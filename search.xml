<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Base64]]></title>
      <url>http://kad0108.github.io/2018/08/04/base64/</url>
      <content type="html"><![CDATA[<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>Base64是一种基于64个可打印（可见）字符来表示二进制数据的表示方式。</p>
<p>用记事本去打开<code>exe</code>、<code>jpg</code>等文件时，会看到一大堆乱码，这是因为二进制文件中包含很多无法显示和打印的字符（计算机中任何数据都是按ascii码存储的，而ascii码的128个字符中有32个是不可见字符）。世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p>
<a id="more"></a>
<p>Base64的可打印字符包括有<code>A-Z</code>、<code>a-z</code>、<code>0-9</code>、<code>+</code>、<code>/</code>共64个字符（还有一个垫字符<code>=</code>）。Base64编码就是将其他所有符号都转换成这个字符集中的字符。</p>
<p>对二进制数据进行处理，每3个字节一组，一共<code>3*8=24</code>bit，将其以<code>6bit</code>进行切分划分为4组，如图。这样每<code>6</code>个二进制位的十进制值就可以得到，也就是ASCII码值。</p>
<p><img src="/2018/08/04/base64/./base64.jpg" alt=""></p>
<p>当字节数不足3时，两个字节的情况，二进制后面补两个0，得到的Base64编码末尾补一个<code>=</code>；一个字节的情况，二进制后面补四个0，得到的Base64编码末尾补两个<code>=</code>。</p>
<h2 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h2><p>JS中提供<code>ArrayBuffer</code>对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（<code>TypedArray</code>视图和<code>DataView</code>视图)来读写，视图的作用是以指定格式解读二进制数据。</p>
<p>一个场景需求是将二进制数据进行Base64编码，因为ArrayBuffer的兼容性，不能使用，但是ArrayBuffer的视图读写方式提供了思路，如何通过整数来处理二进制。维护的数组<code>view</code>其实相当于是ArrayBuffer的一个视图，数组中每个值都不超过<code>2^8</code>，也就是二进制位不超过<code>8</code>位，当然数组需要提前计算好需要开多大且每个值置为<code>0</code>。对于需要将数据的二进制形式放在第<code>i~j</code>位之间的操作，就转变成将数据的每个二进制位塞到数组<code>view</code>的第<code>index / 8</code>个值的第<code>index % 8</code>个二进制位的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var view = [];</div><div class="line">for(var i = 0; i &lt; len; i++) view[i] = 0;</div><div class="line"></div><div class="line">function getBoolNum(num)&#123;</div><div class="line">    if(!!x) return 1;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">function setBit(bitId, bit)&#123;</div><div class="line">    var index = parseInt(bitId / 8);</div><div class="line">    var mod = bitId % 8;</div><div class="line">    if(getBoolNum(view[index] &amp; (1 &lt;&lt; mod)) == bit) return;</div><div class="line">    view[index] ^= (1 &lt;&lt; mod);</div><div class="line">&#125;</div><div class="line">function setVal(bitBegin, bitEnd, val)&#123;</div><div class="line">    for(var i = 0; i &lt; bitEnd - bitBegin; i++)&#123;</div><div class="line">        setBit(i + bitBegin, (val &gt;&gt; i) &amp; 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>处理得到记录了二进制数据的数组<code>view</code>，通过转换为字符串（这样得到的字符串打印出来一般会是乱码，所以才需要Base64编码）来进行Base64编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var str = &apos;&apos;;</div><div class="line">for(var i = 0; i &lt; view.length; i++)&#123;</div><div class="line">    str += String.fromCharCode(view[i]);</div><div class="line">&#125;</div><div class="line">window.btoa(str);</div></pre></td></tr></table></figure>
<h2 id="在URL中的应用"><a href="#在URL中的应用" class="headerlink" title="在URL中的应用"></a>在URL中的应用</h2><p>采用Base64编码因为比较简短，同时不具有可读性，可用于在HTTP环境下传递较长的标识信息。然而，标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的<code>/</code>和<code>+</code>字符变为形如<code>%XX</code>的形式，而这些<code>%</code>号在存入数据库时还需要再进行转换，因为SQL中已将<code>%</code>号用作通配符。</p>
<p>为解决此问题，可采用一种<strong>用于URL的改进Base64</strong>编码，它不在末尾填充<code>=</code>号，并将标准Base64中的<code>+</code>和<code>/</code>分别改成了<code>-</code>和<code>_</code>，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function encodeUrl(str)&#123;</div><div class="line">    return str.replace(/\+/g, &apos;-&apos;).replace(/\//g, &apos;_&apos;).replace(/\=+$/, &apos;&apos;);</div><div class="line">&#125;</div><div class="line">function decodeUrl(str)&#123;</div><div class="line">    var exLen = (4 - str.length % 4) % 4;</div><div class="line">    str = (str + &apos;===&apos;).slice(0, str.length + exLen);</div><div class="line">    return str.replace(/-/g, &apos;+&apos;).replace(/_/g, &apos;/&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么URL需要编码？因为网络标准RFC有硬性规定只有<code>[0-9a-zA-Z]</code>以及一些特殊符号<code>$-_+!*()</code>等才可以不经过编码直接用于URL。同时，由于在URL编码中空格与加号是等价的，因为空格无法表示会替换为加号，所以也需要对加号进行处理。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2008/06/base64.html" target="_blank" rel="external">Base64笔记</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sapiens —— A Brief History of Humankind]]></title>
      <url>http://kad0108.github.io/2018/05/03/sapiens/</url>
      <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这学期无脑的写论文和改论文学习生活实在是百无聊赖，尽管同时也在学习英语看英语原著，但总是感觉有些乏味没能满足我的精神需求。虽然被困在学校困在实验室里，但我的思想不能被束缚。之前听过《人类简史》的大名，偶然在知乎上刷推荐书单看到，就决定读了。从小看的最多都是教科书课外辅导书作文书，可能是因为反感死记硬背，一直不喜欢文科类的科目，只喜欢理科思维性的科目，所以课外阅读很少，也直接导致了我看问题肤浅不够深入。不想说这本书论点论据的正确性，因为我还不够格来评价，只是在看的过程中发现书中很多观点和诠释问题的角度是对我固有思维的冲击，第一次在看书的过程中思维有了饥渴的感觉。看前半部分内容的过程中都在惊叹作者奇特的角度和观点，看到后面慢慢地自己能通过作者独特的视角去思考看待一些问题了。这本《人类简史》应该算是我的思维启蒙书了～～</p>
<a id="more"></a>
<h3 id="整本书看完印象最深的观点是："><a href="#整本书看完印象最深的观点是：" class="headerlink" title="整本书看完印象最深的观点是："></a>整本书看完印象最深的观点是：</h3><p><strong>难点不在于讲故事，而在于要让人相信</strong>。任何形式的群体都需要坚信由想象所构建的秩序才能维持久远。适用于神灵、国家、有限公司等等。</p>
<h3 id="和别人讨论最多的衍生观点是："><a href="#和别人讨论最多的衍生观点是：" class="headerlink" title="和别人讨论最多的衍生观点是："></a>和别人讨论最多的衍生观点是：</h3><p><strong>科学发展是第一生产力</strong>。中国几千年的治乱兴衰都是由于科学发展不能满足由于人口过多而产生的需求。简单说就是当时生产的粮食不够当时的人吃，土地的承载力有限，这也是为什么每个朝代开始的时候一般都政治清明、欣欣向荣，就是因为每个朝代开始前经历过大的战争，消耗了很多人口，生产与需求矛盾不大。随着发展，人口数增加，导致人口又超过了土地的承载力，这个时候社会矛盾极大，极易发生动乱。中国历史上每个朝代都是一个无可奈何的轮回，除非当时的人们可以进行计划生育。现在不必要计划生育，一方面就是由于科技发展保证了还没达到可供养人数的上限。</p>
<hr>
<p>书非借不能读也，也促使我写下了这篇读书笔记。准确地说这应该是第三篇读书笔记，却是第一篇非技术类的阅读笔记。前两篇<a href="http://kadong.space/categories/Reading-Notes/" target="_blank" rel="external">看这里</a>。总是敲键盘，很久没有大篇幅写过字了，所以原谅我潦草的字迹。</p>
<p><img src="/2018/05/03/sapiens/0.jpg" alt=""></p>
<p><img src="/2018/05/03/sapiens/1.jpg" alt=""></p>
<p><img src="/2018/05/03/sapiens/2.jpg" alt=""></p>
<p><img src="/2018/05/03/sapiens/3.jpg" alt=""></p>
<p><img src="/2018/05/03/sapiens/4.jpg" alt=""></p>
<p><img src="/2018/05/03/sapiens/5.jpg" alt=""></p>
<p><img src="/2018/05/03/sapiens/6.jpg" alt=""></p>
<!--
<a href="/2017/08/09/you-dont-know-js-I/" title="You Don't Know JavaScript I —— Scope & Closures">You Don't Know JavaScript I —— Scope & Closures</a><br><a href="/2017/08/10/you-dont-know-js-II/" title="You Don't Know JavaScript II —— This & Object & Prototypes">You Don't Know JavaScript II —— This & Object & Prototypes</a>
<p>–&gt;</p>
-->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git]]></title>
      <url>http://kad0108.github.io/2018/04/22/git/</url>
      <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>毕业🎓前的日子真是度日如年，厌倦反感学校的一切，只能看书学英语参加各种英语角活动看视频，而且除了跑实验写的那点已经很久很久没有敲代码了。。。稍微学点东西安慰自己。。。之前只是知道Git这些命令怎么用，没有更详细地了解过。看廖老师的博文学习再学一遍Git加深印象。</p>
<h2 id="Git：分布式版本控制系统"><a href="#Git：分布式版本控制系统" class="headerlink" title="Git：分布式版本控制系统"></a>Git：分布式版本控制系统</h2><p>Git自动记录每次文件改动，还可以多人协作编辑，即版本控制，Github则是为开源项目免费提供Git存储。</p>
<p>Git是Linus为了方便管理Linux内核开发而开发的一个源码版本控制软件。</p>
<p>分布式版本控制系统没有中央服务器，比集中式版本控制系统 （例如：SVN）安全性高很多。Git不仅仅是不需要联网这么简单，还有极其强大的分支管理。</p>
<p>安装成功后Git需要自报家门，<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;Your Name&quot;</div><div class="line">$ git config --global user.email &quot;email@example.com&quot;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>版本库又名仓库（repository），可以理解为一个目录，这个目录下的所有文件的改动都可以被Git管理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ mkdir repository #创建空目录</div><div class="line">$ cd repository</div><div class="line">$ pwd #显示当前目录</div><div class="line">$ git init #将目录变为Git可管理的仓库</div><div class="line">$ ls -a #可以查看到该目录下多了一个隐藏.git目录</div></pre></td></tr></table></figure>
<p>注意⚠️：版本控制系统只能追踪文本文件的改动，比如TXT文件、网页、代码等。而图片、视频这些二进制文件，版本控制系统只能把二进制文件每次改动串起来，只知道图片从100kb改成了120kb，并不知道具体改了什么。</p>
<p>在<code>repository</code>目录下新建一个文件，做些改动，将文件添加到版本库的步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add &lt;file&gt; #把文件添加到仓库</div><div class="line">$ git commit -m &quot;message...&quot; #把文件提交到仓库，命令执行成功后会得到改动信息</div></pre></td></tr></table></figure>
<p>注意⚠️：可以多次<code>add</code>不同文件，然后<code>commit</code>一次性提交。</p>
<p>继续修改文件，然后运行<code>git status</code>命令可以时刻掌握仓库当前状态。通过命令返回信息可以知道，文件被修改过了，但还没有准备提交的修改。</p>
<p>如果想查看具体做了什么修改，可以使用命令<code>git diff</code>。提交修改和提交新文件的步骤是一样的。</p>
<p><img src="/2018/04/22/git/git-diff.png" alt=""></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>初始化一个Git仓库，使用<code>git init</code>命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<ul>
<li>第一步，使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li>
<li>第二步，使用命令<code>git commit</code>，完成</li>
</ul>
<p>修改文件后查看状态：</p>
<ul>
<li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li>
<li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li>
</ul>
<h2 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h2><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>当不断地修改文件，不断地将修改提交到版本库中，每次<code>commit</code>是保存一个快照。如果文件改乱了或者误删了文件，可以从<code>commit</code>进行恢复。</p>
<p>可以通过<code>git log</code>查看所有的历史改动。想查看简洁版日志可以加上<code>--pretty=oneline</code>参数。其中黄色的一大串字符是版本号<code>commit id</code>，是由SHA1计算出的十六进制数。</p>
<p><img src="/2018/04/22/git/git-log.png" alt=""></p>
<p>每提交一个新版本，Git会将它们自动串成一条时间线。<code>HEAD</code>表示当前版本，<code>HEAD^</code>表示上一个版本，<code>HEAD-100</code>表示上100个版本。想要把当前版本<code>add new line</code>退回到上一个版本<code>add distributed</code>，可以使用命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git reset --hard HEAD^</div></pre></td></tr></table></figure>
<p>可以通过命令<code>cat readme.txt</code>查看文件内容是不是版本<code>add distributed</code>。</p>
<p>如果这时又想回到最新的版本<code>add new line</code>，找到对应的<code>commit id</code>就可以回到指定的版本。版本号不需要写全，前几位即可，Git会自动去找。如果找不到版本号，Git提供了命令<code>git reflog</code>用来记录你的每一次命令。</p>
<p><img src="/2018/04/22/git/git-reset.png" alt=""></p>
<p><img src="/2018/04/22/git/git-reflog.png" alt=""></p>
<p>Git的版本回退速度很快，因为Git内部有个指向当前版本的<code>HEAD</code>指针，当回退版本时，Git只是把指针<code>HEAD</code>从<code>add GPL</code>改为指向<code>add distributed</code>。然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p>
<blockquote>
<p>试了一下如何将本地回滚推送到远端。<br><code>git reset</code>之后是直接在本地版本库里移动<code>HEAD</code>指针到某个<code>commit</code>了，所以不需要<code>add</code>和<code>commit</code>，因为本地工作区没有任何变化。这个时候<code>git push</code>是没有用的，想同步更新远端只能强推<code>git push -f</code>。建议<code>reset</code>在本地操作，强制更新到远端会影响到一起协作开发的小伙伴。<br><code>git revert</code>只是撤销之前某次<code>commit</code>，我认为<code>revert</code>并不是真正意义上的回滚，同样<code>revert</code>是帮你增加一个<code>commit</code>，所以工作区也没有任何变化，不需要<code>add</code>和<code>commit</code>，直接<code>push</code>即可。回滚推送到远端建议采用这种方式。</p>
</blockquote>
<h3 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h3><p>在电脑中能看到的目录，比如<code>repository</code>文件夹就是一个<strong>工作区</strong>。</p>
<p>工作区中有个隐藏的目录<code>.git</code>是Git的<strong>版本库</strong>。版本库中最重要的就是称为stage的<strong>暂存区</strong>，还有Git自动创建的第一个<code>master</code>分支，以及指向<code>master</code>的<code>HEAD</code>指针。</p>
<p><img src="/2018/04/22/git/stage.jpeg" alt=""></p>
<p>前面提到向Git版本库添加文件时分两步进行，实际上第一步<code>git add</code>就是将文件修改添加到暂存区；第二步<code>git commit</code>是将暂存区所有内容提交到当前分支。因为创建Git版本库时，Git自动创建唯一一个<code>master</code>分支，所以<code>git commit</code>是向<code>master</code>分支提交更改。可以在每一步操作过程中通过<code>git status</code>查看状态，判断暂存区是否clean。</p>
<p>文件修改还在工作区，未<code>git add</code>到暂存区时的状态为<code>Changes not staged for commit</code>：</p>
<p><img src="/2018/04/22/git/changes-not-staged.png" alt=""></p>
<p>文件修改已经提交到暂存区时的状态为<code>Changes to be commited</code>：</p>
<p><img src="/2018/04/22/git/changes-to-be-commited.png" alt=""></p>
<p><strong>暂存区</strong>是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</p>
<h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>Git之所以比其他版本控制系统设计的优秀，是因为Git跟踪并管理的是<strong>修改</strong>，而非文件。比如操作过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</div></pre></td></tr></table></figure>
<p>的结果是第二次修改没有被提交。提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别。</p>
<p>因为Git管理的是修改，当使用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>想要提交第二次修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</div></pre></td></tr></table></figure>
<p>理解了Git是如何跟踪修改的，每次修改，如果不<code>add</code>到暂存区，那就不会加入到<code>commit</code>中。</p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>想要丢弃工作区的修改可以使用<code>git checkout -- &lt;file&gt;</code>。命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令。这个命令是将工作区的全部修改全部撤销，这里有两种情况：</p>
<ul>
<li>一种是文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>一种是文件已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>
</ul>
<p>即让文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p>如果想丢弃的修改已经<code>git add</code>到暂存区了，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交，这时用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。</p>
<p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p>
<p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改。想要丢弃工作区的修改继续<code>git checkout -- &lt;file&gt;</code>。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交。</p>
<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm text.txt</div></pre></td></tr></table></figure>
<p>工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了:</p>
<p><img src="/2018/04/22/git/rm.png" alt=""></p>
<p>根据提示，有两个选择：</p>
<ul>
<li>一是确实要从版本库中删除该文件，那就用命令<code>git rm &lt;file&gt;</code>删掉，并且<code>git commit</code>，然后文件就从版本库中被删除了。</li>
<li>另一种情况是删错了，因为版本库里还有呢，所以<code>git checkout -- test.txt</code>可以很轻松地把误删的文件恢复到最新版本。</li>
</ul>
<p><code>git rm &lt;file&gt;</code>的操作相当于<code>rm &lt;file&gt; + git add &lt;file&gt;</code>。</p>
<p><code>git checkout --</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>版本回退总结：</p>
<ul>
<li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<p>撤销修改总结：</p>
<ul>
<li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- &lt;file&gt;</code>。</li>
<li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li>
<li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="#版本回退">版本回退</a>一节，不过前提是没有推送到远程库。</li>
</ul>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。Github网站是提供Git远程仓库托管服务的。本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，设置如下：</p>
<ol>
<li><p>创建SSH Key，<code>cd ~</code>到用户主目录下，查看是否有<code>.ssh</code>目录，其中有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件。如果没有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>登陆GitHub，打开“Account settings”-&gt;“SSH Keys”页面，点“Add SSH Key”，粘贴<code>id_rsa.pub</code>文件的内容。</p>
</li>
</ol>
<p>GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。GitHub允许你添加多个Key。只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。</p>
<p>在Github上“create a new repo”，根据提示，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p><img src="/2018/04/22/git/origin-repo.jpeg" alt=""></p>
<p>Git默认远程库的名字就是<code>origin</code>。把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p>
<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。</p>
<p>至此，你拥有了真正的分布式版本库！</p>
<h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>上次讲的是先有本地库，后有远程库的时候，如何关联远程库。下面讲的是，远程库已经准备好了，如何从远程库克隆：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone &lt;Git URL&gt;</div></pre></td></tr></table></figure>
<p>也许还注意到，GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p>
<p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p>
<p><img src="/2018/04/22/git/git-clone.jpeg" alt=""></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>添加远程库总结：</p>
<ul>
<li>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</li>
<li>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</li>
<li>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改，把本地<code>master</code>分支的最新修改推送至GitHub；</li>
<li>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</li>
</ul>
<p>从远程库克隆总结：</p>
<ul>
<li>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</li>
<li>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</li>
</ul>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支就是科幻电影里面的平行宇宙。分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>Git的分支与其它版本控制系统相比是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>在<a href="#版本回退">版本回退</a>一节里提到，每次提交Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p>
<p><img src="/2018/04/22/git/master.png" alt=""></p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev  #-b参数表示创建并切换，相当于以下⬇️两条命令</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch dev  #新建分支</div><div class="line">$ git checkout dev #切换到新分支</div></pre></td></tr></table></figure>
<p><img src="/2018/04/22/git/dev.png" alt=""></p>
<p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p>
<p>可以用<code>git branch</code>查看当前分支，命令会列出所有分支，当前分支前面会标有<code>*</code>号。</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如对文件进行修改，新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<p><img src="/2018/04/22/git/dev-commit.png" alt=""></p>
<p>此时<code>git checkout master</code>切换回<code>master</code>分支会发现，文件并没有被修改，因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p>
<p><img src="/2018/04/22/git/checkout-branch.png" alt=""></p>
<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p>
<p><img src="/2018/04/22/git/merge.png" alt=""></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>具体做法是，在<code>master</code>分支上，把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git merge dev</div><div class="line">Updating 9452784..4ef8073</div><div class="line">Fast-forward</div><div class="line"> readme.txt | 1 +</div><div class="line"> 1 file changed, 1 insertion(+)</div></pre></td></tr></table></figure>
<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p>
<p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p>
<p>合并完分支后，甚至可以使用命令<code>git branch -d dev</code>删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p>
<p><img src="/2018/04/22/git/delete-dev.png" alt=""></p>
<p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了。</p>
<p>如果新创建的<code>dev</code>分支没有合并就想要删除使用命令<code>git branch -d dev</code>会报错并提醒<code>dev</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令<code>git branch -D dev</code>。</p>
<p>因为创建、合并和删除分支非常快，所以Git鼓励使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当不同的分支上的修改均已提交，但是当修改内容有冲突时，合并操作就会有问题。比如<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，就是这样：</p>
<p><img src="/2018/04/22/git/diff-branch.png" alt=""></p>
<p>这时切换到<code>master</code>分支进行<code>git merge feature1</code>操作将<code>feature1</code>分支合并到当前<code>master</code>分支时，Git会提示修改存在冲突，必须手动解决冲突再提交。<code>git status</code>可以查看冲突文件。</p>
<p>直接查看修改内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Git is a distributed version control system.</div><div class="line">Let&apos;s learn git branch.</div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</div><div class="line">Creating a new branch is quick &amp; simple.</div><div class="line">=======</div><div class="line">Creating a new branch is quick AND simple.</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</div></pre></td></tr></table></figure>
<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容。对冲突内容进行修改保存，并再次提交，<code>master</code>分支和<code>feature1</code>分支变成了：</p>
<p><img src="/2018/04/22/git/conflict-fixed.png" alt=""></p>
<p>用带参数的<code>git log --graph --pretty=oneline --abbrev-commit</code>也可以看到分支的合并情况:</p>
<p><img src="/2018/04/22/git/git-log-merge.png" alt=""></p>
<blockquote>
<p>这里想了解修改冲突内容是在<code>master</code>分支上进行的还是同时在<code>master</code>和<code>dev</code>分支上进行，所以在修改冲突内容后尝试切换分支，结果报error了，提醒文件需要进行合并。使用<code>git status</code>查看，提示<code>You have unmerged paths</code>。然后继续在当前<code>master</code>上做别的修改也还可以，只是在<code>git add</code>和<code>git commit</code>之前不能切分支，在commit之后<code>master</code>和<code>dev</code>分支上的内容是一致的。所以暂且认为修改冲突是在<code>master</code>分支上进行的，而且修改之后必须对冲突进行操作，可以commit或者abort。</p>
</blockquote>
<p>最后删除<code>feature1</code>分支<code>git branch -d feature1</code>工作完成。</p>
<h3 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h3><p>在实际开发中应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p><img src="/2018/04/22/git/branch-team.png" alt=""></p>
<h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你接到一个修复一个代号101的bug的任务时，想要创建一个分支<code>issue-101</code>来修复它，但是当前正在<code>dev</code>上进行的工作工作只进行到一半，还没法提交，但是，必须在两个小时内修复该bug，怎么办？</p>
<p>Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash</div></pre></td></tr></table></figure>
<p>用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支。</p>
<p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支。</p>
<p>这时再回到<code>dev</code>分支继续干活，<code>git status</code>查看工作区是干净的，想要查看刚刚保存的工作现场：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git stash list</div><div class="line">stash@&#123;0&#125;: WIP on dev: 96086b0 add test</div></pre></td></tr></table></figure>
<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<ol>
<li><p>用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p>
</li>
<li><p>用<code>git stash pop</code>，恢复的同时把stash内容也删了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git stash pop</div><div class="line">On branch dev</div><div class="line">Changes not staged for commit:</div><div class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</div><div class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</div><div class="line"></div><div class="line">	modified:   readme.txt</div><div class="line"></div><div class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</div><div class="line">Dropped refs/stash@&#123;0&#125; (52454198962524c309a2f575a2b0ecd1c704487a)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>也可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash apply stash@&#123;0&#125;</div></pre></td></tr></table></figure>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p>
<p>要查看远程库的信息，用<code>git remote</code>，或者用<code>git remote -v</code>显示更详细的信息，会显示可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>
<h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上。</p>
<p>前面<a href="#远程仓库">远程仓库</a>部分有提到首次推送应该使用<code>-u</code>参数，不仅仅是推送，而且将本地<code>master</code>分支与远端<code>master</code>分支对应起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push -u origin master</div></pre></td></tr></table></figure>
<p>如果本地有多个分支，并且切换到另一个<code>dev</code>分支上，这时想推送本地<code>master</code>分支到远端，应该使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div></pre></td></tr></table></figure>
<p>如果本地有多个分支，而且当前分支也正好是<code>master</code>分支，那么可以进一步简化命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push</div></pre></td></tr></table></figure>
<p>如果要推送其他分支道理是一样的，如果在首次没有使用<code>-u</code>，那么之后每次推送都需要指明是将本地哪个分支推送到远端，这时如果直接使用<code>git push</code>命令会提醒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git push</div><div class="line">fatal: The current branch dev has no upstream branch.</div><div class="line">To push the current branch and set the remote as upstream, use</div><div class="line"></div><div class="line">    git push --set-upstream origin dev</div></pre></td></tr></table></figure>
<p>不是所有分支都需要向远端推送，比如bug分支就没必要推送远端。</p>
<h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p>
<p>模拟多人提交，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆，当从远程库clone时，默认情况下，只能看到本地的<code>master</code>分支，可以用<code>git branch</code>命令查看。要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是用这个命令创建本地<code>dev</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev origin/dev</div></pre></td></tr></table></figure>
<p>在<code>dev</code>上继续修改，并把修改的<code>dev</code>分支<code>push</code>到远程。</p>
<p>已经完成模拟他人推送提交，碰巧你也对同样的文件作了修改，并试图推送：</p>
<p><img src="/2018/04/22/git/git-pull.png" alt=""></p>
<p>推送失败，提示远端可能有新的提交和本地提交冲突，解决办法是先<code>git pull</code>将最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送。</p>
<p>因此，多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>创建合并分支总结：</p>
<ul>
<li>Git鼓励大量使用分支：</li>
<li>查看分支：<code>git branch</code></li>
<li>创建分支：<code>git branch &lt;branch-name&gt;</code></li>
<li>切换分支：<code>git checkout &lt;branch-name&gt;</code></li>
<li>创建+切换分支：<code>git checkout -b &lt;branch-name&gt;</code></li>
<li>合并某<code>&lt;branch-name&gt;</code>分支到当前分支：<code>git merge &lt;branch-name&gt;</code></li>
<li>删除分支：<code>git branch -d &lt;branch-name&gt;</code></li>
<li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;branch-name&gt;</code>强行删除。</li>
</ul>
<p>解决冲突总结：</p>
<ul>
<li>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</li>
<li>用<code>git log --graph</code>命令可以看到分支合并图。</li>
</ul>
<p>分支策略总结：</p>
<ul>
<li>Git分支十分强大，在团队开发中应该充分应用。</li>
<li>合并分支时，加上<code>--no-ff</code>参数，比如<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>，就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</li>
</ul>
<p>Bug分支总结：</p>
<ul>
<li>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</li>
<li>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</li>
</ul>
<p>多人协作总结：</p>
<ul>
<li>查看远程库信息，使用<code>git remote -v</code>；</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>
<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>
</ul>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>Tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起，commit_id则相对比较难记。</p>
<blockquote>
<p>这里想起来之前在MSRA实习时做的一个工作是重构小英的一个游戏模块，重构完之后上dev和staging分支进行线上测试然后发布，mentor要求我对旧版本和重构后的新版本代码打tag标记，方便出现什么问题时及时取用。</p>
</blockquote>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>首先切换到需要打标签的分支上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch</div><div class="line">$ git checkout xxx</div></pre></td></tr></table></figure>
<p>然后，敲命令<code>git tag &lt;tag-name&gt;</code>就可以打一个新标签。</p>
<p>可以用命令<code>git tag</code>查看所有标签，这里标签不是按时间顺序列出，而是按字母排序的。</p>
<p>默认标签是打在最新提交的commit上的，如果想要给以前的commit打，方法是通过<code>git log --pretty=oneline --abbrev-commit</code>找到历史提交的commit_id，然后打上tag即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag &lt;tag-name&gt; &lt;commit_id&gt;</div></pre></td></tr></table></figure>
<p>可以用<code>git show &lt;tag-name&gt;</code>查看标签信息。</p>
<p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -a &lt;tag-name&gt; -m &lt;message&gt; &lt;commit_id&gt;</div></pre></td></tr></table></figure>
<p>还可以通过<code>-s</code>用私钥签名一个标签。</p>
<h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>如果标签打错了，也可以删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -d &lt;tag-name&gt;</div></pre></td></tr></table></figure>
<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tag-name&gt;</code>。或者一次性推送全部尚未推送到远程的本地标签<code>git push origin --tags</code>。</p>
<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag -d &lt;tag-name&gt;</div><div class="line">$ git push origin :refs/tags/v0.9</div></pre></td></tr></table></figure>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>创建标签总结：</p>
<ul>
<li>命令<code>git tag &lt;tag-name&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit_id；</li>
<li>命令<code>git tag</code>可以查看所有标签；</li>
<li>命令<code>git show &lt;tag-name&gt;</code></li>
<li><code>git tag -a &lt;tag-name&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li>
<li><code>git tag -s &lt;tag-name&gt; -m &quot;blablabla...&quot;</code>可以用PGP签名标签。</li>
</ul>
<p>操作标签总结：</p>
<ul>
<li>命令<code>git push origin &lt;tag-name&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tag-name&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tag-name&gt;</code>可以删除一个远程标签。</li>
</ul>
<h2 id="使用Github"><a href="#使用Github" class="headerlink" title="使用Github"></a>使用Github</h2><p>想要在Github上参与一个开源项目，可以点<code>Fork</code>在自己的帐号下clone一个对应的开源项目仓库，然后从自己的帐号下将项目clone到本地，这样自己才能推送修改。自己拥有Fork后的仓库的读写权限。</p>
<p>如果想修改这个开源项目的一个bug，可以本地修改之后推送到自己的仓库中。如果希望开源项目官方可以接受你的修改，可以在GitHub上发起一个pull request。通过推送pull request给官方仓库来贡献代码。</p>
<h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>。</p>
<p>解决办法是在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>忽略文件的原则是：</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ol>
<p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a></p>
<p>检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p>
<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了，如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add -f App.class</div></pre></td></tr></table></figure>
<p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git check-ignore -v App.class</div></pre></td></tr></table></figure>
<p><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000" target="_blank" rel="external">配置别名－Link</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="external">搭建Git服务器－Link</a></p>
<p><a href="git-cheatsheet.pdf">GIT CHEAT SHEET.pdf</a></p>
<h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>因为这次学习Git过程中配置了另一个Github小号的信息，导致在<code>hexo deploy</code>的时候报错提示<code>permission denied</code>。一开始一直以为是<code>SSH key</code>的问题，就重新生成了一遍<code>SSH key</code>然后添加到Github，发现并不好使。而且我跑了命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git config user.name</div><div class="line">$ git config user.email</div><div class="line">$ git remote -v</div></pre></td></tr></table></figure>
<p>验证信息都是对的，那就奇怪了，怎么可能提交的时候还认为本地是Github小号呢，有想到可能是cache的问题，查了一下然后试了一下，果然。。。</p>
<p><img src="/2018/04/22/git/git-cache.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2017 Summary]]></title>
      <url>http://kad0108.github.io/2018/01/04/2017-summary/</url>
      <content type="html"><![CDATA[<p>以前都没有总结过去一年的习惯，2017年感觉是我成长到现在最充实最有成就感的一年，想记录下来，当未来某天回首这一年能够为自己这一年的奋斗付出成长而热泪盈眶。</p>
<blockquote>
<p>2017年，我24周岁，研三，在大连上学已经是第七年。</p>
</blockquote>
<a id="more"></a>
<p>感觉会写成流水账，哈哈~~就按时间先后来写这一年的经历了。</p>
<p>2017年的春节过得超级热闹，爸爸妈妈招呼一大家人一起在忻州的新家过年，自己也是过得最有压力的一个春节，想放开玩但总想着马上要找实习找工作，那时候对自己还不是特别自信，大过年还在刷题总结前端知识点发博文。</p>
<p>其实自己算法一般般，可能因为做过ACM给别人造成一种印象以为算法很好（捂脸），返校前面了google，希望将来可以成为google的一员，超级梦想。</p>
<p>2016年底抱着试试的心态去面了SAP的VT项目，经过电面、笔试、群面、现场面四轮居然通过了，很开心，是外企很想体验一下，不过研究生导师管的很严，还担心自己偷溜出去实习被发现，再加上自己还需要发一篇论文的压力，下学期还得找正式的暑期实习，这么多考虑加在一起让我很纠结，怕自己不能承受，但是机会摆在面前怎么能拒绝，所以选择了去实习。每周去三个半天，因为VT项目这种形式是培训SAP内部语言ABAP，自己并不是太感兴趣，所以只实习了一个半月就离职了。不说这段实习能给自己带来多少提升与帮助，只说这段经历这段体验以及我各方面了解到的信息让我知道<strong>年轻还是要拼一把不能太安逸了</strong>。</p>
<p>从SAP离职后开始找正式找暑期实习，本科毕业那会儿保了研就乖乖待在研究生导师实验室里了，好像什么都没有做，回想了一下没有想起来任何值得称道的事情。开始找实习就是广投海投，简历一遍遍完善，记录下每一次面试内容，开始的每一次的面试都让自己有提升，慢慢发现各大公司前端面试考察的内容都很接近了，之后就面的很得心应手，基本面过的公司都拿到了实习offer，不想夸自己有多棒拿了有多少offer，总之越来越肯定自己变得自信了。必须提到印象最深的两家面试经历：</p>
<p>2月份的时候无意投递了MS，像GG和MS，实验室上几届学长都有去实习或工作，感觉都是我可望不可即的顶尖国际企业，没有想过可以有幸成为其中的一员。清楚的记得是3月底，当时还在睡午觉，接到电话问能不能满足来MS实习，我其实是有点半信半疑的想着会不会是骗人的，后来面试流程以及通知Offer的效率简直让我惊呆了！是愚人节那天下午，连着电面两面，都是算法题，幸好自己发挥的挺好答得不错，然后面试完等了半小时左右就通知我通过了面试正式Offer已经开始走流程发放。惊人的速度，效率太高了！和T家的面试形成了鲜明对比（这里必须吐槽一下）。</p>
<p>让上一届学长推荐了T，这里必须感谢玉姐，帮我询问了锁定释放简历的部门hr，在内推流程结束前把工作地改成了深圳。然后整个面试流程拖了有一个月之久，从3月底到4月底，前后一共面了有六面，有一面还问了正常前端面试不太会问的AC自动机、trie树、kmp、dp。。。幸好别的难的算法不会或者不了解，问的这些还懂点皮毛（捂脸），然后好像面试反馈还挺好（偷笑）。因为自己二逼偶然在知乎上结识了其中某个面试官，后来知道是组里leader，之后到正式找工作这段时间一直在沟通，给我各种“鸡汤”，哈哈，也是我决定选择第一份工作加入T的主要原因。</p>
<p>找实习基本告一段落了，得考虑写小论文了，最好也必须得在暑期出去实习之前投出去。实验在年前跑完了，写论文这个过程太折磨人，我本来就打小不爱学语文不爱写作，所以对论文这个事超级抵触但是也不能不做。特别感谢超哥的指导，顺利发了小论文可以放心出去实习了。</p>
<p>其实这里去MS还是去T让我纠结了很久，谁让研究生导师管得太严让我大胆的想法没能实现。这里还得感谢小胖学姐对我人生路上第一个选择的正确引领。总感觉自己如果实习不去MS，之后工作很难再进，会让自己后悔的，出于自己的小私心以及一些客观的约束，最后还是选择了去MS。实习结束回校后其实一直想写一篇实习总结来着，因为这段经历真的太难忘也让我感到自己也在发光发热！</p>
<hr>
<p><img src="/2018/01/04/2017-summary/msra0.jpg" alt="MS Building"></p>
<p>实习期间开始我是有每天记录自己做了什么工作的，到后来就每周记一次了。</p>
<p>来MSRA实习，第一周超级无敌兴奋，兴奋到什么程度呢，平常在学校我每天中午不睡午觉下午就困到睁不开眼睛，来实习我每天早晨不到6点就起床收拾出门去上班，中午不睡觉吃完饭就回到工位上干活，晚上工作到去赶末班地铁，11点半左右回到住的地方。就这个亢奋的状态持续了很久，睡的少一点都不觉得困。</p>
<p><img src="/2018/01/04/2017-summary/msra5.jpeg" alt="MS Center"></p>
<p>公司环境自然好的没法说，福利待遇也超赞，给外地实习生提供酒店住宿，太人性化了，到目前为止只知道G和M会给实习生提供很好的住宿。组里的小伙伴们实习生占大部分，而且一半左右都是北大的，刚开始一听他们的学校就感觉，哇，好厉害，我这么挫的学校都不好意思说了，只能更努力些认真完成分配给自己的任务。</p>
<p>我加入的是<a href="http://www.engkoo.com/" target="_blank" rel="external">微软小英</a>团队，当时一面面试官是我进组之后的mentor，二面面试官是组里的leader。小英小组里每天上午11点都要开会（被称作scrum），每个人总结前一天做的任务然后更新工作面板；每周一下午大组开一个大会，由leader给大组里的大leader总结上一周项目进展；后来组里接了别的项目还得开会，有时候一白天就开会了。。。其实当时对这种一大堆的会是很不理解的。。。</p>
<p><img src="/2018/01/04/2017-summary/msra3.jpeg" alt="MS Hackthon"></p>
<p>想到哪里就直接写了，也没想着整点文章结构内涵啥的。嗯，想起来当时就是给自己安排的几个任务，其中有一个就是完全是体力活，就是给对用户所有的点击都打log给后台，虽说也有很多自动化前端测试工具，但是重点是得知道每个点击处的信息。。。这个任务当时让我超级烦躁，感觉很无脑，但是也得认真做好好做。其实我还是历练不够，对于这种情况这种工作安排，我以后遇到应该怎么处理呢？</p>
<p>后来又给自己安排的任务是重构小英里面的wordcrush游戏模块，这个工作也是后来找工作面试时最多最主要问我的地方，都会问我重构这个项目我会考虑哪些之类的问题。这里需要记住的地方就是，这块的工作是我自己独立完成的，为了方面后面别人进行维护，一定要写明操作文档！！</p>
<p><img src="/2018/01/04/2017-summary/msra6.jpeg" alt="Xiaoying WordCrush"></p>
<p>再后来开始做pearson的开发，只有两个前端开发，任务比较重，当时自己还得准备找工作，有点焦虑，状态也不太好，虽然自己也尽心尽力去完成了任务，但是在任务分配上自己有所推脱。。。把一部分任务丢给了另一个前端实习生，感觉很惭愧，实在汗颜。希望自己以后工作遇到很重的任务尽量能让自己保持一个平和的心态和状态。</p>
<p>有时候会是这种情况，自己的工作是依赖于别人的工作进度的。我做前端开发，就需要后端的接口和数据来渲染，但实际上两者的进度必须是同时进行的，所以我前期的开发基本都是写假数据渲染。印象最深的那次工作到凌晨4点为了赶一个阶段性的甲方ddl，浏览器里调试都是正常的，一部署到手机端就各种问题，就改bug改了好久。其实应该学会变通的，因为只是想要录制操作流程视频，完全可以在浏览器里录制，不需要必须在手机端，这样大家就不用工作熬夜到那么晚了。这是我长这么大第一次通宵。</p>
<p><img src="/2018/01/04/2017-summary/msra8.jpeg" alt="MSRA Family Fest"></p>
<p>组里用的前端框架算得上鼻祖级别的了，相当老。。。所以就有了我的其中一个重构的工作。慢慢知道了大公司的项目代码都会存在这样的问题，会因为项目年代久、代码量大等等一些原因不方便或者短期内不考虑整体重构。然后还有一点我必须吐槽，因为代码会经手很多人，很多人写很多人维护，全都不写注释！！！整个一大坨代码不写注释让维护工作太费劲，所以我在完成自己任务代码时就会写注释。</p>
<p>慢慢工作做了一段时间感觉自己好像基本没什么思考的时间，开发工作很重，基本都是在赶ddl，感觉自己没什么长进了。其实自己之前也有尝试去学习现在一些很火框架的底层原理，但是学起来又没多大兴趣了。。。不得不让我思考我的这个职业发展以及自我进步的问题。后来有一次吃饭，我问同事有没有感觉工作做久了就没什么进步，同事有同感，但是他和我说来MSRA实习，不只是工作，还应该去观察看组里的leader是如何运筹帷幄，去了解一个产品的生命周期。嗯，自己确实还有很多需要去学习进步的地方。</p>
<p><img src="/2018/01/04/2017-summary/msra4.jpeg" alt="MS Slogan"></p>
<p>感触一定不止这些，可能是时间过去了久了一点，说不定之后啥会儿回想起来会文思泉涌，哈哈。在MSRA的这段实习会是我很珍贵的记忆和经历，我为我曾是MSRA的一员感到骄傲。还有很棒的小英团队还有很nice到现在每天都给我的英文阅读点赞的mentor，感恩一路上碰到的每个人。</p>
<p><img src="/2018/01/04/2017-summary/msra10.jpeg" alt="MSRA Xiaoying"></p>
<hr>
<p>因为自己想去南方工作，北方自然环境毕竟比不上南方，所以也尽量只考虑了南方的工作地点和公司。杭州是我很喜欢很喜欢的城市，去过三次，两次是去面网易云音乐。对杭州真的有种说不出来的特殊感情，就是感觉很舒服，第一次在西湖看喷泉我就哭了，觉得在这个城市生活的人真的好幸福，希望自己以后能在这个城市定居。</p>
<p>很感谢遇到的腾讯面试官，能够在只有实习电面反馈的情况下认可我，为我校招开绿灯没有面试直接发了offer。感觉是我职业路上的一位贵人，想起刘邦的用人之道：“夫运筹帷幄之中，决胜千里之外，吾不如子房；镇国家，抚百姓，给馈饷，不绝粮道，吾不如萧何；连百万之军，战必胜，攻必取，吾不如韩信。此三人，皆人杰也，吾能用之，此吾所以取天下也”。以后工作中有这样一位认可自己看重自己的leader感觉很幸运。很期待。</p>
<p>有个字述一年的活动，我给自己总结的是“<strong>行</strong>”，一路都在努力进步前行。<strong>认真做好每件事，感恩一路上遇到的人和事，投资自己，提升自己，站在阳光里。</strong></p>
<p>新的一年对自己有很多期待：刚入手了kpw，希望可以提升自己的阅读量（小时候书读的少（捂脸）），尤其是英文阅读；运动要一直坚持，让自己一直健健康康的；拓宽自己的知识面，技术知识面，找到自己感兴趣深入的领域有所提升；一直都很羡慕出国留学的同学，被周围同学问过很多次为什么没想过出国，我很想，只是我不想让家里因为我留学增添负担，所以要攒钱供自己出国留学；希望萌卓能够拿到Google的Offer；自己和父母、妹妹、萌卓一起，都能健康、快乐、永远年轻～～</p>
<p>Happy New Year!</p>
<p><img src="/2018/01/04/2017-summary/fireworks.jpg" alt="Happy New Year!"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Nonlinear Dimensionality Reduction —— LE & LLE]]></title>
      <url>http://kad0108.github.io/2017/11/26/reduction/</url>
      <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近恶补了线性代数的知识，大一时《线性代数》的课本居然一直留着，惊讶到我了，因为本科毕业时把所有课本都卖了，不知怎么想的唯独没卖《线性代数》这本书，当时居然知道三年后自己会用到，感觉好神奇😄。特别推荐一下<a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzIyMTU0NDMyNA==&amp;scene=124&amp;#wechat_redirect" target="_blank" rel="external">马同学高等数学</a>公众号以及感谢<a href="https://github.com/dovebaby" target="_blank" rel="external">@大壮学长</a>的讲解。</p>
<h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p>高维数据意味着需要超过两个或三个维度来表示数据，在高维情形下出现的数据样本稀疏、距离计算困难等问题，是所有机器学习方法共同面对的严重障碍，称为“维数灾难”。</p>
<p>缓解维数灾难的重要途径是降维，即通过某种数学变换将原始高维属性空间转为一个低维子空间，在这个子空间中样本密度大幅提高，距离计算也变得更为容易。为什么能降维呢？因为很多时候，观测或收集到数据样本虽然是高维的，但与学习任务相关的也许仅是某个低维分布，即高维空间中的一个低维嵌入（embedding）。</p>
<a id="more"></a>
<p>基于线性变换来进行降维的方法称为线性降维方法，如PCA（Principal Component Analysis）、LDA（Linear Discriminant Analysis）。PCA降维原则是投影后数据尽可能分散即方差大，希望方差大的方向上数据无关即协方差为0，但PCA不一定有助于数据分类。LDA的降维原理是使降维后数据间类内距离尽可能小，类间距离尽可能大，是带标签的降维方法。</p>
<p><strong>其实不同的降维方法就是保持了低维不同的样本相关性。</strong></p>
<p>很多时候我们不知道数据的具体特征（高维信息），而仅仅知道数据与数据之间的相似程度。这种情况下对数据降维，必然要尽可能保证原来相似的数据在降维后的空间中依然相似，不相似的数据还是距离很远。解决这类问题通常采用非线性降维方法（Nonlinear Dimensionality Reduction）：LE（Laplacian Eigenmaps）、LLE（Locally-linear embedding）。</p>
<h2 id="LE"><a href="#LE" class="headerlink" title="LE"></a>LE</h2><p>LE 和 LLE 都是从图的角度去构建数据之间的关系，图中每个点代表一个数据，每一条边权重代表数据之间的相似程度，越相似权值越大，并且它们都假设数据具有局部结构性质。LE假设每一个点都只与它距离最近的点相似，远的数据相似度为0，降维后相近的点仍保持相近。</p>
<p>设 $y_i \in R^{d \times 1}$ 是样本 $i$ 在低维（降到 $d$ 维）子空间中的向量表示，$w_{ij}$ 是点 $i$ 和 $j$ （ $j$ 为 $i$ 的 $k$ 近邻）之间的权重值。希望能够使降维后样本 $k$ 近邻两点之间距离越小，$w$ 越大则越相似，则要优化的目标函数为</p>
<p>$$<br>\sum_{ij} (y_i - y_j)^2 w_{ij}<br>$$</p>
<p>将目标函数展开，先看 $\sum_{ij} y_i^2 w_{ij}$ ，遍历 $j$ 则有 $D_i = \sum_j w_{ij}$</p>
<p>$$<br>\sum_{ij} y_i^2 w_{ij}<br> = \sum_{ij} y_i^2 \sum_j w_{ij}<br> = \sum_i y_i^2 D_i<br> = \sum_i y_i D_i y_i^T<br> = tr(Y D Y^T)<br>$$</p>
<p>其中 $Y = (y_{j1}, y_{j2}, \dots, y_{jk}) \in R^{d \times k}$，填充0至 $R^{d \times n}$，其中 $D$ 为对角阵：</p>
<p>$$<br>\begin {pmatrix}<br>     D_1 &amp; &amp; &amp; 0 \\<br>     &amp; D_2 \\<br>     &amp; &amp; \ddots  \\<br>     0 &amp; &amp; &amp; D_n<br>\end {pmatrix}<br>$$</p>
<p>$y_i D_i y_i^T$ 是 $Y D Y^T$ 对角线上的元素，所以转为求迹（trace）。</p>
<p>再看 $\sum_{ij} y_i y_j w_{ij} ＝ tr(Y W Y^T)$，其中矩阵 $W \in R^{n \times n}$ 是样本相似度矩阵，这个相似度怎么度量，可以自由定，比如高斯核函数 $w_{ij} = exp(-||x_i - x_j||^2 / t)$ ，样本点之间距离越小，$w$ 值越大也就越相似。一般为了让样本点 $i$ 和 $j$ 互相在彼此的邻域内，做此处理 $W = \frac{W + W^T}{2}$ 。</p>
<p>有拉普拉斯矩阵 $L = D - W$，所以目标函数变为：</p>
<p>$$<br>\begin{equation}<br>\begin{split}<br>arg min \quad tr(Y^T L T) \newline<br>s.t. \quad  Y D Y^T = I<br>\end{split}<br>\end{equation} \tag {1}<br>$$ </p>
<h2 id="LLE"><a href="#LLE" class="headerlink" title="LLE"></a>LLE</h2><p>LLE假设样本点可以由 $k$ 近邻的样本点线性表示，并且投影前后线性关系权重系数不变。</p>
<p>LLE的算法步骤为：</p>
<ol>
<li><p>找每个样本点的 $k$ 个近邻点</p>
</li>
<li><p>由每个样本点的近邻点计算该样本点的局部重建权值矩阵</p>
</li>
<li><p>计算样本点的降维表示</p>
</li>
</ol>
<p><img src="/2017/11/26/reduction/lle.png" alt="LLE算法实现"></p>
<p>我们希望能够通过 $k$ 近邻的样本点来线性重构原样本点，定义误差函数为 </p>
<p>$$<br>min \sum_i^n ||x_i - \sum_j^k w_{ij} x_{ij}||^2<br>$$</p>
<p>其中 $x_{ij} (j = 1,2,\dots,k)$ 是 $x_i$ 的 $k$ 个近邻点；$w_{ij}$ 是 $x_i$ 和 $x_j$ 之间的权值，满足 $\sum_j^k w_{ij} = 1$。</p>
<blockquote>
<p>求解重构权重矩阵</p>
</blockquote>
<p>$$<br>\begin{split}<br>||x_i - \sum_k^k w_{ij} x_{ij}||^2 =&amp; ||\sum_j^k w_{ij} x_i - \sum_j^k w_{ij} x_{ij}||^2 \newline<br>=&amp; \sum_j^k ||(x_i - x_j) w_{ij}||^2 \newline<br>=&amp; \sum_j^k w_{ij}^T (x_i - x_j)^T (x_i - x_j) w_{ij} \newline<br>=&amp; tr(W_i^T (X_i - X_j)^T (X_i - X_j) W_i)<br>\end{split}<br>$$ </p>
<p>其中 $W_i = (W_{i1}, W_{i2}, \dots, W_{ik})^T \in R^{k \times 1}$, $X_j = (X_{j1}, X_{j2}, \dots, X_{jk})$, $X_i = (X_i, X_i, \dots, X_i) \in R^{D \times k}$。</p>
<p>令 $Z_i = (X_i - X_j)^T (X_i - X_j)$，有 $\sum_j^k w_{ij} = W_i^T I_k = 1$, $I_k$ 是 $k$ 维的全1向量。通过拉格朗日乘子法（Lagrange Multiplier）求解带约束的目标函数，构造拉格朗日函数：</p>
<p>$$<br>L(\alpha, \lambda) = W_i^T Z_i W_i + \lambda(W_i^T I_k - 1)<br>$$</p>
<p>由 $\frac{\partial L}{\partial W} = 0$ 得 $W_i = - \lambda Z_i^{-1} I_k/2$，再加上约束条件，则结果为：</p>
<p>$$<br>W_i = \frac{Z_i^{-1} I_k}{I_k^T Z_i^{-1} I_k}<br>$$</p>
<p>比如向量 $(2,3,4,5)^T$ 要想满足求和为1，则 $(2/14, 3/14, 4/14, 5/14)^T$, 即 $(1,1, \dots, 1)(2,3,4,5)^T$。</p>
<blockquote>
<p>求解低维表示</p>
</blockquote>
<p>根据原始空间 $k$ 近邻表示求得权重矩阵 $W_i$，LLE假设降维后低维空间中样本点之间仍然保持一致的线性关系，设低维表示为 $y_i \in R^{d \times 1}$，则低维目标函数为:</p>
<p>$$<br>min \sum_i^n ||y_i - \sum_j^k w_{ij} y_j||^2<br>$$</p>
<p>其中 $W_i = \sum_j^k w_{ij} \in R^{k \times 1}$填充0至 $R^{n \times 1}$, </p>
<p>$Y = (y_{1}, y_{2}, \dots, y_{d}) \in R^{d \times n}$</p>
<p>$y_i = Y1_i$，$1_i = (0, \dots, 1, \dots, 0)^T$ 是只有第 $i$ 位为1的 $R^{n \times 1}$ 的列向量</p>
<p>则：</p>
<p>$$<br>\begin{split}<br>\sum_i^n ||y_i - \sum_j^k w_{ij} y_j||^2 =&amp; \sum_i^n ||Y1_i - YW_i||^2 \newline<br>=&amp; Q_1^TQ_1 + Q_2^TQ_2 + \cdots + Q_n^TQ_n \quad//Q_i = Y1_i - YW_i \newline<br>=&amp; tr(Y(I-W)(I-W)^TY^T)<br>\end{split}<br>$$</p>
<p>其中 $Q_i^TQ_i$ 恰好是 $（YI-YW）^2$ 对角线上的元素。</p>
<p>则令 $M = (I-W)(I-W)^T$ 优化目标函数为：</p>
<p>$$<br>\begin{equation}<br>\begin{split}<br>&amp; argmin \quad tr(YMY^T) \newline<br>&amp; s.t. \quad \sum_i^n y_i = 0 \newline<br>&amp; s.t. \quad \frac{1}{n} \sum_i^n y_i y_i^T = I<br>\end{split}<br>\end{equation} \tag {2}<br>$$</p>
<p>通过拉格朗日乘子法求解，问题变为 $MY = \lambda Y$, 求矩阵 $M$ 最小的 $d$ 个特征值对应的 $d$ 个特征向量组成的 $Y = (y_1, y_2, \dots, y_d)$，最小的特征值0不能反映数据特征，通常选取第 $2 \sim d+1$ 个。</p>
<blockquote>
<p>有关约束条件</p>
</blockquote>
<p>因为低维表示 $y$ 有平移不变性，即通过加减常数进行平移，所以通过约束 $\sum_i^n y_i = 0$ 将低维表示限制在原点范围内。正交约束是因为希望降维后任何一维都不能通过其他维表示得到。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://cs.nyu.edu/~roweis/lle/" target="_blank" rel="external">Locally Linear Embedding</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Face Recognition via Sparse Representation]]></title>
      <url>http://kad0108.github.io/2017/10/30/sparse-representation/</url>
      <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>研二下做的文本分析不做了，转战机器学习人脸识别（老板要求发高质量高水平的文章），没接触过这个领域，不知道自己可以做到什么程度，这次有靠谱学长指导总是很欣慰的（比起之前小老师出去创业只能自己瞎鼓捣好太多了）。</p>
<p><strong><code>Day 2017/10/18：</code></strong> 学长推荐入门阅读 <a href="http://ieeexplore.ieee.org/abstract/document/4483511/" target="_blank" rel="external">Robust Face Recognition via Sparse Representation</a></p>
<p>说实话自己英文阅读水平很一般，而且线性代数学的那些知识基本都还给老师了，这篇论文看的着实心累。再加上自己很反感写论文，看的进度很慢，基本看几个词就走神的那种。在此特别特别特别感谢<a href="https://github.com/liuguochao" target="_blank" rel="external">@超哥</a>的耐心讲解。</p>
<a id="more"></a>
<p>学长说不用非得看明白推导，但是需要了解算法的过程。而且看论文要养成习惯，把比较好的英文词语、短语、比较学术的词都整理记录下来方便以后用，这个很重要。</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>我们想要描述向量 $\vec x = (x_1, x_2)$ 的长度，那么用什么来度量？</p>
<p>$$<br>模 \Leftrightarrow 范数 \Leftrightarrow 长度<br>$$</p>
<ol>
<li><p><strong>$\ell^2$ 范数</strong>就是我们通常意义上的模，即欧氏距离：$||\vec x||_2 = \sqrt{\sum_{i=1}^Nx_i^2} = x_1^2 + x_2^2$ 。二维空间 $\ell^2$ 范数对应的曲线是圆，在三维空间 $\ell^2$ 范数就是球体。</p>
</li>
<li><p><strong>$\ell^1$ 范数</strong>即：$||\vec x||_1 = \sum_{i=1}^N|x_i|$ 即向量元素绝对值之和。</p>
</li>
<li><p><strong>$\ell^0$ 范数</strong>指 $\vec x$ 中非0元素的个数。</p>
</li>
</ol>
<p>范数对应的曲线如图:</p>
<p><img src="/2017/10/30/sparse-representation/norm.png" alt="norm"></p>
<h2 id="论文思想"><a href="#论文思想" class="headerlink" title="论文思想"></a>论文思想</h2><p>给定 $k$ 类样本集，每一类是同一个人的多张图片，将每张图片（是一个像素为 $w \times h$ 的矩阵）按照列堆砌表示成 $m$ 维向量形式 $\vec v \in R^m (m=wh)$，那么给定的 $n_i$ 个第 $i$ 类的训练样本可以表示为矩阵 $ A_i = [\vec v_{i,1}, \vec v_{i,2}, \dots, \vec v_{i,n_i}] \in R^{m \times n_i} $ 。<br>整个训练集可以表示为：</p>
<p>$$<br>A = [A_1, A_2, \dots, A_k] = [\vec v_{1,1}, \vec v_{1,2}, \dots, \vec v_{k,n_k}]. \tag{1}<br>$$</p>
<p>给定测试样本图像 $\vec y \in R^m$，假设是属于第 $i$ 类的，那么可以根据第 $i$ 类样本线性表示如下：</p>
<p>$$<br>\vec y = \alpha_{i,1} \vec v_{i,1} + \alpha_{i,2} \vec v_{i,2} + \cdots + \alpha_{i,n_i} \vec v_{i,n_i}, \tag{2}<br>$$</p>
<p>$$<br>\vec y = ( \vec v_{i,1}, \vec v_{i,2}, \cdots, \vec v_{i,n_i}) (\alpha_{i,1}, \alpha_{i,2}, \cdots, \alpha_{i,n_i})^T \tag{3}<br>$$</p>
<p>那么 $\vec y$ 的线性表示可以写为：</p>
<p>$$<br>\vec y = A\vec x_0 \in R^m. \tag{4}<br>$$</p>
<p>其中 $\vec x_0 = [0, \cdots, 0, \alpha_{i,1}, \alpha_{i,2}, 0, \cdots, 0]^T \in R^n$。</p>
<p>我们希望能够求解线性方程组 $\vec y = A \vec x$，其中未知数有n个，方程个数有m个。对于 $m &lt; n$ 的情况，方程组是超定的$overdetermied$，存在这样的 $\vec x_0$ 是唯一解。对于人脸识别，给定的样本集很大，所以是 $m &lt; n$ 的情况，这时方程组是欠定的$underdetermined$，解不唯一。一般解决这种问题是通过添加约束，取 $\ell^2$ 范数最小值：</p>
<p>$$<br>\begin{equation}<br>\begin{split}<br>\ell^2 &amp;\quad\quad \hat{\vec x^  2} = arg min ||\vec x||_2 \newline<br>\ s.t. &amp;\quad\quad  A\vec x = \vec y<br>\end{split}<br>\end{equation} \tag {5}<br>$$</p>
<p>$\ell^2$ 求解得到的 $\hat{\vec x_2}$ 是密集解，即有大量非0值。我们希望得到的解是稀疏的，也就是与第 $i$ 类有关的系数都为非0，无关系数都为0。最优的方式是求解 $\ell^0$ 范数，然而这个求解问题是NP-Hard：</p>
<p>$$<br>\begin{equation}<br>\begin{split}<br>\ell^0 &amp;\quad \hat{\vec x^ 0} = arg min ||\vec x||_0 \newline<br>s.t. &amp;\quad  A\vec x = \vec y<br>\end{split}<br>\end{equation} \tag {6}<br>$$</p>
<p>$\ell^0$ 范数很难优化求解， $\ell^1$ 范数是  $\ell^0$ 范数的最优凸近似，而且更容易优化求解，所以该篇文章通过求解 $\ell^1$最小值问题来做稀疏表示。</p>
<p>$$<br>\begin{equation}<br>\begin{split}<br>\ell^1 &amp;\quad \hat{\vec x^ 1} = arg min ||\vec x||_1 \newline<br>s.t. &amp;\quad  A\vec x = \vec y<br>\end{split}<br>\end{equation} \tag {7}<br>$$</p>
<h3 id="几何解释"><a href="#几何解释" class="headerlink" title="几何解释"></a>几何解释</h3><p>为什么 $\ell^1$ 范数比 $\ell^2$ 范数更容易得到稀疏解？</p>
<p><img src="/2017/10/30/sparse-representation/sparse-solution.png" alt="sparse solution"></p>
<p>如图 $\ell^2$ 范数曲线在 $scale$ 过程中总会 $touch$ 到直线，得到的相切的点更大概率不在坐标轴上，也就是不稀疏。而 $\ell^1$ 范数曲线与直线相切的点更容易落在坐标轴上，这样的解是稀疏解，那么得到稠密解只有两种情况就是直线的斜率为 $1$ 和 $-1$ 的是时候，所以 $\ell^1$ 求得稀疏解的概率更大。</p>
<p>线性变换包括平移、旋转和缩放。$\vec y = A \vec x$ 求解方程中矩阵A作用域向量 $\vec x$ 相当于对向量进行线性变换，也就是将 $n$ 维的 $\vec x$ 映射到了 $m$ 维空间中。</p>
<p>定义单位 $\ell^1-ball \quad P_1$，在进行线性映射后 $\vec y = A \vec x$ 的求解问题落在了多面体 $P = A(P_1)$上。</p>
<h3 id="噪音处理"><a href="#噪音处理" class="headerlink" title="噪音处理"></a>噪音处理</h3><p>$\vec y = A \vec x_0$ 是最精确理想的情况，实际上一定会存在噪音 $\vec y = A \vec x_0 + \vec z$，假设我们允许的误差范围是 $||\vec z||_2 &lt; \varepsilon$ ，那么求解问题变为：</p>
<p>$$<br>\begin{equation}<br>\begin{split}<br>\ell_s^1 &amp;\quad \hat{\vec x^ 1} = arg min ||\vec x||_1 \newline<br>s.t. &amp;\quad  ||A \vec x - \vec y||_2 \le \varepsilon<br>\end{split}<br>\end{equation} \tag {8}<br>$$</p>
<h3 id="Algorithm-1"><a href="#Algorithm-1" class="headerlink" title="Algorithm 1"></a>Algorithm 1</h3><ol>
<li><p>输入 $k$ 类训练样本 $A = [A_1, A_2, \dots, A_k] \in R^{m \times n}$，一个测试样本 $\vec y \in R^m$.</p>
</li>
<li><p>将A进行归一化。$\frac{\vec x}{||\vec x||_1} \to ||\frac{\vec x}{||\vec x||_1}||_1 = ||\frac{\vec x}{|x_1| + |x_2|}|| = \frac{||x_1|| + ||x_2||}{||x_1|| + ||x_2||} = 1$</p>
</li>
<li><p>求解 $\ell^1$最小化问题：<br>$$<br>\begin{equation}<br>\begin{split}<br>\ell^1 &amp;\quad \hat{\vec x^ 1} = arg min ||\vec x||_1 \newline<br>s.t. &amp;\quad  A\vec x = \vec y<br>\end{split}<br>\end{equation} \tag{7}<br>$$</p>
</li>
<li><p>计算残差：<br>$$<br>\begin{equation}<br>\begin{split}<br>\hat{\vec y} &amp; = A {\hat{\vec x^ 1}} \newline<br>r_i(\vec y) &amp; = ||\vec y - A \hat{\vec y}||_2<br>\end{split}<br>\end{equation} \tag{9}<br>$$<br>​</p>
</li>
<li>残差取最小得到 $\vec y$ 属于哪一类，$identity(\vec y)  = arg min_i r_i(\vec y) $.</li>
</ol>
<h3 id="论文还讨论了两个问题"><a href="#论文还讨论了两个问题" class="headerlink" title="论文还讨论了两个问题"></a>论文还讨论了两个问题</h3><h4 id="Feature-Extraction"><a href="#Feature-Extraction" class="headerlink" title="Feature Extraction"></a>Feature Extraction</h4><p>特征提取对于人脸识别的稀疏表示可以起到降低数据维度、减少计算开销的作用。比如图像分辨率为 $640 \times 480$ ，维数m在 $10^5$ 量级，这样采用上述 $Algorithm 1$ 过程计算会很慢很慢。所以将图像空间映射到特征空间 $R \in R^{d \times m}$ 其中 $d \ll m$ ：</p>
<p>$$<br>\tilde{y} \doteq R \vec y = RA \vec x_0 \in R^d \tag{10}<br>$$</p>
<p>求解问题变为：</p>
<p>$$<br>\begin{equation}<br>\begin{split}<br>\ell_r^1 &amp;\quad \hat{\vec x^ 1} = arg min ||\vec x||_1 \newline<br>s.t. &amp;\quad  ||RA\vec x - \vec y||_2 \leq \varepsilon<br>\end{split}<br>\end{equation} \tag {11}<br>$$</p>
<p>当特征维数 $d$ 满足 $d \geq 2tlog(n/d)$ 时，$Algorithm 1$ 能够快速迭代收敛，特征的选取不再是决定性的，即使是随机的映射或者降采样也可以表现的很好。</p>
<h4 id="Robustness-to-Occlusion-or-Corruption"><a href="#Robustness-to-Occlusion-or-Corruption" class="headerlink" title="Robustness to Occlusion or Corruption"></a>Robustness to Occlusion or Corruption</h4><p>实际情形中会有被遮挡或者质量不好的测试样本 $\vec y$ ，需要将线性模型改写为：</p>
<p>$$<br>\vec y = \vec y_0 + \vec e_0 = A \vec x_0 + \vec e_0 = [A, I][\vec x_0, \vec e_0]^T = B \vec w_0 \tag{12}<br>$$</p>
<p>其中 $\vec e_0 \in R^m$ 是非零错误向量，求解问题变为：</p>
<p>$$<br>\begin{equation}<br>\begin{split}<br>\ell_e^1 &amp;\quad \hat{\vec w^ 1} = arg min ||\vec w||_1 \newline<br>s.t. &amp;\quad  B \vec w = \vec y<br>\end{split}<br>\end{equation} \tag {13}<br>$$</p>
<p>算法过程和 $Algorithm 1$ 一致。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>为了能在hexo里正确显示latex语法，试了各种markdown renderer for hexo，总是个别语法有问题，鼓捣了老半天。。。必须贴一下<a href="http://blog.csdn.net/emptyset110/article/details/50123231" target="_blank" rel="external">这篇博文</a>，至少是好使了，我勒个去。。。</p>
<p>其实看的稀里糊涂，真的是只知道了大概的算法过程，不过也算是有点收获。接下来开始学习线性降维PCA，加油啦~(≧▽≦)/~</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://asciimath.org/" target="_blank" rel="external">MathJax</a></p>
<p><a href="http://www.mohu.org/info/symbols/symbols.htm" target="_blank" rel="external">LaTeX数学符号表示</a></p>
<p><a href="http://blog.csdn.net/zouxy09/article/details/24971995" target="_blank" rel="external">机器学习中的范数规则化之（一）L0、L1与L2范数</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MD5]]></title>
      <url>http://kad0108.github.io/2017/10/17/md5/</url>
      <content type="html"><![CDATA[<p><strong>MD5(Message Digest Algorithm 5)</strong>是一种信息摘要算法，它可以从任意长度的明文字符串生成128位的哈希值，是不可逆的。</p>
<h2 id="MD5算法原理："><a href="#MD5算法原理：" class="headerlink" title="MD5算法原理："></a>MD5算法原理：</h2><h3 id="处理原文"><a href="#处理原文" class="headerlink" title="处理原文"></a>处理原文</h3><p>计算原文长度(bit)对512取余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448。填充的方法是第一位填1，其余位填0。填充后，信息长度为512*N+448(N为每512位为一组的组数)。用剩余位置(512-448=64位)记录原文的真正长度，将长度的二进制值补在最后。信息长度变为512(N+1)。</p>
<h3 id="设置初始值"><a href="#设置初始值" class="headerlink" title="设置初始值"></a>设置初始值</h3><p>MD5的哈希结果长度为128位，按每32位一组分成4组，这4组结果是由4个初始值A、B、C、D经过不断演变得到。MD5的官方实现中这4个32位的整数参数称为链接变量，设置如下：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A=0x67452301</div><div class="line">B=0xefcdab89</div><div class="line">C=0x98badcfe</div><div class="line">D=0x10325476</div></pre></td></tr></table></figure>
<p>按小端规则，数据在内存中的排列就是：<code>01 23 45 67 89 ab cd ... 32 10</code>。</p>
<h3 id="循环加工"><a href="#循环加工" class="headerlink" title="循环加工"></a>循环加工</h3><ol>
<li><p>循环的次数是分组的个数(N+1)</p>
</li>
<li><p>官方MD5所用到的函数有四种非线性函数：每次循环有四轮运算，每轮16次，F、G、H、I交替使用。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">F(X, Y, Z) =(X&amp;Y) | ((~X) &amp; Z)</div><div class="line">G(X, Y, Z) =(X&amp;Z) | (Y &amp; (~Z))</div><div class="line">H(X, Y, Z) =X^Y^Z</div><div class="line">I(X, Y, Z)=Y^(X|(~Z))</div></pre></td></tr></table></figure>
</li>
<li><p>四种操作：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FF(a, b, c, d, M[j], s, Ki)表示 a = b + ((a + F(b, c, d) + Mj + Ki) &lt;&lt;&lt; s)</div><div class="line">GG(a, b, c, d, M[j], s, Ki)表示 a = b + ((a + G(b, c, d) + Mj + Ki) &lt;&lt;&lt; s)</div><div class="line">HH(a, b, c, d, M[j], s, Ki)表示 a = b + ((a + H(b, c, d) + Mj + Ki) &lt;&lt;&lt; s)</div><div class="line">II(a, b, c, d, M[j], s, Ki)表示 a = b + ((a + I(b, c, d) + Mj + Ki) &lt;&lt;&lt; s)</div></pre></td></tr></table></figure>
</li>
<li><p>Mi是第一步处理后的原文，原文长度是512的整数倍，把每512位再分成16等分，命名为M0~M15，每轮运算中交替用到M0~M15。</p>
</li>
<li><p>Ki是常量，每次运算都不相同。</p>
</li>
<li><p>左移S位，S也是常量，每次运算都不相同。</p>
</li>
<li><p>每次循环后将ABCD分别加上abcd，然后进入下一循环。</p>
</li>
</ol>
<h3 id="拼接结果"><a href="#拼接结果" class="headerlink" title="拼接结果"></a>拼接结果</h3><p>把循环加工最终产生的ABCD四个值拼接在一起转换成字符串即可。</p>
<h2 id="JS实现MD5算法"><a href="#JS实现MD5算法" class="headerlink" title="JS实现MD5算法"></a>JS实现MD5算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *</div><div class="line"> * MD5 (Message-Digest Algorithm)</div><div class="line"> *</div><div class="line"> **/</div><div class="line">var MD5 = function(string) &#123;</div><div class="line">	function RotateLeft(lValue, iShiftBits) &#123;</div><div class="line">		return (lValue &lt;&lt; iShiftBits) | (lValue &gt;&gt;&gt; (32 - iShiftBits));</div><div class="line">	&#125;</div><div class="line">	function AddUnsigned(lX, lY) &#123;</div><div class="line">		var lX4, lY4, lX8, lY8, lResult;</div><div class="line">		lX8 = (lX &amp; 0x80000000);</div><div class="line">		lY8 = (lY &amp; 0x80000000);</div><div class="line">		lX4 = (lX &amp; 0x40000000);</div><div class="line">		lY4 = (lY &amp; 0x40000000);</div><div class="line">		lResult = (lX &amp; 0x3FFFFFFF) + (lY &amp; 0x3FFFFFFF);</div><div class="line">		if (lX4 &amp; lY4) &#123;</div><div class="line">			return (lResult ^ 0x80000000 ^ lX8 ^ lY8);</div><div class="line">		&#125;</div><div class="line">		if (lX4 | lY4) &#123;</div><div class="line">			if (lResult &amp; 0x40000000) &#123;</div><div class="line">				return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);</div><div class="line">			&#125; else &#123;</div><div class="line">				return (lResult ^ 0x40000000 ^ lX8 ^ lY8);</div><div class="line">			&#125;</div><div class="line">		&#125; else &#123;</div><div class="line">			return (lResult ^ lX8 ^ lY8);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	function F(x, y, z) &#123;</div><div class="line">		return (x &amp; y) | ((~x) &amp; z);</div><div class="line">	&#125;</div><div class="line">	function G(x, y, z) &#123;</div><div class="line">		return (x &amp; z) | (y &amp; (~z));</div><div class="line">	&#125;</div><div class="line">	function H(x, y, z) &#123;</div><div class="line">		return (x ^ y ^ z);</div><div class="line">	&#125;</div><div class="line">	function I(x, y, z) &#123;</div><div class="line">		return (y ^ (x | (~z)));</div><div class="line">	&#125;</div><div class="line">	function FF(a, b, c, d, x, s, ac) &#123;</div><div class="line">		a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));</div><div class="line">		return AddUnsigned(RotateLeft(a, s), b);</div><div class="line">	&#125;;</div><div class="line">	function GG(a, b, c, d, x, s, ac) &#123;</div><div class="line">		a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));</div><div class="line">		return AddUnsigned(RotateLeft(a, s), b);</div><div class="line">	&#125;;</div><div class="line">	function HH(a, b, c, d, x, s, ac) &#123;</div><div class="line">		a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));</div><div class="line">		return AddUnsigned(RotateLeft(a, s), b);</div><div class="line">	&#125;;</div><div class="line">	function II(a, b, c, d, x, s, ac) &#123;</div><div class="line">		a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));</div><div class="line">		return AddUnsigned(RotateLeft(a, s), b);</div><div class="line">	&#125;;</div><div class="line">	function ConvertToWordArray(string) &#123;</div><div class="line">		var lWordCount;</div><div class="line">		var lMessageLength = string.length;</div><div class="line">		var lNumberOfWords_temp1 = lMessageLength + 8;</div><div class="line">		var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;</div><div class="line">		var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;</div><div class="line">		var lWordArray = Array(lNumberOfWords - 1);</div><div class="line">		var lBytePosition = 0;</div><div class="line">		var lByteCount = 0;</div><div class="line">		while (lByteCount &lt; lMessageLength) &#123;</div><div class="line">			lWordCount = (lByteCount - (lByteCount % 4)) / 4;</div><div class="line">			lBytePosition = (lByteCount % 4) * 8;</div><div class="line">			lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) &lt;&lt; lBytePosition));</div><div class="line">			lByteCount++;</div><div class="line">		&#125;</div><div class="line">		lWordCount = (lByteCount - (lByteCount % 4)) / 4;</div><div class="line">		lBytePosition = (lByteCount % 4) * 8;</div><div class="line">		lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 &lt;&lt; lBytePosition);</div><div class="line">		lWordArray[lNumberOfWords - 2] = lMessageLength &lt;&lt; 3;</div><div class="line">		lWordArray[lNumberOfWords - 1] = lMessageLength &gt;&gt;&gt; 29;</div><div class="line">		return lWordArray;</div><div class="line">	&#125;;</div><div class="line">	function WordToHex(lValue) &#123;</div><div class="line">		var WordToHexValue = &quot;&quot;,</div><div class="line">			WordToHexValue_temp = &quot;&quot;,</div><div class="line">			lByte, lCount;</div><div class="line">		for (lCount = 0; lCount &lt;= 3; lCount++) &#123;</div><div class="line">			lByte = (lValue &gt;&gt;&gt; (lCount * 8)) &amp; 255;</div><div class="line">			WordToHexValue_temp = &quot;0&quot; + lByte.toString(16);</div><div class="line">			WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);</div><div class="line">		&#125;</div><div class="line">		console.log(lValue, WordToHexValue);</div><div class="line">		return WordToHexValue;</div><div class="line">	&#125;;</div><div class="line">	function Utf8Encode(string) &#123;</div><div class="line">		string = string.replace(/\r\n/g, &quot;\n&quot;);</div><div class="line">		var utftext = &quot;&quot;;</div><div class="line">		for (var n = 0; n &lt; string.length; n++) &#123;</div><div class="line">			var c = string.charCodeAt(n);</div><div class="line">			if (c &lt; 128) &#123;</div><div class="line">				utftext += String.fromCharCode(c);</div><div class="line">			&#125; else if ((c &gt; 127) &amp;&amp; (c &lt; 2048)) &#123;</div><div class="line">				utftext += String.fromCharCode((c &gt;&gt; 6) | 192);</div><div class="line">				utftext += String.fromCharCode((c &amp; 63) | 128);</div><div class="line">			&#125; else &#123;</div><div class="line">				utftext += String.fromCharCode((c &gt;&gt; 12) | 224);</div><div class="line">				utftext += String.fromCharCode(((c &gt;&gt; 6) &amp; 63) | 128);</div><div class="line">				utftext += String.fromCharCode((c &amp; 63) | 128);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return utftext;</div><div class="line">	&#125;;</div><div class="line">	var x = Array();</div><div class="line">	var k, AA, BB, CC, DD, a, b, c, d;</div><div class="line">	var S11 = 7,</div><div class="line">		S12 = 12,</div><div class="line">		S13 = 17,</div><div class="line">		S14 = 22;</div><div class="line">	var S21 = 5,</div><div class="line">		S22 = 9,</div><div class="line">		S23 = 14,</div><div class="line">		S24 = 20;</div><div class="line">	var S31 = 4,</div><div class="line">		S32 = 11,</div><div class="line">		S33 = 16,</div><div class="line">		S34 = 23;</div><div class="line">	var S41 = 6,</div><div class="line">		S42 = 10,</div><div class="line">		S43 = 15,</div><div class="line">		S44 = 21;</div><div class="line">	string = Utf8Encode(string);</div><div class="line">	x = ConvertToWordArray(string);</div><div class="line">	a = 0x67452301;</div><div class="line">	b = 0xEFCDAB89;</div><div class="line">	c = 0x98BADCFE;</div><div class="line">	d = 0x10325476;</div><div class="line">	for (k = 0; k &lt; x.length; k += 16) &#123;</div><div class="line">		AA = a;</div><div class="line">		BB = b;</div><div class="line">		CC = c;</div><div class="line">		DD = d;</div><div class="line">		a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);</div><div class="line">		d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);</div><div class="line">		c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB);</div><div class="line">		b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);</div><div class="line">		a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);</div><div class="line">		d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);</div><div class="line">		c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613);</div><div class="line">		b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);</div><div class="line">		a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8);</div><div class="line">		d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);</div><div class="line">		c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);</div><div class="line">		b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);</div><div class="line">		a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122);</div><div class="line">		d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193);</div><div class="line">		c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E);</div><div class="line">		b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);</div><div class="line">		a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);</div><div class="line">		d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340);</div><div class="line">		c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);</div><div class="line">		b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);</div><div class="line">		a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);</div><div class="line">		d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);</div><div class="line">		c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);</div><div class="line">		b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);</div><div class="line">		a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);</div><div class="line">		d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);</div><div class="line">		c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);</div><div class="line">		b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);</div><div class="line">		a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);</div><div class="line">		d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);</div><div class="line">		c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);</div><div class="line">		b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);</div><div class="line">		a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);</div><div class="line">		d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681);</div><div class="line">		c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);</div><div class="line">		b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);</div><div class="line">		a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);</div><div class="line">		d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);</div><div class="line">		c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);</div><div class="line">		b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);</div><div class="line">		a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);</div><div class="line">		d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);</div><div class="line">		c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);</div><div class="line">		b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05);</div><div class="line">		a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);</div><div class="line">		d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);</div><div class="line">		c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);</div><div class="line">		b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);</div><div class="line">		a = II(a, b, c, d, x[k + 0], S41, 0xF4292244);</div><div class="line">		d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97);</div><div class="line">		c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);</div><div class="line">		b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);</div><div class="line">		a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3);</div><div class="line">		d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);</div><div class="line">		c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);</div><div class="line">		b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);</div><div class="line">		a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);</div><div class="line">		d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);</div><div class="line">		c = II(c, d, a, b, x[k + 6], S43, 0xA3014314);</div><div class="line">		b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);</div><div class="line">		a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82);</div><div class="line">		d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);</div><div class="line">		c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);</div><div class="line">		b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);</div><div class="line">		a = AddUnsigned(a, AA);</div><div class="line">		b = AddUnsigned(b, BB);</div><div class="line">		c = AddUnsigned(c, CC);</div><div class="line">		d = AddUnsigned(d, DD);</div><div class="line">	&#125;</div><div class="line">	var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d);</div><div class="line">	return temp.toLowerCase();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="MD5应用"><a href="#MD5应用" class="headerlink" title="MD5应用"></a>MD5应用</h2><h3 id="一致性验证"><a href="#一致性验证" class="headerlink" title="一致性验证"></a>一致性验证</h3><p>MD5的典型应用是对一段文本信息产生信息摘要，以防止被篡改。常常在某些软件下载站点的某软件信息中看到其MD5值，它的作用就在于我们可以在下载该软件后，对下载回来的文件用专门的软件（如Windows MD5 Check等）做一次MD5校验，以确保我们获得的文件与该站点提供的文件为同一文件。</p>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>如果有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。</p>
<h3 id="安全访问认证"><a href="#安全访问认证" class="headerlink" title="安全访问认证"></a>安全访问认证</h3><p>在Unix系统中用户的密码是以MD5（或其它类似的算法）经Hash运算后存储在文件系统中。当用户登录的时候，系统把用户输入的密码进行MD5 Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。</p>
<h2 id="MD5破解"><a href="#MD5破解" class="headerlink" title="MD5破解"></a>MD5破解</h2><p>所谓的破解并非把摘要还原成原文，对MD5的破解实际上都属于碰撞。比如原文A通过MD5可以生成摘要M，我们并不需要把M还原成A，只需要找到原文B，生成同样的摘要M即可。</p>
<p>设MD5的哈希函数是H(x)，那么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">H(A)= M</div><div class="line">H(B)=M</div></pre></td></tr></table></figure></p>
<p>任意B即为破解结果。</p>
<p><strong>MD5碰撞的方法有很多，主要包括暴力枚举法、字典法、彩虹表法等等。</strong></p>
<p>暴力枚举就是枚举出所有原文并计算哈希值，对比与给定的信息摘要是否一致。时间复杂度太高。</p>
<p>字典法就是存储尽可能多的原文和对应的哈希值，这样可以快速找到碰撞结果，但是需要巨大的空间存储。</p>
<h3 id="彩虹表"><a href="#彩虹表" class="headerlink" title="彩虹表"></a>彩虹表</h3><p>两个基本函数：</p>
<ul>
<li>H(X)：生成信息摘要的哈希函数，比如MD5</li>
<li>R(X)：从信息摘要转换成另一个字符串的衰减函数(Reduce)。其中R(X)的定义域是H(X)的值域，R(X)的值域是H(X)的定义域。注意R(X)并非H(X)的反函数。</li>
</ul>
<p>通过交替运算H和R若干次，可以形成一个原文和哈希值的链条。假设原文为<code>aaaaaa</code>，哈希值长度32bit，那么哈希链表如下：</p>
<p><img src="/2017/10/17/md5/h&amp;r.png" alt="h &amp; r"></p>
<p>假设H(X)和R(X)的交替重复K次，链条长度为2K+1，我们只需把链表的首部和尾部存入哈希表中。</p>
<p>演示一次破解过程：</p>
<blockquote>
<p>给定信息摘要：<code>920ECF10</code>，进行R(X)运算得到<code>kiebgt</code>，查询哈希表可以找到末端<code>kiebgt</code>对应的首端是<code>aaaaaa</code>，因此摘要<code>920ECF10</code>的原文“极有可能”在<code>aaaaaa</code>到<code>kiebgt</code>的这个链条当中。</p>
</blockquote>
<p>接下来从<code>aaaaaa</code>开始，重新交替运算R(X)与H(X)，看一看摘要值920ECF10是否是其中一次H(X)的结果。从链条看来，答案是肯定的，因此<code>920ECF10</code>的原文就是<code>920ECF10</code>的前置节点<code>sgfnyd</code>。</p>
<p>需要补充的是，如果给定的摘要值经过一次R(X)运算，结果在哈希表中找不到，可以继续交替H(X) R(X)直到第K次为止。如果重复了K次之后，仍然没有再末节点中找到对应的值，则可以断定所需明文不在集合中。再计算无意义。</p>
<p>哈希链表代表了一组映射关系，其中每组包含K对映射，但只需要存储链条首位两个字符串。假设K=10，那么存储空间只有上述字典的十分之一，代价则是破解一个摘要的运算次数提高了十倍。</p>
<p>但是哈希链条存在一个致命的缺陷：R(X)函数的可靠性，虽然尽量吧R(X)设计成结果均匀分布的函数，但是再完美的函数也难免有碰撞的情况，比如如下情况：</p>
<blockquote>
<p>给定信息摘要：<code>FB107E70</code>，经过多次R(X)，H(X)运算，得到结果<code>kiebgt</code>，通过哈希表查找末端<code>kiebgt</code>，可以找出首端<code>aaaaaa</code>。</p>
</blockquote>
<p>但是，<code>FB107E70</code>并不在<code>aaaaaa</code>到<code>kiebgt</code>的哈希链条当中，这就是R(X)的碰撞造成的。</p>
<p>这个问题看似没什么影响，既然找不到就重新生成一组首尾映射即可。但是想象一下，当K值较大的时候，哈希链很长，一旦两条不同的哈希链在某个节点出现碰撞，后面所有的明文和哈希值全都变成了一毛一样的值。</p>
<p>这样造成的后果就是冗余存储。原本两条哈希链可以存储2K个映射，由于重复，真正存储的映射数量不足2K。</p>
<p>由此彩虹表诞生，彩虹表对哈希链进行了改进，把原先R(X)函数改进成了R1(X)到R(X)一共k个衰减函数。这样一来虽然也可能发生碰撞，但是碰撞只会发生在同一级运算，如R1和R1碰撞，R3和R3碰撞，大大减小了存储重复的几率。</p>
<p><img src="/2017/10/17/md5/rainbow.png" alt="rainbow"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://en.wikipedia.org/wiki/MD5" target="_blank" rel="external">MD5 Wiki</a></p>
<p><a href="https://mp.weixin.qq.com/s/k-ToL356asWtS_PN30Z17w" target="_blank" rel="external">MD5算法——梦见微信公众号</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_6fe0eb1901014cpl.html" target="_blank" rel="external">MD5算法步骤详解</a></p>
<p><a href="https://www.zhihu.com/question/38369521" target="_blank" rel="external">如何给自己各种帐号编一个安全又不会忘记的密码？</a></p>
<p><a href="https://www.zhihu.com/question/19790488" target="_blank" rel="external">彩虹表</a></p>
<p><a href="http://blog.csdn.net/github_35681219/article/details/52743048" target="_blank" rel="external">计算机的大小端规则</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[服务器推送信息]]></title>
      <url>http://kad0108.github.io/2017/08/29/server-sent/</url>
      <content type="html"><![CDATA[<p>本文总结了服务器将信息主动推送到客户端的几种实现方式：</p>
<ol>
<li>Ajax polling</li>
<li>Long polling</li>
<li>HTTP Stream</li>
<li>WebSockets</li>
<li>Server-Sent Events</li>
</ol>
<p>Ajax是一种从页面向服务器请求数据的技术，Comet是一种服务器向页面推送数据的技术。</p>
<p>有两种方式实现Comet：长轮询和流。</p>
<a id="more"></a>
<h2 id="Polling"><a href="#Polling" class="headerlink" title="Polling"></a>Polling</h2><p><strong>短轮询</strong>是浏览器定时向服务器发送请求，看有没有更新的数据。下图是短轮询的时间线。</p>
<p>⚠️注意：短轮询并不是一直发送请求，而是应该在服务器响应后再发送请求，只不过服务器响应返回的不一定是更新的数据。</p>
<p><img src="/2017/08/29/server-sent/ajax polling.png" alt="ajax polling"></p>
<p><strong>长轮询</strong>是页面发起一个到服务器的请求，然后服务器一致保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这个过程在页面打开期间一直持续不断。下图是长轮询的时间线。</p>
<p><img src="/2017/08/29/server-sent/long polling.png" alt="long polling"></p>
<p>无论是短轮询还是长轮询，浏览器都要在接收数据之前，先发起对服务器的连接，两者最大的区别在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询是等待发送响应。轮询的优势是所有浏览器都支持，因为使用XHR对象和setTimeout就能实现的。</p>
<h2 id="HTTP-Stream"><a href="#HTTP-Stream" class="headerlink" title="HTTP Stream"></a>HTTP Stream</h2><p>第二种Comet实现是<strong>HTTP流</strong>。流不同于上述两种轮询，因为它在页面的整个生命周期内只使用一个HTTP连接。浏览器向服务器发送一个请求，服务器保持连接打开，然后周期性地向浏览器发送数据。</p>
<p>所有服务器端语言支持打印到输出缓存然后刷新（将输出缓存中的内容一次性全部发送到客户端）的功能。而这正是实现HTTP流的关键所在。</p>
<p>通过侦听readystatechange事件及检测readyState的值是否为3，就可以利用XHR对象实现HTTP流。在上述这些浏览器中，随着不断从服务器接收数据，readyState的值会周期性变为3，此时responseText属性中酒会保存接收到的所有数据。就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。使用XHR对象实现HTTP流的典型代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function createStreamingClient(url, progress, finished)&#123;</div><div class="line">	var xhr = new XMLHttpRequest(),</div><div class="line">		received = 0;</div><div class="line">	xhr.open(&quot;get&quot;, url, true);</div><div class="line">	xhr.onreadystatechange = function()&#123;</div><div class="line">		var result;</div><div class="line">		if(xhr.readyState == 3)&#123;</div><div class="line">			// 只取得最新数据并调整计数器</div><div class="line">			result = xhr.responseText.substring(received);</div><div class="line">			reveiced += result.length;</div><div class="line">			// 调用progress回调函数</div><div class="line">			progress(result);</div><div class="line">		&#125;else if(xhr.readyState == 4)&#123;</div><div class="line">			finished(xhr.responseText);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	xhr.send(null);</div><div class="line">	return xhr;</div><div class="line">&#125;</div><div class="line">var client = createStreamingClient(&quot;streaming.php&quot;, function(data)&#123;</div><div class="line">	alert(&quot;Recevied: &quot; + data);</div><div class="line">&#125;, function(data)&#123;</div><div class="line">	alert(&quot;Done!&quot;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这个createStreamingClient函数接收三个参数：要连接的url，在连接到数据时调用的函数以及关闭连接时调用的函数。有时候，当连接关闭时，很可能还需要重新建立，所以关注连接什么时候关闭还是有必要的。</p>
<p>只要readystatechange事件发生，而且readyState值为3，就对responseText进行分割以取得最新数据。这里的received变量用于记录已经处理了多少个字符，每次readyState值为3时都递增。然后通过progress回调函数来处理传入的新数据。当readyState值为4时，则执行finished回调函数，传入响应返回的全部内容。</p>
<p>这个例子比较简单，在大多数浏览器中正常运行（IE除外），但管理Comet的连接是很容易出错的，需要时间不断改进才能达到完美。</p>
<h2 id="Server-Sent-Events"><a href="#Server-Sent-Events" class="headerlink" title="Server-Sent Events"></a>Server-Sent Events</h2><p><strong>服务器发送事件SSE</strong>是围绕只读Comet交互推出的API或者模式。SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的MIME类型必须是<code>text/event-stream</code>，而且是浏览器中的JavaScript API能解析格式输出。SSE支持短轮询、长轮询和HTTP流，而且能在断开连接时自动确定何时重新连接。</p>
<h3 id="SSE-API"><a href="#SSE-API" class="headerlink" title="SSE API"></a>SSE API</h3><p>要预定新的事件流，首先要创建一个新的EventSource对象，并传入一个入口点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var source = new EventSource(&quot;myevents.php&quot;);</div></pre></td></tr></table></figure>
<p>注意，传入的URL必须与创建对象的页面同源（相同的URL模式，域及端口）。EventSource的实例有一个readyState的属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2表示关闭了连接。</p>
<p>另外还有三个事件：</p>
<ol>
<li>open：在建立连接时触发。</li>
<li>message：在从服务器接收到新事件时触发。</li>
<li>error：在无法建立连接时触发。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">source.onmessage = function(event)&#123;</div><div class="line">	var data = event.data;</div><div class="line">	// 处理数据</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>服务器发回的数据以字符串形式保存在<code>event.data</code>中。</p>
<p>默认情况下，EventSource对象会保持与服务器的活动连接。如果连接断开，还会重新连接，这就意味着SSE适合长轮询和HTTP流。如果想强制立即断开连接并且不再重新连接，可以调用close方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source.close();</div></pre></td></tr></table></figure>
<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>所谓的服务器事件会通过一个持久的HTTP响应发送，这个响应的MIME类型为<code>text/event-stream</code>。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀<code>data:</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">data: foo</div><div class="line">// blank line</div><div class="line">data: bar</div><div class="line">// blank line</div><div class="line">data: foo</div><div class="line">data: bar</div></pre></td></tr></table></figure>
<p>对以上响应，事件流中的第一个message事件返回的<code>event.data</code>值为foo，第二个message事件返回的是bar，第三个message事件返回的<code>event.data</code>是<code>foo\nbar</code>（注意中间的换行符）。对于多个连续的以<code>data:</code>开头的数据行，将作为多段数据解析，每个值之间以一个换行符分隔。只有在包含<code>data:</code>的数据行后面有空行时，才会触发message事件，因此在服务器上生成事件流时不能忘了多添加这一行。</p>
<p>通过<code>id:</code>前缀可以给特定的事件指定一个关联的ID，这个ID行位于<code>data:</code>行前面或后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data: foo</div><div class="line">id: 1</div></pre></td></tr></table></figure>
<p>设置了ID后，EventSource对象会跟踪上一次触发的事件，如果连接断开，会向服务器发送一个包含名为<code>Last-Event-ID</code>的特殊HTTP头部的请求，以便服务器知道下一次该触发哪个事件。在多次连接的事件流中，这种机制可以确保浏览器以正确的顺序收到连接的数据段。</p>
<h2 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h2><p><a href="http://kadong.space/2017/02/15/websocket/" target="_blank" rel="external">WebSockets总结详见这篇博文</a></p>
<h3 id="SSE与WebSockets"><a href="#SSE与WebSockets" class="headerlink" title="SSE与WebSockets"></a>SSE与WebSockets</h3><p>面对某个具体的用例，在考虑是使用SSE还是使用WebSocket时，可以考虑如下几个因素。首先，你是否有自由度建立和维护WebSockets服务器？因为Web Socket协议不同于HTTP，所以现有服务器不能用于Web Socket通信。SSE通过常规HTTP通信，因此现有服务器可以满足需求。</p>
<p>第二个要考虑的问题是到底需不需要双向通信。如果用例只需读取服务器数据（比如比赛成绩），那么SSE比较容易实现，如果用例必须双向通信（如聊天室），那么Web Sockets显然更好。别忘了，在不能选择Web Sockets的情况下，组合XHR和SSE也是能实现双向通信的。</p>
<blockquote>
<p>以上内容基本都摘自《JS高级程序设计》一书。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS自定义事件]]></title>
      <url>http://kad0108.github.io/2017/08/28/custom-event/</url>
      <content type="html"><![CDATA[<h3 id="绑定事件几种方式："><a href="#绑定事件几种方式：" class="headerlink" title="绑定事件几种方式："></a>绑定事件几种方式：</h3><ol>
<li><p>HTML事件处理程序<code>&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;alert(&#39;clicked&#39;)&quot;/&gt;</code></p>
</li>
<li><p>DOM0级事件处理程序<code>$btn.onclick = function(){}</code></p>
</li>
<li><p>DOM2级事件处理程序<code>$btn.addEventListener(&#39;click&#39;, function(){}, false)</code></p>
</li>
</ol>
<h3 id="解除绑定："><a href="#解除绑定：" class="headerlink" title="解除绑定："></a>解除绑定：</h3><ol>
<li><p><code>$btn.onclick = null;</code></p>
</li>
<li><p><code>$btn.removeEventListener()</code>传入参数和addEventListener参数相同，也就是通过addEventListener添加的匿名函数无法移除。 </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function handler()&#123;&#125;</div><div class="line">$btn.addEventListener(&apos;click&apos;, handler, false);</div><div class="line">$btn.removeEventListener(&apos;click&apos;, handler, false);</div></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<h3 id="onclick-VS-addEventListener："><a href="#onclick-VS-addEventListener：" class="headerlink" title="onclick VS addEventListener："></a>onclick VS addEventListener：</h3><ol>
<li><p>使用addEventListener可以添加多个事件处理程序，都会触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$btn.addEventListener(&apos;click&apos;, function()&#123; console.log(1); &#125;); // 触发</div><div class="line">$btn.addEventListener(&apos;click&apos;, function()&#123; console.log(2); &#125;); // 触发</div></pre></td></tr></table></figure>
</li>
<li><p>使用onclick会有覆盖，但是onclick不会覆盖addEventListener</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$btn.onclick = function()&#123; console.log(3); &#125;; // 被覆盖</div><div class="line">$btn.onclick = function()&#123; console.log(3); &#125;; // 触发</div></pre></td></tr></table></figure>
</li>
</ol>
<p>二者回调函数中的参数都是一样的，event一样，this指向也一样。</p>
<h3 id="addEventListener小知识点"><a href="#addEventListener小知识点" class="headerlink" title="addEventListener小知识点"></a>addEventListener小知识点</h3><ol>
<li><p>addEventListener第三个参数表示事件能否在捕获或冒泡阶段执行。默认false，事件发生在冒泡阶段执行。</p>
</li>
<li><p>阻止同类型事件的触发使用<code>event.stopImmediatePropagation()</code>，这个API会阻止事件的冒泡行为以及后序的同类型事件监听函数。</p>
</li>
<li><p>blur、focus、load、unload这些事件不会冒泡。</p>
</li>
</ol>
<h3 id="addEventListener兼容性"><a href="#addEventListener兼容性" class="headerlink" title="addEventListener兼容性"></a>addEventListener兼容性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">var EventUtil = &#123;</div><div class="line">	addEvent: function(ele, eventName, listener)&#123;</div><div class="line">		if(ele.addEventListener)&#123;</div><div class="line">			ele.addEventListener(eventName, listener, false);		</div><div class="line">		&#125;else if(ele.attachEvent)&#123;</div><div class="line">			ele.attachEvent(&quot;on&quot; + eventName, listener);</div><div class="line">		&#125;else&#123;</div><div class="line">			ele[&quot;on&quot; + eventName] = listener;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	removeEvent: function(ele, eventName, listener)&#123;</div><div class="line">		if(ele.removeEventListener)&#123;</div><div class="line">			ele.removeEventListener(eventName, listener);		</div><div class="line">		&#125;else if(ele.detachEvent)&#123;</div><div class="line">			ele.detachEvent(&quot;on&quot; + eventName, listener);</div><div class="line">		&#125;else&#123;</div><div class="line">			ele[&quot;on&quot; + eventName] = null;		</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	getEvent: function(e)&#123;</div><div class="line">		var evt = e || window.event;</div><div class="line">		return evt;</div><div class="line">	&#125;,</div><div class="line">	getTarget: function(e)&#123;</div><div class="line">		var e = this.getEvent(e);</div><div class="line">		var target = e.target || e.srcElement;</div><div class="line">		return target;</div><div class="line">	&#125;,</div><div class="line">	stopPropagation: function(e)&#123;</div><div class="line">		var e = this.getEvent(e);</div><div class="line">		if(e.stopPropagation) e.stopPropagation();</div><div class="line">		else e.cancelBubble = true;		</div><div class="line">	&#125;,</div><div class="line">	preventDefault: function(e)&#123;</div><div class="line">		var e = this.getEvent(e);</div><div class="line">		if(e.preventDefault) e.preventDefault();</div><div class="line">		else e.returnValue = false;//兼容firefox</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="JS自定义事件"><a href="#JS自定义事件" class="headerlink" title="JS自定义事件"></a>JS自定义事件</h2><p>创建自定义事件可以使用API来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var eventObj = document.createEvent(&quot;MouseEvents&quot;);//创建事件对象</div><div class="line">eventObj.initEvent(&quot;click&quot;, true, false);//初始化事件信息</div><div class="line">node.dispatchEvent(eventObj);//将事件绑定到特定dom节点上</div></pre></td></tr></table></figure>
<p>监听事件，触发事件执行回调函数的行为换种思路可以这样来实现：定义一个数组，push进去事件处理函数；执行时，遍历数组中事件处理函数并执行。</p>
<p>类似于这样的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var Event = &#123;</div><div class="line">    _listeners: &#123;&#125;,</div><div class="line">    addEvent: function(type, fn) &#123;</div><div class="line">    	// 添加    </div><div class="line">    &#125;,</div><div class="line">    fireEvent: function(type) &#123;</div><div class="line">    	// 触发    </div><div class="line">    &#125;,</div><div class="line">    removeEvent: function(type, fn) &#123;</div><div class="line">    	// 删除</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Event.addEvent(&quot;alert&quot;, function() &#123;</div><div class="line">    alert(&quot;弹出！&quot;);</div><div class="line">&#125;);</div><div class="line">// 触发自定义alert事件</div><div class="line">Event.fireEvent(&quot;alert&quot;);</div></pre></td></tr></table></figure></p>
<h3 id="原型模式实现"><a href="#原型模式实现" class="headerlink" title="原型模式实现"></a>原型模式实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">function EventTarget()&#123;</div><div class="line">	this._listener = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">EventTarget.prototype = &#123;</div><div class="line">	constructor: this,</div><div class="line">	addEvent: function(type, fn)&#123;</div><div class="line">		if(typeof type === &quot;string&quot; &amp;&amp; typeof fn === &quot;function&quot;)&#123;</div><div class="line">			if(typeof this._listener[type] === &quot;undefined&quot;)&#123;</div><div class="line">				this._listener[type] = [];</div><div class="line">			&#125;</div><div class="line">			this._listener[type].push(fn);</div><div class="line">		&#125;</div><div class="line">		return this;</div><div class="line">	&#125;,</div><div class="line">	fireEvent: function(type)&#123;</div><div class="line">		if(type &amp;&amp; this._listener[type])&#123;</div><div class="line">			var arrayEvent = this._listener[type];</div><div class="line">			if(arrayEvent instanceof Array)&#123;</div><div class="line">				for(var i = 0; i &lt; arrayEvent.length; i++)&#123;</div><div class="line">					arrayEvent[i].call(this, &#123;type: type&#125;); // 其实这里还没太明白为什么需要传入type这个参数</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return this;</div><div class="line">	&#125;,</div><div class="line">	removeEvent: function(type, fn)&#123;</div><div class="line">		console.log(this._listener[type], fn);</div><div class="line">		var arrayEvent = this._listener[type];</div><div class="line">		if(typeof type === &quot;string&quot; &amp;&amp; arrayEvent instanceof Array)&#123;</div><div class="line">			if(typeof fn === &quot;function&quot;)&#123;</div><div class="line">				for(var i = 0; i &lt; this._listener[type].length; i++)&#123;</div><div class="line">					console.log(arrayEvent[i], fn);</div><div class="line">					if(arrayEvent[i] === fn)&#123;</div><div class="line">						this._listener[type].splice(i, 1);</div><div class="line">						break;</div><div class="line">					&#125;	</div><div class="line">				&#125;</div><div class="line">			&#125;else&#123;</div><div class="line">				delete this._listener[type];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		console.log(this._listener[type]);</div><div class="line">		return this;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要实现自定义事件功能时候，先new构造下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var myEvent = new EventTarget();</div><div class="line"></div><div class="line">var fn1, fn2;</div><div class="line">myEvent.addEvent(&apos;alert&apos;, fn1 = function()&#123;</div><div class="line">	console.log(arguments);</div><div class="line">	alert(&apos;first alert&apos;);</div><div class="line">&#125;).addEvent(&apos;alert&apos;, fn2 = function()&#123;</div><div class="line">	alert(&apos;second alert&apos;);</div><div class="line">&#125;)</div><div class="line">document.onclick = function()&#123;</div><div class="line">	myEvent.fireEvent(&apos;alert&apos;);</div><div class="line">&#125;</div><div class="line">myEvent.removeEvent(&apos;alert&apos;, fn1);</div></pre></td></tr></table></figure>
<p>上面这种设计模式叫做<strong>发布-订阅者模式</strong>。观察者对象，有一个消息容器和三个方法，分别是订阅消息、取消消息、发布消息。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events" target="_blank" rel="external">Creating and triggering events</a></p>
<p><a href="http://www.zhangxinxu.com/wordpress/2012/04/js-dom%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/" target="_blank" rel="external">漫谈js自定义事件、DOM/伪DOM自定义事件</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[You Don't Know JavaScript II —— This & Object & Prototypes]]></title>
      <url>http://kad0108.github.io/2017/08/10/you-dont-know-js-II/</url>
      <content type="html"><![CDATA[<h2 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h2><p>其实很多时候看书都有点心浮气躁，总是看一会儿就被别的事情打断了，最近很难静下心有一个完整的时间段来不思考任何烦心事好好地看书。</p>
<h1 id="第二部分-this和对象原型"><a href="#第二部分-this和对象原型" class="headerlink" title="第二部分 this和对象原型"></a>第二部分 this和对象原型</h1><h2 id="第一章-关于this"><a href="#第一章-关于this" class="headerlink" title="第一章 关于this"></a>第一章 关于this</h2><h3 id="1-1-为什么要用this"><a href="#1-1-为什么要用this" class="headerlink" title="1.1 为什么要用this"></a>1.1 为什么要用this</h3><p>如果不使用this就需要给函数体显式地传入一个上下文对象，this提供了一种更优雅的方式来隐式传递一个对象的引用，让api设计更简洁而且易于复用。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function bar(context)&#123;</div><div class="line">  return context.name.toUpperCase();</div><div class="line">&#125;</div><div class="line">bar(&#123;name: &apos;kad&apos;&#125;); // &apos;KAD&apos;</div><div class="line"></div><div class="line"></div><div class="line">VS</div><div class="line"></div><div class="line">function bar()&#123;</div><div class="line">  return this.name.toUpperCase();</div><div class="line">&#125;</div><div class="line">bar.call(&#123;name: &apos;kad&apos;&#125;); // &apos;KAD&apos;</div></pre></td></tr></table></figure>
<h3 id="1-2-误解"><a href="#1-2-误解" class="headerlink" title="1.2 误解"></a>1.2 误解</h3><h4 id="1-2-1-指向自身"><a href="#1-2-1-指向自身" class="headerlink" title="1.2.1 指向自身"></a>1.2.1 指向自身</h4><p>❌this指向函数自身。看下面例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo(num)&#123;</div><div class="line">  this.count++;</div><div class="line">&#125;</div><div class="line">foo.count = 0;</div><div class="line">for(var i = 0; i &lt; 10; i++)&#123;</div><div class="line">  if(i &gt; 5) foo(i);</div><div class="line">&#125;</div><div class="line">console.log(foo.count); // 0 ???</div></pre></td></tr></table></figure></p>
<p>很明显foo被调用了4次，但是<code>foo.count</code>的值为0，也就说明this并不指向函数自身。</p>
<p><strong>在函数内部引用自身</strong>： 具名函数在它内部可以使用函数名来引用自身，匿名函数可以使用<code>arguments.callee</code>来引用当前正在运行的函数对象。所以可以在foo函数内修改为<code>foo.count++</code>，但这样回避了this问题，完全依赖与变量foo的词法作用域。</p>
<p>实际可以强制this指向foo函数对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo(num)&#123;</div><div class="line">  this.count++;</div><div class="line">&#125;</div><div class="line">foo.count = 0;</div><div class="line">for(var i = 0; i &lt; 10; i++)&#123;</div><div class="line">  if(i &gt; 5) foo.call(foo, i); // 使用call确保this指向函数对象foo本身</div><div class="line">&#125;</div><div class="line">console.log(foo.count); //4</div></pre></td></tr></table></figure>
<h4 id="1-2-2-它的作用域"><a href="#1-2-2-它的作用域" class="headerlink" title="1.2.2 它的作用域"></a>1.2.2 它的作用域</h4><p>❌this指向函数的作用域。</p>
<p>this在任何情况下都不指向函数的词法作用域。作用域“对象”无法通过JS代码访问，它存在于JS引擎内部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  var a = 2;</div><div class="line">  this.bar();</div><div class="line">&#125;</div><div class="line">function bar()&#123;</div><div class="line">  console.log(this.a);</div><div class="line">&#125;</div><div class="line">foo(); // undefined， 如果直接console a就会报错ReferenceError，很奇怪难道this.a不是RHS查询？</div></pre></td></tr></table></figure>
<p>这段代码尝试使用this连通foo和bar的词法作用域，让bar可以访问foo作用域中的变量a，这是不可能实现的。<strong>你不能使用this来引用一个词法作用域内部的东西。</strong></p>
<h3 id="1-3-this到底是什么"><a href="#1-3-this到底是什么" class="headerlink" title="1.3 this到底是什么"></a>1.3 this到底是什么</h3><p>this是在运行时进行绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p>
<p>当一个函数被调用时，会创建一个活动记录（有时也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this就是记录的其中一个属性，会在函数执行的过程中用到。</p>
<h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p>this既不指向函数自身也不指向函数的词法作用域。</p>
<p>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p>
<h2 id="第2章-this全面解析"><a href="#第2章-this全面解析" class="headerlink" title="第2章 this全面解析"></a>第2章 this全面解析</h2><h3 id="2-1-调用位置"><a href="#2-1-调用位置" class="headerlink" title="2.1 调用位置"></a>2.1 调用位置</h3><p>分析好函数在代码中被调用的位置，this到底引用的是什么，也就是分析调用栈（为了到达当前执行位置所调用的的所有函数）。</p>
<p>查看调用栈可以使用浏览器吊事工具，设置断点或者在代码中插入一条debugger语句。运行代码时，调试器会在那个位置暂停，同时展示当前位置的函数调用列表，这就是调用栈。栈中第二个元素就是真正的调用位置。</p>
<p><img src="/2017/08/10/you-dont-know-js-II/callstack.png" alt="callstack"></p>
<h3 id="2-2-绑定规则"><a href="#2-2-绑定规则" class="headerlink" title="2.2 绑定规则"></a>2.2 绑定规则</h3><p>在函数的执行过程中调用位置决定this的绑定对象。</p>
<h4 id="2-2-1-默认绑定"><a href="#2-2-1-默认绑定" class="headerlink" title="2.2.1 默认绑定"></a>2.2.1 默认绑定</h4><p>直接使用不带任何修饰的函数引用进行调用，this的默认绑定指向全局对象window。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  console.log(this.a);</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo(); // 2</div></pre></td></tr></table></figure>
<p>foo调用时this指向的是全局对象window。严格模式下会输出undefined，全局对象无法使用默认绑定。</p>
<h4 id="2-2-2-隐式绑定"><a href="#2-2-2-隐式绑定" class="headerlink" title="2.2.2 隐式绑定"></a>2.2.2 隐式绑定</h4><p>调用位置是否有上下文对象。隐式绑定规则会把函数调用中的this绑定给这个上下文对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">function foo()&#123;</div><div class="line">	console.log(this.a);</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">  a: 2,</div><div class="line">  foo: foo</div><div class="line">&#125;;</div><div class="line">obj.foo(); // 2 -----(1)</div><div class="line">var f = obj.foo;</div><div class="line">f(); // 1 -----(2)</div></pre></td></tr></table></figure>
<p>(1)处的foo调用位置会使用obj上下文来引用函数。</p>
<p>(2)处的<code>obj.foo()</code>引用的是foo函数本身，所以此时f是不带任何修饰的函数调用，应用了默认绑定，this指向window。如果是严格模式则绑定到undefined上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  console.log(this.a);</div><div class="line">&#125;</div><div class="line">function doFoo(fn)&#123;</div><div class="line">  fn();</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">  a: 2,</div><div class="line">  foo: foo</div><div class="line">&#125;;</div><div class="line">var a = 1;</div><div class="line">dooFoo(obj.foo); // 1</div></pre></td></tr></table></figure>
<p>上面这样传入回调函数和(2)处一样，都会丢失this绑定。还有像setTimeout这样传入回调函数的丢失this绑定是很常见的。</p>
<h4 id="2-2-3-显式绑定"><a href="#2-2-3-显式绑定" class="headerlink" title="2.2.3 显式绑定"></a>2.2.3 显式绑定</h4><p>如果不想在对象内部包含函数引用，而想在某个对象上强制调用函数，可以使用函数的<strong>call和apply</strong>方法。JS中所有的函数包括自己创建的函数都可以调用call和apply方法，因为这两个方法都是函数原型上的方法：<code>Function.prototype.call</code>。</p>
<p>call和apply的第一个参数是对象，会在函数调用时强制将this绑定给这个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  console.log(this.a);</div><div class="line">&#125;</div><div class="line">var obj = &#123;a: 2&#125;;</div><div class="line">foo.call(obj); // 2</div></pre></td></tr></table></figure>
<p>也可以通过一个辅助绑定函数来显示绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo(b)&#123;</div><div class="line">  console.log(this.a, b);</div><div class="line">  return this.a + b;</div><div class="line">&#125;</div><div class="line">function bind(fn, obj)&#123;</div><div class="line">  return function()&#123;</div><div class="line">    return fn.apply(obj, arguments);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var obj = &#123;a: 2&#125;;</div><div class="line">var bar = bind(foo, obj);</div><div class="line">var c = bar(3); // 2 3</div><div class="line">console.log(c); // 5</div></pre></td></tr></table></figure>
<p>当然在ES5中也提供了内置的方法<code>Function.prototype.bind</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var bar = foo.bind(obj);</div><div class="line">var c = bar(3); // 2 3</div><div class="line">console.log(c); // 5</div></pre></td></tr></table></figure>
<p>硬绑定的bar不能再修改它的this了，让我想到箭头函数也是不能修改this 的。</p>
<p>JS一些内置函数也可以确保回调函数使用指定的this。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  console.log(this.val);</div><div class="line">&#125;</div><div class="line">var obj = &#123;val: &apos;ok&apos;&#125;;</div><div class="line">[1,2,3].forEach(foo, obj); // ok*3</div></pre></td></tr></table></figure>
<h4 id="2-2-4-new绑定"><a href="#2-2-4-new绑定" class="headerlink" title="2.2.4 new绑定"></a>2.2.4 new绑定</h4><p>在JS中使用new操作符时被调用的函数才是构造函数调用。</p>
<p>使用new发生构造函数调用时，会自动执行下面的操作：</p>
<ol>
<li>创建一个全新的对象<code>var fn = new Object();</code></li>
<li>设置对象原型链<code>fn.__proto__ = F.prototype;</code></li>
<li>函数调用的this绑定给新对象<code>F.call(fn);</code></li>
<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo(a)&#123;</div><div class="line">  this.a = a;</div><div class="line">&#125;</div><div class="line">var bar = new foo(2);</div><div class="line">console.log(bar.a); // 2</div></pre></td></tr></table></figure>
<p>使用new调用foo时，会构造一个新对象并把它绑定到foo调用的this上。new是最后一种可以影响函数调用时的this绑定行为的方法。</p>
<h3 id="2-3-优先级"><a href="#2-3-优先级" class="headerlink" title="2.3 优先级"></a>2.3 优先级</h3><ul>
<li>默认绑定优先级最低。</li>
<li>显式绑定比隐式绑定优先级高。</li>
<li>new绑定比隐式绑定优先级高。</li>
<li>new和call/apply无法一起使用。</li>
<li>polyfill代码主要用于旧浏览器的兼容（原意是刮墙的腻子来抹平差异）。</li>
</ul>
<h4 id="Curry-柯里化"><a href="#Curry-柯里化" class="headerlink" title="Curry(柯里化)"></a><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#总结" target="_blank" rel="external">Curry(柯里化)</a></h4><p>先看一个curry的简单例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var add = function(x)&#123;</div><div class="line">	return function(y)&#123;</div><div class="line">		return x + y;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var increment = add(1);</div><div class="line">increment(2); // 3</div></pre></td></tr></table></figure>
<p><strong>curry的概念：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。这样的局部调用能够大量减少代码。</strong></p>
<p>文中提到在new中使用硬绑定函数，目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数，bind的功能之一就是可以把除了第一个参数（第一个参数用于绑定this）之外的其他参数都传给下层的函数。看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(a,b)&#123;</div><div class="line">  this.val = a+b;</div><div class="line">  console.log(this.val);</div><div class="line">&#125;</div><div class="line">var bar = foo.bind(null, &apos;a&apos;); // 使用null是因为在本例中并不关心硬绑定的this是什么，反正new时this会被修改</div><div class="line">var baz = new bar(&apos;b&apos;); // &apos;ab&apos;</div></pre></td></tr></table></figure>
<h4 id="判断this"><a href="#判断this" class="headerlink" title="判断this"></a>判断this</h4><ol>
<li>函数是否在new 中调用（new绑定）？如果是的话this绑定的是新创建的对象。<code>var bar = new foo();</code></li>
<li>函数是否通过call、apply（显式绑定）或者硬绑定调用？如果是的话，this绑定的是指定的对象。<code>var bar = foo.call(obj) ;</code></li>
<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。<code>var bar = obj.foo();</code></li>
<li>如果都不是，使用默认绑定，绑定到全局对象。如果在严格模式下，就绑定到undefined。<code>var bar = foo();</code></li>
</ol>
<h3 id="2-4-绑定例外"><a href="#2-4-绑定例外" class="headerlink" title="2.4 绑定例外"></a>2.4 绑定例外</h3><h4 id="2-4-1-被忽略的this"><a href="#2-4-1-被忽略的this" class="headerlink" title="2.4.1 被忽略的this"></a>2.4.1 被忽略的this</h4><p>当把null或undefined作为this的绑定对象传入call、apply或bind时应用的是默认绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  console.log(this.a);</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo.call(null); // 2</div></pre></td></tr></table></figure>
<p>什么情况下会传入null？</p>
<ol>
<li><p>使用apply展开一个数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function foo(a, b)&#123;</div><div class="line">  console.log(a, b);</div><div class="line">&#125;</div><div class="line">foo.apply(null, [1,2]); // 1 2</div></pre></td></tr></table></figure>
<p>ES6中有提供扩展运算符<code>...</code>可以代替apply来展开数组<code>foo(...[1,2])</code></p>
</li>
<li><p>使用bind进行柯里化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var bar = foo.bind(null, 1);</div><div class="line">bar(2); // 1 2</div></pre></td></tr></table></figure>
<p>如果函数并不关心this的话，使用bind仍需要传入一个占位值，就传入null。</p>
</li>
</ol>
<h4 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的this</h4><p>使用null来忽略this绑定可能产生一些副作用，比如使用第三方库中的一个函数中的this如果应用了默认绑定规则会把this绑定到全局对象，会导致不可预计的后果（比如修改全局对象）。</p>
<p>一个更安全的做法是传入一个特殊的空对象<code>Object.create(null)</code>，和<code>{}</code>（等价于 new Object()）不同的是，前者是没有原型链的，比<code>{}</code>更空。</p>
<h4 id="2-4-2-间接引用"><a href="#2-4-2-间接引用" class="headerlink" title="2.4.2 间接引用"></a>2.4.2 间接引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  console.log(this.a);</div><div class="line">&#125;</div><div class="line">var a = 1;</div><div class="line">var o = &#123;a: 2, foo: foo&#125;;</div><div class="line">var p = &#123;a: 3&#125;;</div><div class="line">o.foo(); // 2</div><div class="line">(p.foo = o.foo)(); // 1</div></pre></td></tr></table></figure>
<p>赋值表达式<code>p.foo = o.foo</code>的返回值是目标函数的引用，此时调用位置是foo，而不是<code>p.foo</code>或<code>o.foo</code>，会应用默认绑定。</p>
<h4 id="2-4-3-软绑定"><a href="#2-4-3-软绑定" class="headerlink" title="2.4.3 软绑定"></a>2.4.3 软绑定</h4><p>因为使用硬绑定之后无法修改this，软绑定就是实现和硬绑定相同的效果同时保留隐式绑定或显式绑定修改this的能力。</p>
<p>注：然而代码没太看懂，也不太想细钻了。</p>
<h3 id="2-5-this词法"><a href="#2-5-this词法" class="headerlink" title="2.5 this词法"></a>2.5 this词法</h3><p>ES6中的箭头函数不使用this的上面这几种规则， 而是根据外层（函数或全局）作用域来决定this。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">	setTimeout(function () &#123;</div><div class="line">		console.log(this.a);</div><div class="line">	&#125;, 0);</div><div class="line">&#125;</div><div class="line">var a = 1;</div><div class="line">var obj = &#123;a: 2&#125;;</div><div class="line">foo(); // 1</div><div class="line">foo.call(obj); // 1</div></pre></td></tr></table></figure>
<p>箭头函数最常用于回调函数中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">	setTimeout(() =&gt; &#123;</div><div class="line">		console.log(this.a);</div><div class="line">	&#125;, 0);</div><div class="line">&#125;</div><div class="line">var a = 1;</div><div class="line">var obj = &#123;a: 2&#125;;</div><div class="line">foo(); // 1</div><div class="line">foo.call(obj); // 2</div></pre></td></tr></table></figure>
<p>箭头函数会继承外层函数调用的this绑定， 这和ES6之前代码中的<code>self = this</code>机制一样。</p>
<h3 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h3><p>如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面四条规则来判断this 的绑定对象。</p>
<ol>
<li>由new调用？绑定到新创建的对象。</li>
<li>由call或者apply（或者bind）调用？绑定到指定的对象。</li>
<li>由上下文对象调用？绑定到那个上下文对象。</li>
<li>默认：在严格模式下绑定到undefined，否则绑定到全局对象。</li>
</ol>
<p>一定注意，有些调用可能在无意中使用默认绑定规则，如果想“更安全”地忽略this绑定，你可以使用一个DMZ对象，比如<code>Object.create(null)</code>，以保护全局对象。</p>
<p>ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体来说，箭头函数会继承外层函数调用的this绑定（无论this绑定到什么）。这其实和ES6之前代码中的<code>self=this</code>机制一样。</p>
<h2 id="第3章-对象"><a href="#第3章-对象" class="headerlink" title="第3章 对象"></a>第3章 对象</h2><h3 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h3><p>对象定义的两种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 声明形式</div><div class="line">var obj = &#123;</div><div class="line">  key: val,</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 构造形式 （不常用）</div><div class="line">var obj = new Object();</div><div class="line">obj.key = val;</div></pre></td></tr></table></figure>
<h3 id="3-2-类型"><a href="#3-2-类型" class="headerlink" title="3.2 类型"></a>3.2 类型</h3><p>JS中的六种主要类型：<code>string,number,boolean,null,undefined,object</code>.</p>
<h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">String</div><div class="line">Number</div><div class="line">Boolean</div><div class="line">Object</div><div class="line">Function</div><div class="line">Array</div><div class="line">Date</div><div class="line">RegExp</div><div class="line">Error</div></pre></td></tr></table></figure>
<p>内置对象不同于基础类型，可以当做构造函数使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var str1 = &quot;I am a string&quot;;</div><div class="line">typeof str1; // &quot;string&quot;</div><div class="line">str1 instanceof String; // false</div><div class="line"></div><div class="line">var str2 = new String(&quot;I am a string&quot;);</div><div class="line">typeof str2; // &quot;object&quot;</div><div class="line">str2 instanceof String; // true</div><div class="line"></div><div class="line">Object.prototype.toString.call(str2); // [object String]</div></pre></td></tr></table></figure>
<p>str1只是一个字面量，并且是一个不可变的只。如果在字面量上执行一些操作，比如获取长度，访问某个字符等，语言会自动把字符串字面量转换成一个String对象，也就是说你并不需要显式创建一个对象。</p>
<p>null和undefined没有对应的构造形式，只有文字形式。Date只有构造，没有文字形式。</p>
<p>对于Object、Array、Function和RegExp来说，无论哪种形式都是对象。</p>
<p>Error对象很少在代码中显式创建，一般是在抛出异常时自动创建。</p>
<h3 id="3-3-内容"><a href="#3-3-内容" class="headerlink" title="3.3 内容"></a>3.3 内容</h3><p>存储在对象内部的是这些属性的名称，它们指向值真正的存储位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">  a: 2</div><div class="line">&#125;;</div><div class="line">obj.a; // 2</div><div class="line">obj[&apos;a&apos;]; // 2</div></pre></td></tr></table></figure>
<p>访问obj中a的值，可以使用<code>.</code>操作符（属性访问）或者<code>[]</code>操作符（键访问）。两种语法的区别在于：<code>.</code>操作符要求属性名满足标识符的命名规范，而<code>[&quot;..&quot;]</code>语法可以接受任意UTF-8/Unicode字符串作为属性名。</p>
<p>在对象中，属性名一定都是<strong>字符串</strong>。如果你使用string意外的其他值作为属性名，那它会首先被转换为一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line">obj[true] = &quot;foo&quot;;</div><div class="line">obj[&apos;true&apos;]; // &apos;foo&apos;</div><div class="line"></div><div class="line">obj[3] = &apos;bar&apos;;</div><div class="line">obj[&apos;3&apos;]; // &apos;bar&apos;</div><div class="line"></div><div class="line">obj[obj] = &apos;baz&apos;;</div><div class="line">obj[&quot;[object Object]&quot;]; // &apos;baz&apos;</div></pre></td></tr></table></figure>
<h4 id="3-3-1-可计算属性名"><a href="#3-3-1-可计算属性名" class="headerlink" title="3.3.1 可计算属性名"></a>3.3.1 可计算属性名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var prefix = &quot;foo&quot;;</div><div class="line">var obj = &#123;</div><div class="line">  [prefix + &quot;bar&quot;]: &apos;hello&apos;,</div><div class="line">&#125;</div><div class="line">obj[&apos;foobar&apos;]; //hello</div></pre></td></tr></table></figure>
<p>可计算属性名最常用的场景是ES6的符号（Symbol）。</p>
<h4 id="3-3-2-属性与方法"><a href="#3-3-2-属性与方法" class="headerlink" title="3.3.2 属性与方法"></a>3.3.2 属性与方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  console.log(&apos;foo&apos;);</div><div class="line">&#125;</div><div class="line">var someFoo = foo;</div><div class="line">var obj = &#123;</div><div class="line">  someFoo: foo</div><div class="line">&#125;;</div><div class="line">foo; // function foo()&#123;..&#125;</div><div class="line">someFoo; // function foo()&#123;..&#125;</div><div class="line">obj.someFoo; // function foo()&#123;..&#125;</div></pre></td></tr></table></figure>
<p>someFoo和obj.someFoo只是对于同一个函数的不同引用，不能说明这个函数是属于这个对象。</p>
<h4 id="3-3-3-数组"><a href="#3-3-3-数组" class="headerlink" title="3.3.3 数组"></a>3.3.3 数组</h4><p>数组支持<code>[]</code>访问形式，期望的是数值下表，也就是值存储的位置（通常被称为索引）是整数，不同于对象的访问。</p>
<p>可以对数组添加属性，访问方式同对象，但是数组的length值并未发生变化。完全可以把数组当作一个普通的键值对象来使用，并且不添加任何数值索引，但这并不是一个好主意。</p>
<p>注意：如果向数组添加的属性看起来像一个数字，它会变成数值下标，会修改数组的内容而不是添加一个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</div><div class="line">arr[&quot;3&quot;] = 3;</div><div class="line">arr; //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 3]</div></pre></td></tr></table></figure>
<h4 id="3-3-4-复制对象"><a href="#3-3-4-复制对象" class="headerlink" title="3.3.4 复制对象"></a>3.3.4 复制对象</h4><p>浅复制：<code>var newObj = Object.assign({}, oldObj)</code>，Object.assign就是使用=操作符来赋值。</p>
<p>深复制：<code>var newObj = JSON.parse(JSON.stringify(oldObj))</code>。深复制可能会有循环引用的问题。</p>
<h4 id="3-3-5-属性描述符"><a href="#3-3-5-属性描述符" class="headerlink" title="3.3.5 属性描述符"></a>3.3.5 属性描述符</h4><p>从ES5开始，所有属性都具备属性描述符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;a: 2&#125;;</div><div class="line">Object.getOwnPropertyDescriptor(obj, &apos;a&apos;);</div><div class="line">//</div><div class="line">&#123;</div><div class="line">  value: 2,</div><div class="line">  writable: true,</div><div class="line">  enumerable: true,</div><div class="line">  configurable: true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建属性时属性描述符会使用默认值，可以使用<code>Object.defineProperty(..)</code>来添加新属性或修改已有属性。</p>
<p>writable设置为不可写后，严格模式下修改对象的属性值会报TypeError，相当于定义了一个空操作setter，被调用时抛出一个TypeError错误。</p>
<p>configurable(可配置)修改为false是单向操作，无法撤销，除了无法修改，还会禁止删除这个属性。delete只用来删除对象的可删除属性，若删除的属性是某个对象/函数的最后一个引用者，则这个未引用的对象可以被垃圾回收。不要把delete看作释放内存的工具。</p>
<p>enumerable(可枚举)设置为false，这个属性就不会出现在for…in循环美剧中，但仍可以正常访问。</p>
<h4 id="3-3-6-不变性"><a href="#3-3-6-不变性" class="headerlink" title="3.3.6 不变性"></a>3.3.6 不变性</h4><p>如果希望属性或对象不可改变，可以通过以下方法来实现：</p>
<ol>
<li><p>对象常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line">Object.defineProperty(obj, &quot;PROPERTY&quot;, &#123;</div><div class="line">  value: 2,</div><div class="line">  writable: false,</div><div class="line">  configurable: false</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>禁止扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line">Object.preventExtensions(obj);</div><div class="line">obj.a = 2;</div><div class="line">obj.a; // undefined</div></pre></td></tr></table></figure>
</li>
<li><p>密封</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.seal(); // 这个方法实际上会调用Object.preventExtensions并把所有现有属性标记为configurable:false</div></pre></td></tr></table></figure>
</li>
<li><p>冻结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.freeze(obj); // 这个方法会在现有对象上调用Object.seal并把所有数据访问属性标记为writable:false。这个方法是级别最高的不可变性，会禁止对象本身及其任意直接属性的修改，但这个对象引用的其他对象是不受影响的。</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-3-7-Get"><a href="#3-3-7-Get" class="headerlink" title="3.3.7 [[Get]]"></a>3.3.7 [[Get]]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;a:2&#125;;</div><div class="line">obj.a; // 2</div></pre></td></tr></table></figure>
<p>对属性a的访问实际上是实现了get操作，首先在对象中查找是否有名称相同的属性，如果没有找到会遍历可能存在的prototype链，如果都没有找到则返回undefined。</p>
<p>访问属性和访问变量是不一样的，如果引用了一个当前词法作用域中不存在的变量，会抛出一个ReferenceError异常。</p>
<h4 id="3-3-8-Put"><a href="#3-3-8-Put" class="headerlink" title="3.3.8 [[Put]]"></a>3.3.8 [[Put]]</h4><p>如果已经存在这个属性，[[Put]]算法大致会检查下面的内容：</p>
<ol>
<li>属性是否是访问描述符，如果是并且存在setter就调用setter。</li>
<li>属性的数据描述符中writable是否是false？如果是，在非严格模式下默认失败，在严格模式下抛出TypeError异常。</li>
<li>如果都不是，将该值设置为属性的值。</li>
</ol>
<p>如果对象中不存在这个属性，[[Put]]操作会更加复杂。涉及到后面的[[Prototype]]。</p>
<h4 id="3-3-9-Getter和Setter"><a href="#3-3-9-Getter和Setter" class="headerlink" title="3.3.9 Getter和Setter"></a>3.3.9 Getter和Setter</h4><p>对象默认的[[Put]]和[[Get]]操作分别可以控制属性值的设置和获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line">Object.defineProperty(obj, &apos;a&apos;, &#123;</div><div class="line">  get: function()&#123;</div><div class="line">    return 4;</div><div class="line">  &#125;,</div><div class="line">  enumerable: true</div><div class="line">&#125;);</div><div class="line">obj.a; // 4</div></pre></td></tr></table></figure>
<p>Cannot both specify accessors and a value or writable attribute.</p>
<p>对象文字语法中的<code>get a() {}</code>和<code>defintProperty()</code>显示定义等价。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">  get a()&#123;</div><div class="line">    return this._a;</div><div class="line">  &#125;,</div><div class="line">  set a(val)&#123;</div><div class="line">    this._a = val;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-3-10-存在性"><a href="#3-3-10-存在性" class="headerlink" title="3.3.10 存在性"></a>3.3.10 存在性</h4><p>判断对象中是否存在这个属性:</p>
<ol>
<li><code>(&quot;a&quot; in obj)</code>             in操作符会检查属性是否在对象及其[[Prototype]]原型链中。 </li>
<li><code>obj.hasOwnProperty(&quot;a&quot;);</code>      hasOwnProperty只会检查属性是否在对象中。</li>
</ol>
<p>所有普通对象都是通过Object.prototype的委托来访问hasOwnProperty，但是有的对象可能没有连接到Object.prototype（通过Object.create(null)来创建）。这种情况下，obj.hasOwnProperty就会失败。可以通过<code>Object.prototype.call(obj, &#39;a&#39;)</code>来判断。</p>
<p><strong>注意</strong>：<code>4 in [2,4,6]</code>的结果并不是期待的true，因为这个数组中包含的属性名是0,1,2，这是in操作符检查属性时对象与数组的区别。</p>
<p><code>Object.keys()</code>返回数组，包含所有可枚举属性。<code>Object.getOwnPropertyNames()</code>返回数组包含所有属性，无论是否可枚举。但这两种方法都只会查找对象直接包含的属性。</p>
<h3 id="3-4-遍历"><a href="#3-4-遍历" class="headerlink" title="3.4 遍历"></a>3.4 遍历</h3><p>ES5中增加了一些数组的辅助迭代器，包括forEach、every、some，有意思的是forEach中不能return和break，一定会全部执行完，而every和some都类似于for循环中break会提前终止遍历。</p>
<p>遍历数组是按下标顺序，遍历对象属性的顺序是不确定的，不同JS引擎可能不一样。</p>
<p>ES6中增加了<code>for..of</code>来遍历数组的循环语法，如果对象本身定义了迭代器也可以遍历对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3];</div><div class="line">for(var v of arr)&#123;</div><div class="line">  console.log(v);</div><div class="line">&#125;</div><div class="line">// for..of循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next方法来遍历所有返回值，数组有内置的@@iterator，可以使用内置的@@iterator来手动遍历数组</div><div class="line">var arr = [1,2,3];</div><div class="line">var it = arr[Symbol.iterator]();</div><div class="line">it.next(); // &#123;value: 1, done: false&#125;</div><div class="line">it.next(); // &#123;value: 2, done: false&#125;</div><div class="line">it.next(); // &#123;value: 3, done: false&#125;</div><div class="line">it.next(); // &#123;done: true&#125;</div></pre></td></tr></table></figure>
<p>普通对象没有内置的@@iterator，无法自动完成for..of遍历。可以自定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;a: 2, b: 3&#125;;</div><div class="line">Object.defineProperty(obj, Symbol.iterator, &#123;</div><div class="line">  enumerable: false, // 定义自己的@@iterator主要是不可枚举</div><div class="line">  writable: false,</div><div class="line">  configurable: true,</div><div class="line">  value: function()&#123;</div><div class="line">    var o = this;</div><div class="line">    var idx = 0;</div><div class="line">    var ks = Object.keys(o);</div><div class="line">    return &#123;</div><div class="line">      next: function()&#123;</div><div class="line">        return &#123;</div><div class="line">          value: o[ks[idx++]],</div><div class="line">          done: (idx &gt; ks.length)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">// 手动遍历</div><div class="line">var it = obj[Symbol.iterator]();</div><div class="line">it.next(); // &#123;value: 2, done: false&#125;</div><div class="line">it.next(); // &#123;value: 3, done: false&#125;</div><div class="line">it.next(); // &#123;value: undefined, done: true&#125;</div><div class="line">// 用for..of遍历</div><div class="line">for(var v of obj)&#123;</div><div class="line">	console.log(v)</div><div class="line">&#125;</div><div class="line">// 2</div><div class="line">// 3</div></pre></td></tr></table></figure>
<h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p>JS中的对象有字面形式（比如var a = {…}）和构造形式（比如var a = new Array(..)）。字面形式更常用，不过有时候构造形式可以提供更多选项。</p>
<p>许多人都认为“JS中万物都是对象”，这是错误的。对象是6个（或者7个，取决于你的观点）基础类型之一。对象包括function在内的子类型，不同子类型具有不同的行为，比如内部标签[object Array]表示这是对象的子类型数组。</p>
<p>对象就是键值对的集合。可以通过<code>.propName</code>或者<code>[&quot;propName&quot;]</code>语法来获取属性值。访问属性时，引擎实际上会调用内部的默认[[Get]]操作（在设置属性值时是[[Put]]），[[Get]]操作会检查对象本身是否包含这个属性，如果没找到还会继续查找[[Prototype]]链。</p>
<p>属性的特性可以通过属性描述符来控制，比如writable和configurable。此外，可以使用<code>Object.preventExtensions(..)</code>、<code>Object.seal(..)</code>和<code>Object.freeze(..)</code>来设置对象（及其属性）的不可变性级别。</p>
<p>属性不一定包含值，他们可能是具备getter/setter的访问描述符，此外，属性可以是可枚举或者不可枚举的，这决定了他们是否会出现在for..in循环中。</p>
<p>你可以使用ES6的for..of语法来遍历数据结构（数组、对象等等），for..of会寻找内置或自定义的@@iterator对象并调用他的next方法来遍历数据值。</p>
<h2 id="第四章-混合对象“类”"><a href="#第四章-混合对象“类”" class="headerlink" title="第四章 混合对象“类”"></a>第四章 混合对象“类”</h2><h3 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 小结</h3><p>类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。JS中也有类似的语法，但是和其他语言中的类完全不同。</p>
<p>类意味着复制。</p>
<p>传统的类被实例化时，他的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。</p>
<p>多态（可以把子类的实例赋给父类）看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">struct A</div><div class="line">&#123;</div><div class="line">    virtual void f()</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; &quot;A&quot; &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">struct B: public A</div><div class="line">&#123;</div><div class="line">    void f()</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; &quot;B&quot; &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">void test(A* p)</div><div class="line">&#123;</div><div class="line">    p-&gt;f();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    B b;</div><div class="line">    test(&amp;b); // B</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JS并不会像类那样自动创建对象的复本。</p>
<p>混入模式一节没有太看，是为了描述在JS中模拟类得不偿失，会带来很多隐患。</p>
<h2 id="第五章-原型"><a href="#第五章-原型" class="headerlink" title="第五章 原型"></a>第五章 原型</h2><h3 id="5-1-Prototype"><a href="#5-1-Prototype" class="headerlink" title="5.1 [[Prototype]]"></a>5.1 [[Prototype]]</h3><p>JS中的对象有一个特殊的<code>[[Prototype]]</code>内置属性，其实是对于其他对象的引用。几乎所有的对象在创建时<code>[[Prototype]]</code>属性都会被赋予一个非空的值。</p>
<p>在第3章中提到，当试图引用对象的属性时会触发<code>[[Get]]</code>操作，对于默认的<code>[[Get]]</code>操作来说，第一步是检查对象本身是否有这个属性，有的话使用它，没有的话就需要使用对象的<code>[[Prototype]]</code>链。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var anotherObj = &#123;</div><div class="line">  a: 2</div><div class="line">&#125;;</div><div class="line">var obj = Object.create(anotherObj);</div><div class="line">obj.a; // 2</div></pre></td></tr></table></figure>
<p><code>Object.create()</code>会创建一个对象并把这个对象的<code>[[Prototype]]</code>关联到指定的对象。</p>
<p><code>[[Get]]</code>操作会持续找到匹配的属性名或者查找完整条<code>[[Prototype]]</code>链返回undefined。</p>
<p>使用<code>for...in</code>遍历对象时原理和查找<code>[[Prototype]]</code>链类似，任何可以通过原型链访问到（并且是enumerable）的属性都会被枚举。</p>
<p>使用in操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链（无论属性是否可枚举）。</p>
<h4 id="5-1-1-Object-prototype"><a href="#5-1-1-Object-prototype" class="headerlink" title="5.1.1 Object.prototype"></a>5.1.1 Object.prototype</h4><p>到哪里是<code>[[Prototype]]</code>的尽头呢？</p>
<p>所有普通的<code>[[Prototype]]</code>链最终都会指向内置的Obejct.prototype。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">对象原型链的终点：</div><div class="line">Object.getPrototypeOf(Object.prototype); // null</div></pre></td></tr></table></figure>
<p>由于所有的普通对象都源于这个Object.prototype对象，它包含JS中很多通用功能，比如<code>.toString(), .valueOf(), hasOwnProperty(), isPrototypeOf()</code>。</p>
<h4 id="5-1-2-属性设置和屏蔽"><a href="#5-1-2-属性设置和屏蔽" class="headerlink" title="5.1.2 属性设置和屏蔽"></a>5.1.2 属性设置和屏蔽</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myObj.foo = &quot;bar&quot;;</div></pre></td></tr></table></figure>
<p>如果myObj对象中包含名为foo的普通数据访问属性，这条赋值语句就会修改已有的属性值。</p>
<p>如果foo不是直接存在于myObj中，<code>[[Prototype]]</code>链就会被遍历，类似<code>[[Get]]</code>操作。如果原型链上找不到foo，foo就会被直接添加到myObj上。</p>
<p>如果foo存在于原型链上层，会出现三种情况：</p>
<ol>
<li><p>如果在<code>[[Prototype]]</code>链上层存在名为foo的普通数据访问属性，没有被标记为只读，也就是<code>(writable:true)</code>，就会直接在myObj中添加一个名为foo的新属性，它是<strong>屏蔽属性</strong>。</p>
</li>
<li><p>如果在<code>[[Prototype]]</code>链上层存在foo，但是被标记为只读<code>(writable:false)</code>，那么无法修改已有属性或者在myObj上创建屏蔽属性。如果运行在严格模式下回报错，否则这条赋值语句会被忽略。总之不会发生屏蔽。</p>
</li>
<li><p>如果在<code>[[Prototype]]</code>链上层存在foo并且它是一个setter，就一定会调用这个setter。foo不会被添加到myObj，也不会重新定义foo这个setter。</p>
</li>
<li><p>如果希望在第二种和第三种情况下也屏蔽foo，就不能使用<code>=</code>操作符，而是使用<code>Object.defineProperty(..)</code>来想mObj添加foo。</p>
</li>
</ol>
<p>如果foo即出现在myObj中也出现在myObj的原型链上层，那么会发生屏蔽。myObj中包含的foo属性会屏蔽原型链上层的所有foo属性。</p>
<p>有些情况下会产生隐式屏蔽：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var anotherObj = &#123;a: 2&#125;;</div><div class="line">var myObj = Object.create(anotherObj);</div><div class="line">anotherObj.a; // 2</div><div class="line">myObj.a; // 2</div><div class="line">anotherObj.hasOwnProperty(&apos;a&apos;); // true</div><div class="line">myObj.hasOwnProperty(&apos;a&apos;); // false</div><div class="line"></div><div class="line">myObj.a++; // 隐式屏蔽！</div><div class="line"></div><div class="line">anotherObj.a; // 2</div><div class="line">myObj.a; // 3</div><div class="line"></div><div class="line">myObj.hasOwnProperty(&apos;a&apos;); // true</div></pre></td></tr></table></figure>
<p>尽管<code>myObj.a++</code>看起来是查找并增加<code>anotherObj.a</code>属性，但是<code>++</code>操作相当于<code>myObj.a = myObj.a + 1</code>，也就是先<code>[[Get]]</code>再<code>[[Put]]</code>。</p>
<h3 id="5-2-“类”"><a href="#5-2-“类”" class="headerlink" title="5.2 “类”"></a>5.2 “类”</h3><h4 id="5-2-1-类函数"><a href="#5-2-1-类函数" class="headerlink" title="5.2.1 类函数"></a>5.2.1 类函数</h4><p>JS中所有<strong>函数</strong>(Foo)默认都拥有一个名为prototype的公有并且不可枚举的属性，它指向另一个对象，这个对象被称为Foo的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Foo()&#123;&#125;</div><div class="line">var a = new Foo();</div><div class="line">Object.getPrototypeOf(a) === Foo.prototype; // true</div></pre></td></tr></table></figure>
<p><code>new Foo()</code>会生成一个新对象，这个新对象内部<code>[[Prototype]]</code>关联的就是<code>Foo.prototype</code>对象。</p>
<p><strong>自己测试了一下<code>Object.create()</code>和<code>new Object()</code>的区别：</strong></p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;a: 1&#125;;</div><div class="line"></div><div class="line">var newObj = Object.create(obj);</div><div class="line">newObj.__proto__ === obj; // true</div><div class="line"></div><div class="line">// 这里obj不是构造函数所以不能通过new的方式生成新对象</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 一定是函数才有prototype属性</div><div class="line">var obj = function()&#123;&#125;;</div><div class="line"></div><div class="line">var newObj2 = Object.create(obj);</div><div class="line">newObj2.__proto__ === obj; // true</div><div class="line"></div><div class="line">var newObj = new obj();</div><div class="line">newObj.__proto__ === obj.prototype; // true</div></pre></td></tr></table></figure>
</li>
</ol>
<p>创建类的实例的过程是复制行为，但是JS一直在模仿类的行为，却并没有类似的复制机制，而是通过<code>[[prototype]]</code>让对象之间关联。</p>
<h4 id="⚠️注意："><a href="#⚠️注意：" class="headerlink" title="⚠️注意："></a>⚠️注意：</h4><ol>
<li><p>所有的对象都有<code>__proto__</code>内置属性，称为隐式原型，除了<code>Object.prototype</code>。这个属性指向创建这个对象的函数（constructor）的prototype。</p>
</li>
<li><p>所有的函数都有<code>prototype</code>公有属性，称为显式原型，除了通过<code>Function.prototype.bind</code>构造出来的函数。这个属性指向函数的原型对象。</p>
</li>
</ol>
<p>具体区别<a href="https://www.zhihu.com/question/34183746" target="_blank" rel="external">参考这里</a></p>
<h4 id="5-2-2-构造函数"><a href="#5-2-2-构造函数" class="headerlink" title="5.2.2 构造函数"></a>5.2.2 构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Foo()&#123;&#125;</div><div class="line">Foo.prototype.constructor === Foo; // true</div><div class="line"></div><div class="line">var a = new Foo();</div><div class="line">a.constructor === Foo; // true</div><div class="line">a.__proto__.constructor === Foo; // true</div></pre></td></tr></table></figure>
<p><code>Foo.prototype</code>默认有一个公有并且不可枚举的属性<code>.constructor</code>，这个属性引用的是对象关联的函数Foo。</p>
<p><strong>构造函数还是调用？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function NothingSpecial()&#123;</div><div class="line">  console.log(&apos;hello&apos;);</div><div class="line">&#125;</div><div class="line">var a = new NothingSpecial(); // &quot;hello&quot;</div><div class="line">a; // &#123;&#125;</div></pre></td></tr></table></figure>
<p>NothingSpecial只是一个普通函数，但是使用new调用是，它会构造一个对象并赋值给a，这是new的副作用（无论如何都会构造一个对象）。这个调用是一个构造函数调用。</p>
<p>所以，函数不是构造函数，当且仅当使用new时，函数调用会变成“构造函数调用”。</p>
<p><strong><code>a.constructor</code>是一个非常不可靠并且不安全的引用，要尽量避免使用这些引用。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Foo()&#123;&#125;;</div><div class="line">Foo.prototype = &#123;&#125;; // 创建一个新的原型对象</div><div class="line">// 需要在Foo.prototype上修复丢失的.constructor属性</div><div class="line">Object.defineProperty(Foo.prototype, &quot;constructor&quot;, &#123;</div><div class="line">  enumerable: false,</div><div class="line">  writable: true,</div><div class="line">  configurable: true,</div><div class="line">  value: Foo // 让.constructor指向Foo</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>.constructor</code>并不是一个不可变属性，他是不可枚举的，但是是可写的。你可以给任意<code>[[prototype]]</code>链中的仁义对象添加一个名为constructor的属性或者对其进行修改，你可以任意对其赋值。</p>
<h3 id="5-3-原型-继承"><a href="#5-3-原型-继承" class="headerlink" title="5.3 (原型)继承"></a>5.3 (原型)继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Foo(name)&#123;</div><div class="line">  this.name = name;</div><div class="line">&#125;</div><div class="line">Foo.prototype.myName = function()&#123;</div><div class="line">  return this.name;</div><div class="line">&#125;</div><div class="line">function Bar(name)&#123;</div><div class="line">  Foo.call(this, name);</div><div class="line">&#125;</div><div class="line">Bar.prototype = Object.create(Foo.prototype);</div><div class="line">var a = new Bar(&apos;a&apos;);</div><div class="line">a.myName(); // &quot;a&quot;</div></pre></td></tr></table></figure>
<p>这段代码的核心就是<code>Bar.prototype = Object.create(Foo.prototype);</code>。调用<code>Object.create()</code>会创建一个新对象并新对象内部的<code>[[prototype]]</code>关联到你指定的对象<code>Foo.prototype</code>。</p>
<p><strong>注意：下面这两种方式是常见的错误做法，因为它们都存在一些问题</strong></p>
<ol>
<li><p><code>Bar.prototype = Foo.prototype</code></p>
<p> 这个做法并不会创建一个关联到<code>Bar.prototype</code>新对象，它只是让<code>Bar.prototype</code>直接饮用<code>Foo.prototype</code>对象。因此当执行雷西<code>Bar.prototype.myName = ...</code>的赋值语句时会直接修改<code>Foo.prototype</code>对象本身。</p>
</li>
<li><p><code>Bar.prototype = new Foo()</code></p>
<p> 这个做法的确会创建一个关联到<code>Bar.prototype</code>的新对象。但是它使用了Foo的构造函数调用，如果函数Foo有一些副作用（比如写日志、修改状态、注册到其他对象、给this添加数据属性等等）的话，就会影响到Bar的后代。</p>
</li>
</ol>
<p>因此，要创建一个合适的关联对象，必须使用<code>Object.create()</code>而不是使用具有副作用的<code>Foo()</code>。这样做唯一的缺点就是需要创建一个新对象a并把它关联到希望的对象上，然后把旧对象Bar抛弃掉，抛弃的对象需要进行垃圾回收。</p>
<p>在ES6之前，只能通过设置<code>__proto__</code>属性来实现修改对象的<code>[[Prototype]]</code>关联，ES6添加了<code>Object.setPrototypeOf()</code>，可以用标准并可靠的方法来修改关联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// ES6之前需要抛弃默认的Bar.prototype</div><div class="line">Bar.prototype = Object.create(Foo.prototype);</div><div class="line">// ES6开始可以直接修改现有的Bar.prototype</div><div class="line">Object.setPrototypeOf(Bar.prototype, Foo.prototype);</div></pre></td></tr></table></figure>
<p><strong>检查“类”关系</strong></p>
<p>在传统面向类的观景中，检查一个实例（JS中国年的对象）的继承祖先（JS中的委托关联）通常被称为内省（或反射）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Foo()&#123;&#125;</div><div class="line">Foo.prototype.blah = ...;</div><div class="line">var a = new Foo();</div></pre></td></tr></table></figure>
<ol>
<li><p>instanceof</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a instanceof Foo; // true</div></pre></td></tr></table></figure>
<p> instanceof操作符的左操作数是一个普通的对象，右操作数是一个函数。instanceof回答的问题是：在a的整条<code>[[prototype]]</code>链中是否有指向<code>Foo.prototype</code>的对象。</p>
<p> instanceof智能处理对象（a）和函数（带prototype引用的Foo）之间的关系，如果想判断两个对象（比如a和b）之间是否通过<code>[[Prototype]]</code>链关联，只用instanceof无法实现。</p>
</li>
<li><p>isPrototypeOf</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Foo.prototype.isPrototypeOf(a); // true</div></pre></td></tr></table></figure>
<p> isPrototypeOf回答的问题是：在a的整条<code>[[prototype]]</code>链中是否出现过<code>Foo.prototype</code>。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b.isPrototypeOf(c); // b是否出现在c的[[prototype]]链中</div></pre></td></tr></table></figure>
</li>
<li><p>getPrototypeOf</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.getPrototypeOf(a) === Foo.prototype; // true</div></pre></td></tr></table></figure>
<p> 通过getPrototypeOf可以直接获取一个对象的<code>Prototype</code>。</p>
</li>
<li><p><code>__proto__</code></p>
<p> 绝大多数（不是所有）浏览器也支持一种非标准的方法来访问内部<code>[[Prototype]]</code>属性：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.__proto__ === Foo.prototype; // true</div></pre></td></tr></table></figure>
<p> <code>__proto__</code>的实现大致是：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Object.defineProperty(Object.prototype, &quot;__proto__&quot;, &#123;</div><div class="line">get: function()&#123;</div><div class="line">  return Object.getPrototypeOf(this);</div><div class="line">&#125;,</div><div class="line">set: function(o)&#123;</div><div class="line">  Object.setPrototypeOf(this, o);</div><div class="line">  return o;</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p> 访问<code>a.__proto__</code>时，实际上是调用了getter函数。虽然getter函数存在于<code>Object.prototype</code>对象中，但是它的this指向对象a，所以和<code>Object.getPrototypeOf(a)</code>结果相同。</p>
</li>
</ol>
<h3 id="5-4-对象关联"><a href="#5-4-对象关联" class="headerlink" title="5.4 对象关联"></a>5.4 对象关联</h3><p><code>[[Prototype]]</code>这个连接的作用是：如果在对象上没有找到需要的属性或方法引用，引擎就会继续在<code>[[Prototype]]</code>关联的对象上进行查找。</p>
<p><code>Object.create()</code>会创建一个新对象，并把它关联到指定的对象，这样就可以充分发挥<code>[[Prototype]]</code>机制的威力（委托）并且避免不必要的麻烦（比如使用new的构造函数调用会生成<code>.prototype</code>和<code>.constructor</code>引用）。</p>
<p><code>Object.create(null)</code>会创建一个拥有空（null）<code>[[Prototype]]</code>链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以instanceof操作符无法进行判断，总是会返回false。</p>
<p><code>Object.create()</code>的polyfill（抹平差异化：代码判断当前浏览器有无这个功能，没有写一些支持代码）代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if(!Object.create)&#123;</div><div class="line">  Object.create = function(o)&#123;</div><div class="line">    function F()&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    return new F();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段polyfill代码使用了一个一次性函数F，通过改写它的prototype属性使其指向要关联的对象，然后再使用<code>new F()</code>来构造一个新对象进行关联。</p>
<h3 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h3><p>如果要访问对象中并不存在一个属性，<code>[[Get]]</code>操作就会查找对象内部<code>[[prototype]]</code>关联的对象。这个关联关系实际上定义了一条原型链（有点像嵌套作用域链），在查找属性时会对它进行遍历。</p>
<p>所有普通对象都有内置的<code>Object.prototype</code>，指向原型链的顶端（比如全局作用域），如果在原型链中找不到指定的属性就会停止。toString、valueOf和其他一些通用的功能都存在于<code>Object.prototype</code>对象上，因此所有对象都可以使用它们。</p>
<p>关联两个对象最常用的办法就是使用new关键词进行函数调用，在调用中会创建一个关联到其他对象的新对象。</p>
<p>使用new调用函数时会把新对象的prototype属性关联到其他对象，带new 的函数调用通常被称为构造函数调用，尽管它们实际上和传统的面向类语言中的类构造函数不一样。</p>
<p>虽然这些JS机制和传统面向类语言中的“类初始化”和“类继承 ”很相似，但是JS中的机制有一个核心区别，那就是不会复制，对象之间时通过内部的<code>[[prototype]]</code>链关联的。</p>
<p>对象之间的关系不是复制而是委托。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="external">附上这本书的英文Github版</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[You Don't Know JavaScript I —— Scope & Closures]]></title>
      <url>http://kad0108.github.io/2017/08/09/you-dont-know-js-I/</url>
      <content type="html"><![CDATA[<h2 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h2><p>这本书前后通读了两遍，是我看过的所有前端书籍📚中（虽然没全读完过几本，基本都是翻几页感觉内容没吸引到我就撇一边了。。。），内容质量最赞，最值得反复阅读体会的一本书，而且每次重读，会因为时间阅历不同都会有不同的体会和领悟，强烈推荐！！！</p>
<p>之后一定会不止两遍的重复阅读，而且还要读英文原著，先立Flag。</p>
<p>为什么会读了两遍？读第一次，哇，这内容讲的好深入，发现自己之前对JS的理解和应用都是浮于表面。后来因为找实习写论文一些事情，没有全看完。等到我再拾起来看之前看过的内容时，发现自己对看过的内容根本没吸收多少，所以就又重读了一遍。而且读第二遍的时候做了读书笔记，因为是图书馆借的书，没敢在书上乱画，所以写了markdown记录自己读时觉得值得重复研读的知识点。</p>
<h1 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h1><h2 id="第1章-作用域是什么"><a href="#第1章-作用域是什么" class="headerlink" title="第1章 作用域是什么"></a>第1章 作用域是什么</h2><h3 id="1-1-编译原理"><a href="#1-1-编译原理" class="headerlink" title="1.1 编译原理"></a>1.1 编译原理</h3><p>JS是一门编译语言，JS引擎进行编译过程。</p>
<a id="more"></a>
<p>编译三步骤：</p>
<ul>
<li>词法分析：比如<code>var a = 2;</code>会被分解成<code>var, a, blank,=, 2, ;</code>这些词法单元。</li>
<li>语法分析：将词法单元转换成抽象语法树AST。</li>
<li>代码生成：将AST转换为可执行代码，上例则将AST转换成一组机器指令，用来创建变量a（包括分配内存），并将一个值存储在a中。</li>
</ul>
<p>JS引擎的编译过程除以上三个步骤外，还有对运行性能的优化等。</p>
<h3 id="1-2-理解作用域"><a href="#1-2-理解作用域" class="headerlink" title="1.2 理解作用域"></a>1.2 理解作用域</h3><p><code>var a = 2;</code>的编译器处理过程：</p>
<ul>
<li>遇到<code>var a</code>，编译器询问作用域是否已经有一个该名称的变量存在于同一个作用域中。如果是，编译器会忽略该声明，继续编译；否则会要求作用域在当前作用域中声明一个新的变量，并命名为a。</li>
<li>接下来编译器会为引擎生成运行时所需的代码，这些代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问作用域，是否存在叫做a的变量，如果有则使用这个变量，如果没有引擎会继续查找该变量。</li>
</ul>
<p>编译时的<strong>LHS（赋值操作的目标是谁）</strong>和<strong>RHS（谁是赋值操作的源头）</strong>查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function foo(a)&#123;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line">foo(2);</div><div class="line">// 上述代码处理过程</div><div class="line">引擎：我需要为foo进行RHS引用</div><div class="line">作用域：编译器刚声明了foo函数</div><div class="line">引擎：我要执行foo，我需要对a进行LHS引用</div><div class="line">作用域：编译器把a声明为foo的一个形式参数了</div><div class="line">引擎：我要把2赋给a</div><div class="line">引擎：我需要为console进行RHS引用</div><div class="line">作用域：console是个内置对象，给你</div><div class="line">引擎：我看console中是不是有log方法，找到了是个函数</div><div class="line">引擎：帮我找一下对a的RHS引用</div><div class="line">作用域：变量a在这里</div><div class="line">引擎：我需要a的值</div></pre></td></tr></table></figure>
<h3 id="1-3-作用域嵌套"><a href="#1-3-作用域嵌套" class="headerlink" title="1.3 作用域嵌套"></a>1.3 作用域嵌套</h3><p>在当前作用域中无法找到某个变量时，引擎会在外层嵌套的作用域中继续查找，直到找到该变量或直到最外层作用域（全局作用域）。</p>
<h3 id="1-4-异常"><a href="#1-4-异常" class="headerlink" title="1.4 异常"></a>1.4 异常</h3><p>区分LHS和RHS：</p>
<ol>
<li><p>如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。</p>
</li>
<li><p>当引擎执行LHS查询时，如果在顶层全局作用域中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。前提是程序运行在非严格模式下。严格模式下LHS查询失败时，并不会创建并返回一个全局变量，引擎会抛出ReferenceError异常。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo(a)&#123;</div><div class="line">  console.log(a+b); // ReferenceError: b is not defined -&gt; RHS</div><div class="line">  b = a; // LHS</div><div class="line">&#125;</div><div class="line">foo(2);</div></pre></td></tr></table></figure>
<p>ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功但是对结果的操作是非法或不合理的。</p>
<h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。赋值操作会导致LHS查询。=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。</p>
<p>JS引擎首先会在代码执行前对其进行编译，在这个过程中，像<code>var a = 2</code>这样的声明会被分解成两个独立的步骤：</p>
<ol>
<li><p>首先，<code>var a</code>在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</p>
</li>
<li><p>接下来，<code>a = 2</code>会查询（LHS查询）变量a并对其进行赋值。</p>
</li>
</ol>
<p>LHS和RHS查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后抵达全局作用域，无论找到或没找到都将停止。</p>
<p>不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常（严格模式下）。</p>
<h2 id="第2章-词法作用域"><a href="#第2章-词法作用域" class="headerlink" title="第2章 词法作用域"></a>第2章 词法作用域</h2><p>作用域有两种工作模型：词法作用域、动态作用域。</p>
<h3 id="2-1-词法阶段"><a href="#2-1-词法阶段" class="headerlink" title="2.1 词法阶段"></a>2.1 词法阶段</h3><p>词法作用域是在写代码或者定义时确定的，而动态作用域是在运行时确定的。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用（this也是）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line">function bar()&#123;</div><div class="line">  var a = 3;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">bar();</div><div class="line">// 词法作用域 foo输出 2</div><div class="line">// 动态作用域 foo输出 3</div></pre></td></tr></table></figure>
<p><strong>遮蔽效应</strong>：多层嵌套的作用域中可以定义同名的标识符，内部的标识符会遮蔽外部的标识符。非全局变量被遮蔽无法访问到，全局变量被遮蔽可以通过对全局对象属性的引用<code>window.a</code>来进行访问。</p>
<p>词法作用域的查找只查找一级标识符，比如<code>obj.name</code>，会先查找obj标识符，找到这个变量后，再按照对象访问规则对属性进行访问。</p>
<h3 id="2-2-欺骗词法"><a href="#2-2-欺骗词法" class="headerlink" title="2.2 欺骗词法"></a>2.2 欺骗词法</h3><p>词法作用域完全由写代码时函数做声明的位置来定义，可以采用下面两种机制来实现修改词法作用域。<strong>欺骗词法作用域会导致性能下降。</strong></p>
<h4 id="2-2-1-eval"><a href="#2-2-1-eval" class="headerlink" title="2.2.1 eval"></a>2.2.1 eval</h4><p><code>eval(..)</code>接收一个字符串为参数，并执行其中的JS代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(str, a)&#123;</div><div class="line">  eval(str); // cheat!</div><div class="line">  console.log(a, b);</div><div class="line">&#125;</div><div class="line">var b = 2;</div><div class="line">foo(&quot;var b = 3;&quot;, 1); // 1, 3</div></pre></td></tr></table></figure>
<p>eval在函数foo的作用域内声明了一个新的变量b，对已存在的<code>foo(..)</code>词法作用域进行了修改，遮蔽了外部作用域中的同名变量。</p>
<p>严格模式下，eval在运行时有自己的词法作用域，也就无法修改所在的作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(str)&#123;</div><div class="line">  &quot;use strict&quot;;</div><div class="line">  eval(str);</div><div class="line">  console.log(a); // ReferenceError: a is not defined</div><div class="line">&#125;</div><div class="line">foo(&quot;var a = 2;&quot;);</div></pre></td></tr></table></figure>
<p>JS中还有一些方法和<code>eval(..)</code>有相似的功能：</p>
<ol>
<li><p>setTimeout、setInterval的第一个参数也可以是字符串，字符串可以被解释为动态生成的代码，已过时不提倡使用。</p>
</li>
<li><p><code>new Function()</code>最后一个参数也可以接受代码字符串，并将其转化为动态生成的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var add = new Function(&apos;a&apos;, &apos;b&apos;, &apos;return a + b;&apos;);</div><div class="line">add(2, 6);</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>面试题：当没有JSON对象时，怎么将一个JSON字符串<code>str = &quot;{&quot;a&quot;:1,&quot;b&quot;:&quot;kad&quot;}&quot;</code>转换成JS对象？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. eval(&apos;(&apos; + str + &apos;)&apos;);</div><div class="line">2. var fn = new Function(&quot;return &quot; +str);</div><div class="line">   fn();</div></pre></td></tr></table></figure>
<h4 id="2-2-2-with"><a href="#2-2-2-with" class="headerlink" title="2.2.2 with"></a>2.2.2 with</h4><p>with用于重复引用同一个对象的多个属性时的快捷方式，不需要重复引用对象本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo(obj)&#123;</div><div class="line">  with(obj)&#123;</div><div class="line">    a = 2;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var o1 = &#123;a: 3&#125;;</div><div class="line">var o2 = &#123;b: 3&#125;;</div><div class="line">foo(o1);</div><div class="line">console.log(o1.a); // 2</div><div class="line">foo(o2);</div><div class="line">console.log(o2.a); // undefind</div><div class="line">console.log(a); // 2 -&gt; 不好，a泄漏到全局作用域中了</div></pre></td></tr></table></figure>
<p>在with块内部，对变量a进行的是LHS引用，所以当传递o2给with时，with所声明的作用域是o2，o2的作用域、foo的作用域和全局作用域中都没有找到标识符a，则自动创建了全局变量a（因为是非严格模式）。</p>
<h4 id="2-2-3-性能"><a href="#2-2-3-性能" class="headerlink" title="2.2.3 性能"></a>2.2.3 性能</h4><p>eval和with会在运行是修改或创建新的作用域，以此来欺骗书写定义时的词法作用域。</p>
<p>JS引擎会在编译阶段进行性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但引擎如果在代码中发现了eval或with，无法在词法分析阶段明确知道eval会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给with用来创建新词法作用域的对象内容。这样所有的优化可能都是无意义的，也就完全不做任何优化。如果代码中大量使用eval或with，运行起来一定会非常慢。</p>
<h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</p>
<p>JS中有两个机制可以欺骗词法作用域：eval和with。前者可以对一段包含一个或多个声明的代码字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。</p>
<p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎智能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用。</p>
<h2 id="第3章-函数作用域和块作用域"><a href="#第3章-函数作用域和块作用域" class="headerlink" title="第3章 函数作用域和块作用域"></a>第3章 函数作用域和块作用域</h2><h3 id="3-1-函数中的作用域"><a href="#3-1-函数中的作用域" class="headerlink" title="3.1 函数中的作用域"></a>3.1 函数中的作用域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  function bar()&#123;</div><div class="line">    // ...</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">bar(); // error</div></pre></td></tr></table></figure>
<p>bar是属于foo的作用域，从foo外部无法对其进行访问。</p>
<h3 id="3-2-隐藏内部实现"><a href="#3-2-隐藏内部实现" class="headerlink" title="3.2 隐藏内部实现"></a>3.2 隐藏内部实现</h3><p><strong>最小授权或最小暴露原则</strong> ：应该最小限度地暴露必要内容，而将其他内容都隐藏起来，比如某个模块或对象的API设计。</p>
<p>变量冲突的一个典型例子存在与全局作用域中。当程序中加载了多个第三方库时，如果他们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。</p>
<h3 id="3-3-函数作用域"><a href="#3-3-函数作用域" class="headerlink" title="3.3 函数作用域"></a>3.3 函数作用域</h3><p>具名函数的名称本身就会污染所在作用域，而且必须显式地调用才能运行。如何能够不需要函数名，并且自动运行？</p>
<p>JS中提供了立即执行函数表达式来解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(function foo()&#123;</div><div class="line">	var a = 3;</div><div class="line">	console.log(a); // 3</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>区分函数声明和表达式：看function关键字出现在声明中的位置，如果是声明中的第一个词就是函数声明，否则就是函数表达式。<code>(function foo(){..})</code>作为函数表达式意味着foo只能在<code>..</code>所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中以为这不会非必要的污染外部作用域。</p>
<h4 id="3-3-1-匿名和具名"><a href="#3-3-1-匿名和具名" class="headerlink" title="3.3.1 匿名和具名"></a>3.3.1 匿名和具名</h4><p>函数表达式可以是匿名的，而函数声明则不可以省略函数名。所以下方是匿名函数表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout(function()&#123;</div><div class="line">  // ...</div><div class="line">&#125;, 0);</div></pre></td></tr></table></figure>
<p>如果没有函数名，当函数需要应用自身时只能使用<code>arguments.callee</code>引用（指向正在执行的函数的指针），比如递归。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</p>
<h4 id="3-3-2-立即执行函数表达式"><a href="#3-3-2-立即执行函数表达式" class="headerlink" title="3.3.2 立即执行函数表达式"></a>3.3.2 立即执行函数表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(function()&#123;..&#125;)();</div></pre></td></tr></table></figure>
<p><strong>IIFE(Immediately Invoked Function Expression)</strong> ：函数被包含在第一个括号内，成为了一个表达式，末尾再加上一个括号可以理解执行这个函数。</p>
<p>IIFE的几种写法：</p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(function()&#123;..&#125;())</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 当作函数调用并传递参数进去</div><div class="line">(function(global)&#123;..&#125;)(window);</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 解决undefined标识符的默认值被错误覆盖导致的异常</div><div class="line">undefined = true; // warn</div><div class="line">(function(undefined)&#123;</div><div class="line">  var a;</div><div class="line">  if(a === undefined)&#123;</div><div class="line">    console.log(&quot;undefined is safe here&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 倒置代码的运行顺序，将需要运行的函数在IIFE执行之后当作参数传递进去</div><div class="line">var a = 2;</div><div class="line">(function(def)&#123;</div><div class="line">  def(window);</div><div class="line">&#125;)(function(global)&#123;</div><div class="line">  var a = 3;</div><div class="line">  console.log(a); // 3</div><div class="line">  console.log(global.a); // 2</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// jQuery源码整体架构就是采用了IIFE的第4中写法，将需要运行的函数当作参数传递</div><div class="line">;(function(global, factory) &#123;</div><div class="line">    factory(global);</div><div class="line">&#125;(typeof window !== &quot;undefined&quot; ? window : this, function(window, noGlobal) &#123;</div><div class="line">    var jQuery = function( selector, context ) &#123;</div><div class="line">		return new jQuery.fn.init( selector, context );</div><div class="line">	&#125;;</div><div class="line">	jQuery.fn = jQuery.prototype = &#123;&#125;;</div><div class="line">	// 核心方法</div><div class="line">	// 回调系统</div><div class="line">	// 异步队列</div><div class="line">	// 数据缓存</div><div class="line">	// 队列操作</div><div class="line">	// 选择器引</div><div class="line">	// 属性操作</div><div class="line">	// 节点遍历</div><div class="line">	// 文档处理</div><div class="line">	// 样式操作</div><div class="line">	// 属性操作</div><div class="line">	// 事件体系</div><div class="line">	// AJAX交互</div><div class="line">	// 动画引擎</div><div class="line">	return jQuery;</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-4-块作用域"><a href="#3-4-块作用域" class="headerlink" title="3.4 块作用域"></a>3.4 块作用域</h3><p>块作用域也应遵循最小授权原则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 比如变量i只在for循环内部使用，但却会污染到外部作用域中</div><div class="line">for(var i = 0; i &lt; 10; i++)&#123;</div><div class="line">  console.log(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JS中块作用域的相关功能：</p>
<h4 id="3-4-1-with"><a href="#3-4-1-with" class="headerlink" title="3.4.1 with"></a>3.4.1 with</h4><p>with也是块作用域，用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效。</p>
<h4 id="3-4-2-try-catch"><a href="#3-4-2-try-catch" class="headerlink" title="3.4.2 try/catch"></a>3.4.2 try/catch</h4><p><code>try/catch</code>的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try&#123;</div><div class="line">    throw &quot;TestError&quot;; // 抛出一个异常</div><div class="line">&#125;catch(err)&#123;</div><div class="line">    console.log(err); // TestError</div><div class="line">&#125;</div><div class="line">console.log(err); // ReferenceError: err is not defined</div></pre></td></tr></table></figure>
<p><code>try/catch</code>中的this、return、break、continue的含义不会发生变化，IIFE则会改变代码的含义。</p>
<h4 id="3-4-3-let"><a href="#3-4-3-let" class="headerlink" title="3.4.3 let"></a>3.4.3 let</h4><p>let关键字声明的变量以大括号<code>{..}</code>为块作用域，而且使用let进行的声明不会在块作用域中进行提升。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  console.log(a); // ReferenceError</div><div class="line">  var a = 2;</div><div class="line">  console.log(a); // 2</div><div class="line">&#125;</div><div class="line">console.log(a); // ReferenceError</div></pre></td></tr></table></figure>
<ol>
<li><p><strong>垃圾收集:</strong> 块作用域非常有用的原因和闭包及回收内存垃圾的回收机制有关。闭包覆盖的作用域中所有的结构都不会被引擎回收，块作用域可以让引擎清楚的知道没有必要再保留哪些结构。</p>
</li>
<li><p><strong>let循环:</strong> for循环头部的let将i绑定到了for循环的块中，而且是绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(let i = 0; i &lt; 10; i++)&#123;</div><div class="line">  console.log(i);</div><div class="line">&#125;</div><div class="line">console.log(i); // ReferenceError</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-4-4-const"><a href="#3-4-4-const" class="headerlink" title="3.4.4 const"></a>3.4.4 const</h4><p>const可以用来创建块作用域变量，原文中说任何试图修改值的操作都会引起错误TypeError，个人感觉这里不严谨，const定义的引用类型的变量时可以修改的，只是不能修改变量类型。</p>
<h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p>函数是JS中最常见的作用域单元，声明在一个函数内部的变量或函数会在所处的作用域中隐藏起来，这是良好软件的设计原则。但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指<code>{..}</code>内部）。</p>
<p>从ES3开始，<code>try/catch</code>结构在catch分句中具有块作用域。</p>
<p>在ES6中引入了let关键字，用来在任意代码块中声明变量。<code>if(){let a = 2;}</code>会声明了一个劫持了if的<code>{..}</code>块的变量，并且将变量添加到这个块中。</p>
<h2 id="第4章-提升"><a href="#第4章-提升" class="headerlink" title="第4章 提升"></a>第4章 提升</h2><h3 id="4-1-先有鸡还是先有蛋"><a href="#4-1-先有鸡还是先有蛋" class="headerlink" title="4.1 先有鸡还是先有蛋"></a>4.1 先有鸡还是先有蛋</h3><p>直觉上认为JS是从上到下一行一行执行的，考虑一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = 2;</div><div class="line">var a;</div><div class="line">console.log(a); // 2</div></pre></td></tr></table></figure>
<p>声明在前还是赋值在前？</p>
<h3 id="4-2-编译器再度来袭"><a href="#4-2-编译器再度来袭" class="headerlink" title="4.2 编译器再度来袭"></a>4.2 编译器再度来袭</h3><p>正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。</p>
<p><code>var a = 2;</code>在JS看来是两部分<code>var a;</code>和<code>a = 2;</code>，第一个定义声明是在编译阶段进行的，第一个赋值声明会被留在原地等待执行阶段。也就是<strong>先有声明后有赋值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo(); // TypeError</div><div class="line">bar(); // ReferenceError</div><div class="line">var foo = function bar()&#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数表达式不会被提升，变量标识符foo被提升，所以调用<code>foo()</code>不会导致ReferenceError，但是没有赋值所以抛出TypeError。</p>
<p>具名函数表达式的作用：目前了解到的是函数表达式中的函数名只能用在函数内部，外部无法引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var foo = function bar()&#123;</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line">foo(); // 正常运行</div><div class="line">bar(); // ReferenceError: bar is not defined</div></pre></td></tr></table></figure>
<h3 id="4-3-函数优先"><a href="#4-3-函数优先" class="headerlink" title="4.3 函数优先"></a>4.3 函数优先</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">foo(); // 1</div><div class="line">var foo;</div><div class="line">function foo()&#123;</div><div class="line">    console.log(1);</div><div class="line">&#125;</div><div class="line">foo = function()&#123;</div><div class="line">    console.log(2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管<code>var foo</code>出现在<code>function foo()...</code>的声明之前，但它是重复的声明因此被忽略了，<strong>函数声明会被提升到普通变量之前</strong>。</p>
<h3 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h3><p>我们习惯将<code>var a = 2;</code>看作一个声明，而JS引擎将<code>var a</code>和<code>a = 2</code>当作两个单独的声明，第一个是编译阶段的任务，第二个是执行阶段的任务。</p>
<p>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理，可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。</p>
<p>声明本身被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。</p>
<p>要注意避免重复声明，特别是当普通的声明和函数声明混合在一起的时候。</p>
<h2 id="第5章-作用域闭包"><a href="#第5章-作用域闭包" class="headerlink" title="第5章 作用域闭包"></a>第5章 作用域闭包</h2><h3 id="5-1-启示"><a href="#5-1-启示" class="headerlink" title="5.1 启示"></a>5.1 启示</h3><p>JS中闭包无处不在，你只需要能够识别并拥抱它。</p>
<h3 id="5-2-实质问题"><a href="#5-2-实质问题" class="headerlink" title="5.2 实质问题"></a>5.2 实质问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  var a = 2;</div><div class="line">  function bar()&#123; // 函数bar的词法作用域能够访问foo()的作用域</div><div class="line">    console.log(a);</div><div class="line">  &#125;</div><div class="line">  return bar;</div><div class="line">&#125;</div><div class="line">// 实际是通过不同的标识符引用调用了内部的函数bar</div><div class="line">baz(); // 2</div></pre></td></tr></table></figure>
<p>在foo()执行后，通常会期待函数foo的整个内部作用域都被销毁，而闭包的神器之处就是阻止这件事的发生。变量baz也就是bar声明的位置，是拥有涵盖foo内部作用域的闭包，使得该作用域能够一直存活，以供bar在之后任何时间进行引用。</p>
<h3 id="5-3-现在我懂了"><a href="#5-3-现在我懂了" class="headerlink" title="5.3 现在我懂了"></a>5.3 现在我懂了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function wait(msg)&#123;</div><div class="line">  setTimeout(function timer()&#123;</div><div class="line">    console.log(msg);</div><div class="line">  &#125;, 1000);</div><div class="line">&#125;</div><div class="line">wait(&quot;hello, closure!&quot;);</div></pre></td></tr></table></figure>
<p>内部函数timer涵盖了<code>wait(..)</code>的作用域，保有对变量msg的引用。wait在执行1000ms之后，内部作用域不会消失，timer函数依然保有对wait作用域的引用。这就是闭包。</p>
<p>在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步或同步任务中，只要使用了回调函数，实际上就是在使用闭包。</p>
<p><strong>函数在定义时的词法作用域以外的地方被调用，闭包使得函数可以继续访问定义使的词法作用域。</strong></p>
<h3 id="5-4-循环和闭包"><a href="#5-4-循环和闭包" class="headerlink" title="5.4 循环和闭包"></a>5.4 循环和闭包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(var i = 1; i &lt;= 5; i++)&#123;</div><div class="line">  setTimeout(function timer()&#123;</div><div class="line">    console.log(i);</div><div class="line">  &#125;, i * 1000);</div><div class="line">&#125;</div><div class="line">// 以每秒一次的频率输出五次6</div><div class="line">// 循环的终止条件是i=6，所有函数共享一个i的引用，</div></pre></td></tr></table></figure>
<p>解决方法：把每次循环的i都封闭在一个作用域中，通过IIFE被每个迭代生成一个新的作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(var i = 1; i &lt;= 5; i++)&#123;</div><div class="line">  (function(i)&#123;</div><div class="line">    setTimeout(function timer()&#123;</div><div class="line">      console.log(i);</div><div class="line">    &#125;, i*1000);</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>重返块作用域</strong></p>
<p>每次迭代需要一个块作用域，可以使用第3章中介绍的。比如使用let声明，特殊之处在于，变量在循环过程中不止被声明一次，每次迭代都会声明，随后都会使用上一个迭代结束时的值来初始化这个变量。</p>
<h3 id="5-5-模块"><a href="#5-5-模块" class="headerlink" title="5.5 模块"></a>5.5 模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function CoolModule()&#123;</div><div class="line">  var something = &quot;cool&quot;;</div><div class="line">  var another = [1,2,3];</div><div class="line">  function doSomething()&#123;</div><div class="line">    console.log(something);</div><div class="line">  &#125;</div><div class="line">  function doAnother()&#123;</div><div class="line">    console.log(another.join(&apos;!&apos;));</div><div class="line">  &#125;</div><div class="line">  return &#123;</div><div class="line">    doSomething: doSomething,</div><div class="line">    doAnother: doAnother</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">var foo = CoolModule();</div><div class="line">foo.doSomething(); // cool</div><div class="line">foo.doAnother(); // 1!2!3</div></pre></td></tr></table></figure>
<p>必须通过调用CoolModule创建一个模块实例，如果不执行外部函数，内部作用域和闭包都无法被创建。</p>
<p>改为单例模式，替代调用CoolModule()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var foo = (function()&#123;</div><div class="line">  // ...</div><div class="line">  return &#123;</div><div class="line">    doSomething: doSomething,</div><div class="line">    doAnother: doAnother</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h4 id="5-5-1-现代的模块机制"><a href="#5-5-1-现代的模块机制" class="headerlink" title="5.5.1 现代的模块机制"></a>5.5.1 现代的模块机制</h4><h4 id="5-5-2-未来的模块机制"><a href="#5-5-2-未来的模块机制" class="headerlink" title="5.5.2 未来的模块机制"></a>5.5.2 未来的模块机制</h4><p>ES6中的模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//bar.js</div><div class="line">function hello()&#123;</div><div class="line">  return &quot;bar&quot;;</div><div class="line">&#125;</div><div class="line">export hello;</div><div class="line"></div><div class="line">// foo.js</div><div class="line">// 仅从bar模块导入hello</div><div class="line">import hello from &quot;bar&quot;</div><div class="line">function awesome()&#123;</div><div class="line">  console.log(hello());</div><div class="line">&#125;</div><div class="line">export awesome;</div><div class="line"></div><div class="line">// baz.js</div><div class="line">// 导入完整的foo和bar模块</div><div class="line">module foo from &quot;foo&quot;;</div><div class="line">module bar from &quot;bar&quot;;</div><div class="line">console.log(bar.hello());</div><div class="line">foo.awesome();</div></pre></td></tr></table></figure>
<p>模块文件中的内功会被当作好像包含在作用域闭包中一样来处理。</p>
<h3 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h3><p>闭包就好像从JS中分离出来的一个充满神秘色彩的未开化世界，只有最勇敢的人才能够到那里。但实际上它只是一个标准，显然就是关于如何在函数作为值按需传递的词法环境中书写代码的。</p>
<p>当函数可以记住并访问所在的词法作用域，即时函数是在当前词法作用域之外执行，这时就产生了闭包。</p>
<p>如果没能认出闭包，也不了解它的工作原理，在使用它的过程中就很容易犯错，比如在循环中。但同时闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。</p>
<p>模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Virtual DOM]]></title>
      <url>http://kad0108.github.io/2017/07/23/virtual-dom/</url>
      <content type="html"><![CDATA[<p>DOM操作是JS最基础的部分，前段时间重构的一个项目中使用JQuery来操作大量的DOM节点，就算是操作相同的节点也直接使用<code>$</code>去直接获取元素，JQuery是可以很方便的操作DOM，但是其底层封装的实现也依然是原生JS中提供的获取元素的API。现在项目里用到的knockoutJS，算是MVVM的鼻祖，虽说实现了数据绑定渲染，但其底层没有用到虚拟DOM，也就还是应该用了原生JS获取DOM元素的API。</p>
<h2 id="前端应用状态管理"><a href="#前端应用状态管理" class="headerlink" title="前端应用状态管理"></a>前端应用状态管理</h2><p>记得最开始做IFE的任务中有个题目是让实现一个排序表格，附上当时写的<a href="https://github.com/BaiduGo3/task03/blob/gh-pages/task03_038/kad/kad.js" target="_blank" rel="external">代码</a>，每次点击排序按钮，都要重新渲染整个table中的元素。DOM操作有多耗性能？看下图：</p>
<a id="more"></a>
<p><img src="/2017/07/23/virtual-dom/dom.png" alt="dom"></p>
<p>可以看到div元素的属性的庞大，所以每次的dom操作都会触发repaint、reflow，性能可想而知。</p>
<p>其实上面的问题就是状态改变时需要更新相应的dom元素，那么是不是可以实现让视图和状态进行绑定，状态变更视图自动变更，这也就是MVVM模式数据双向绑定。Virtual DOM解决的就是<strong>维护状态，更新视图</strong>。</p>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>用原生JS对象可以很容易表示DOM节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var ele = &#123;</div><div class="line">	tagName: &apos;ul&apos;, // 节点名</div><div class="line">	props: &#123; //  dom属性</div><div class="line">		id: &apos;list&apos;</div><div class="line">	&#125;,</div><div class="line">	childs: [ // 子节点</div><div class="line">		&#123;tagName: &apos;li&apos;, props: &#123;class: &apos;item&apos;&#125;, childs: [&quot;Item1&quot;]&#125;,</div><div class="line">		&#123;tagName: &apos;li&apos;, props: &#123;class: &apos;item&apos;&#125;, childs: [&quot;Item2&quot;]&#125;,</div><div class="line">		&#123;tagName: &apos;li&apos;, props: &#123;class: &apos;item&apos;&#125;, childs: [&quot;Item3&quot;]&#125;,</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用上面的JS对象可以表示如下的DOM结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul id=&apos;list&apos;&gt;</div><div class="line">  &lt;li class=&apos;item&apos;&gt;Item 1&lt;/li&gt;</div><div class="line">  &lt;li class=&apos;item&apos;&gt;Item 2&lt;/li&gt;</div><div class="line">  &lt;li class=&apos;item&apos;&gt;Item 3&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p>那么状态变更-&gt;渲染视图就可以通过这种方式来实现：用JS对象表示DOM信息结构，当状态变更时，重新渲染整个JS对象结构，然后用新渲染的对象树和旧的树进行对比，纪录两棵树的差异，然后将差异应用到真正的DOM树上。</p>
<p>这就是Virtual DOM的整体思想：</p>
<ol>
<li><p>用JS对象模拟DOM树</p>
</li>
<li><p>比较两棵虚拟DOM树的差异</p>
</li>
<li><p>把差异应用到真正的DOM树上</p>
</li>
</ol>
<h3 id="步骤一：用JS对象模拟DOM树"><a href="#步骤一：用JS对象模拟DOM树" class="headerlink" title="步骤一：用JS对象模拟DOM树"></a>步骤一：用JS对象模拟DOM树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Element(tagName, props, childs) &#123;</div><div class="line">	this.tagName = tagName;</div><div class="line">	this.props = props;</div><div class="line">	this.childs = childs;</div><div class="line">&#125;</div><div class="line">module.exports = function (tagName, props, children) &#123;</div><div class="line">	return new Element(tagName, props, children)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的DOM结构就可以表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var ele = require(&apos;./element&apos;)</div><div class="line"></div><div class="line">var ul = el(&apos;ul&apos;, &#123;id: &apos;list&apos;&#125;, [</div><div class="line">	ele(&apos;li&apos;, &#123;class: &apos;item&apos;&#125;, [&apos;Item 1&apos;]),</div><div class="line">	ele(&apos;li&apos;, &#123;class: &apos;item&apos;&#125;, [&apos;Item 2&apos;]),</div><div class="line">	ele(&apos;li&apos;, &#123;class: &apos;item&apos;&#125;, [&apos;Item 3&apos;])</div><div class="line">])</div></pre></td></tr></table></figure>
<p>需要根据JS对象ul构件真正的<code>&lt;ul&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Element.prototype.render = function()&#123;</div><div class="line">	var ele = document.createElement(this.tagName);</div><div class="line">	var props = this.props</div><div class="line"></div><div class="line">	for (var propName in props) &#123; </div><div class="line">		var propValue = props[propName]</div><div class="line">		ele.setAttribute(propName, propValue)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var childs = this.childs || [];</div><div class="line">	childs.forEach(function(child)&#123;</div><div class="line">		var childEle = (child instanceof Element)</div><div class="line">	      ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点</div><div class="line">	      : document.createTextNode(child); // 如果字符串，只构建文本节点</div><div class="line">	    ele.appendChild(childEle);</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">	return ele;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>render方法会根据tagName构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var ulRoot = ul.render()</div><div class="line">document.body.appendChild(ulRoot)</div></pre></td></tr></table></figure>
<h3 id="步骤二：比较两棵虚拟DOM树的差异"><a href="#步骤二：比较两棵虚拟DOM树的差异" class="headerlink" title="步骤二：比较两棵虚拟DOM树的差异"></a>步骤二：比较两棵虚拟DOM树的差异</h3><p>比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也就是 Virtual DOM 的 diff 算法。在前端当中，很少会跨越层级地移动DOM元素。<strong>所以 Virtual DOM 只会对同一个层级的元素进行对比，这样算法复杂度就可以达到 O(n)。</strong></p>
<p>对新旧两棵树进行深度优先遍历，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// diff 函数，对比两棵树</div><div class="line">function diff (oldTree, newTree) &#123;</div><div class="line">	var index = 0; // 当前节点的标志</div><div class="line">	var patches = &#123;&#125;; // 用来记录每个节点差异的对象</div><div class="line">	dfsWalk(oldTree, newTree, index, patches);</div><div class="line">	return patches;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 对两棵树进行深度优先遍历</div><div class="line">function dfsWalk (oldNode, newNode, index, patches) &#123;</div><div class="line">	// 对比oldNode和newNode的不同，记录下来</div><div class="line">	patches[index] = [...];</div><div class="line"></div><div class="line">	diffChilds(oldNode.childs, newNode.childs, index, patches);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 遍历子节点</div><div class="line">function diffChilds (oldChilds, newChilds, index, patches) &#123;</div><div class="line">	var leftNode = null;</div><div class="line">	var currentNodeIndex = index;</div><div class="line">	oldChilds.forEach(function (child, i) &#123;</div><div class="line">		var newChild = newChilds[i];</div><div class="line">		currentNodeIndex = (leftNode &amp;&amp; leftNode.count) // 计算节点的标识</div><div class="line">			  ? currentNodeIndex + leftNode.count + 1</div><div class="line">			  : currentNodeIndex + 1;</div><div class="line">		dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点</div><div class="line">		leftNode = child</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的ul和新的ul有差异，当前的标记是0，那么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...] // 用数组存储新旧节点的不同</div></pre></td></tr></table></figure>
<p>同理li1是patches[1]，li1的文本节点是patches[2]类推。</p>
<h4 id="差异类型"><a href="#差异类型" class="headerlink" title="差异类型"></a>差异类型</h4><p>对 DOM 操作可能会：</p>
<ol>
<li>替换掉原来的节点</li>
<li>移动、删除、新增子节点</li>
<li>修改了节点的属性</li>
<li>对于文本节点，文本内容可能会改变</li>
</ol>
<p>定义节点差异为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var REPLACE = 0</div><div class="line">var REORDER = 1</div><div class="line">var PROPS = 2</div><div class="line">var TEXT = 3</div></pre></td></tr></table></figure>
<p>对于节点替换，很简单。判断新旧节点的tagName和是不是一样的，如果不一样的说明需要替换掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">patches[0] = [&#123;</div><div class="line">  type: REPALCE,</div><div class="line">  node: newNode // el(&apos;section&apos;, props, children)</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>如果给div新增了属性id为container:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">patches[0] = [&#123;</div><div class="line">  type: REPALCE,</div><div class="line">  node: newNode // el(&apos;section&apos;, props, children)</div><div class="line">&#125;, &#123;</div><div class="line">  type: PROPS,</div><div class="line">  props: &#123;</div><div class="line">    id: &quot;container&quot;</div><div class="line">  &#125;</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>如果是文本节点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">patches[2] = [&#123;</div><div class="line">  type: TEXT,</div><div class="line">  content: &quot;Virtual DOM2&quot;</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>如果是节点重新排序呢？<code>div ul p</code>的顺序换成了<code>ul div p</code>，应该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如ul和div的tagName不同，div会被ul所替代。最终，三个节点都会被替换，这样DOM开销就非常大。</p>
<p><strong>React给子节点加上唯一标识key，对比的时候，使用key进行对比，这样就能复用老的 DOM 树上的节点。</strong></p>
<h3 id="步骤三：把差异应用到真正的DOM树上"><a href="#步骤三：把差异应用到真正的DOM树上" class="headerlink" title="步骤三：把差异应用到真正的DOM树上"></a>步骤三：把差异应用到真正的DOM树上</h3><p>对新DOM树进行深度优先的遍历，遍历的时候从步骤二生成的patches对象中找出当前遍历的节点差异，然后进行 DOM 操作.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function patch (node, patches) &#123;</div><div class="line">  var walker = &#123;index: 0&#125;</div><div class="line">  dfs(node, walker, patches)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function dfs (node, walker, patches) &#123;</div><div class="line">  var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异</div><div class="line"></div><div class="line">  var len = node.childNodes</div><div class="line">    ? node.childNodes.length</div><div class="line">    : 0</div><div class="line">  for (var i = 0; i &lt; len; i++) &#123; // 深度遍历子节点</div><div class="line">    var child = node.childNodes[i]</div><div class="line">    walker.index++</div><div class="line">    dfs(child, walker, patches)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (currentPatches) &#123;</div><div class="line">    applyPatches(node, currentPatches) // 根据不同类型的差异对当前节点进行 DOM 操作</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Virtual DOM 算法主要是实现上面步骤：<code>element，diff，patch</code>。然后就可以实际的进行使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 1. 构建虚拟DOM</div><div class="line">var tree = el(&apos;div&apos;, &#123;&apos;id&apos;: &apos;container&apos;&#125;, [</div><div class="line">    el(&apos;h1&apos;, &#123;style: &apos;color: blue&apos;&#125;, [&apos;simple virtal dom&apos;]),</div><div class="line">    el(&apos;p&apos;, [&apos;Hello, virtual-dom&apos;]),</div><div class="line">    el(&apos;ul&apos;, [el(&apos;li&apos;)])</div><div class="line">])</div><div class="line">// 2. 通过虚拟DOM构建真正的DOM</div><div class="line">var root = tree.render()</div><div class="line">document.body.appendChild(root)</div><div class="line">// 3. 生成新的虚拟DOM</div><div class="line">var newTree = el(&apos;div&apos;, &#123;&apos;id&apos;: &apos;container&apos;&#125;, [</div><div class="line">    el(&apos;h1&apos;, &#123;style: &apos;color: red&apos;&#125;, [&apos;simple virtal dom&apos;]),</div><div class="line">    el(&apos;p&apos;, [&apos;Hello, virtual-dom&apos;]),</div><div class="line">    el(&apos;ul&apos;, [el(&apos;li&apos;), el(&apos;li&apos;)])</div><div class="line">])</div><div class="line">// 4. 比较两棵虚拟DOM树的不同</div><div class="line">var patches = diff(tree, newTree)</div><div class="line">// 5. 在真正的DOM元素上应用变更</div><div class="line">patch(root, patches)</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="external">深度剖析：如何实现一个 Virtual DOM 算法</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/20346379?columnSlug=purerender" target="_blank" rel="external">React 源码剖析系列 － 不可思议的 react diff</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RegExp]]></title>
      <url>http://kad0108.github.io/2017/07/17/regexp/</url>
      <content type="html"><![CDATA[<p>最近遇到几个很类似的题目，都用到正则做字符串操作，就想总结一下。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="正则创建方式"><a href="#正则创建方式" class="headerlink" title="正则创建方式"></a>正则创建方式</h3><ol>
<li><p><code>var reg = new RegExp(/are/, &#39;g&#39;);</code></p>
</li>
<li><p><code>var reg = /are/i;</code></p>
</li>
</ol>
<p>注意使用构造函数时字符的转义规则。</p>
<h3 id="正则模式匹配符"><a href="#正则模式匹配符" class="headerlink" title="正则模式匹配符"></a>正则模式匹配符</h3><p><code>\g</code>：在字符串中查找所有可能的匹配，返回结果是多个</p>
<p><code>\i</code>：匹配时不区分大小写</p>
<p><code>\m</code>：多行匹配</p>
<a id="more"></a>
<h3 id="正则匹配查询："><a href="#正则匹配查询：" class="headerlink" title="正则匹配查询："></a>正则匹配查询：</h3><ol>
<li><p><code>str.search(reg)</code>返回值为str中第一个与reg匹配的位置，不匹配返回-1</p>
</li>
<li><p><code>str.match(reg)</code>返回匹配数组，依赖全局标志g</p>
</li>
<li><p><code>reg.exec(str)</code>返回一个数组，数组里存储的是第一个匹配项的相关信息</p>
</li>
<li><p><code>reg.test(str)</code>返回值Boolean</p>
</li>
</ol>
<h3 id="正则常用语法"><a href="#正则常用语法" class="headerlink" title="正则常用语法"></a>正则常用语法</h3><h4 id="特殊代码"><a href="#特殊代码" class="headerlink" title="特殊代码"></a>特殊代码</h4><table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
</tr>
</tbody>
</table>
<h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody>
</table>
<h4 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h4><table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\W</td>
<td>匹配任意不是字母和数字的字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td>[^x]</td>
<td>匹配除了x以外的任意字符</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody>
</table>
<h2 id="Regex-Golf"><a href="#Regex-Golf" class="headerlink" title="Regex Golf"></a>Regex Golf</h2><h3 id="Warmup"><a href="#Warmup" class="headerlink" title="Warmup"></a>Warmup</h3><p><img src="/2017/07/17/regexp/regexp.png" alt=""></p>
<h3 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h3><p>可以发现需要match的字符串都以ick为结尾</p>
<p><img src="/2017/07/17/regexp/regexp1.png" alt=""></p>
<h3 id="It-never-ends"><a href="#It-never-ends" class="headerlink" title="It never ends"></a>It never ends</h3><p>不允许通过<code>$</code>匹配字符串结尾，可以用<code>\b</code>来匹配单词的开头和结尾</p>
<p><img src="/2017/07/17/regexp/regexp2.png" alt=""></p>
<h3 id="Ranges"><a href="#Ranges" class="headerlink" title="Ranges"></a>Ranges</h3><p>考察字母的范围以及字符串的边界</p>
<p><img src="/2017/07/17/regexp/regexp3.png" alt=""></p>
<h3 id="Backrefs"><a href="#Backrefs" class="headerlink" title="Backrefs"></a>Backrefs</h3><p>考察反向引用，可以发现，开头出现的三个字母之后还会出现，后向引用用于重复搜索前面某个分组匹配的文本。例如，<code>\1</code>代表分组1匹配的文本。</p>
<p><img src="/2017/07/17/regexp/regexp4.png" alt=""></p>
<h3 id="Abba"><a href="#Abba" class="headerlink" title="Abba"></a>Abba</h3><p>可以发现要求不要match类似abba这样的字符串，先构造abba，还是用到后向引用<code>(\w)(\w)\2\1</code>，不匹配就用到零宽断言<code>(?!exp)</code>，匹配后面不是exp的串。然而<code>(?!(\w)(\w)\2\1)</code>只匹配了左边的，右边的也匹配上了。。。不应该match的串是<code>xxxabbaxxx</code>这样子的，那么应该就是<code>^(?!.*(\w)(\w)\2\1)</code>。</p>
<p><img src="/2017/07/17/regexp/regexp5.png" alt=""></p>
<h3 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h3><h2 id="有关正则的题目"><a href="#有关正则的题目" class="headerlink" title="有关正则的题目"></a>有关正则的题目</h2><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><p>前不久同学问了一个问题，<strong>将一个字符串中所有中文符号转为对应的英文符号。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var str = &quot;（孔）。，）&quot;;</div><div class="line">console.log(str);</div><div class="line">var obj = &#123;</div><div class="line">	&apos;（&apos;: &apos;(&apos;,</div><div class="line">	&apos;）&apos;: &apos;)&apos;,</div><div class="line">	&apos;，&apos;: &apos;,&apos;,</div><div class="line">	&apos;。&apos;: &apos;.&apos;</div><div class="line">&#125;;</div><div class="line">for(var key in obj)&#123;</div><div class="line">	if(str.indexOf(key) != -1)&#123;</div><div class="line">		str = str.replace(new RegExp(&apos;\\&apos; + key, &apos;g&apos;), obj[key]);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">console.log(str);</div></pre></td></tr></table></figure>
<h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><p><strong>按所给的时间格式输出指定的时间。</strong></p>
<p>格式说明:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">对于 2014.09.05 13:14:20</div><div class="line">yyyy: 年份，2014</div><div class="line">yy: 年份，14</div><div class="line">MM: 月份，补满两位，09</div><div class="line">M: 月份, 9</div><div class="line">dd: 日期，补满两位，05</div><div class="line">d: 日期, 5</div><div class="line">HH: 24制小时，补满两位，13</div><div class="line">H: 24制小时，13</div><div class="line">hh: 12制小时，补满两位，01</div><div class="line">h: 12制小时，1</div><div class="line">mm: 分钟，补满两位，14</div><div class="line">m: 分钟，14</div><div class="line">ss: 秒，补满两位，20</div><div class="line">s: 秒，20</div><div class="line">w: 星期，为 [&apos;日&apos;, &apos;一&apos;, &apos;二&apos;, &apos;三&apos;, &apos;四&apos;, &apos;五&apos;, &apos;六&apos;] 中的某一个，本 demo 结果为 五</div></pre></td></tr></table></figure></p>
<p>输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new Date(1409894060000), &apos;yyyy-MM-dd HH:mm:ss 星期w&apos;</div></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2014-09-05 13:14:20 星期五</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function formatDate(d, sFormation) &#123;</div><div class="line">    var obj = &#123;</div><div class="line">        yyyy: d.getFullYear(),</div><div class="line">        yy: d.getFullYear().toString().slice(-2),</div><div class="line">        MM: (&apos;0&apos; + (d.getMonth()+1)).slice(-2),</div><div class="line">        M: d.getMonth()+1,</div><div class="line">        dd: (&apos;0&apos; + d.getDate()).slice(-2),</div><div class="line">        d: d.getDate(),</div><div class="line">        HH: (&apos;0&apos; + d.getHours()).slice(-2),</div><div class="line">        H: d.getHours(),</div><div class="line">        hh: (&apos;0&apos; + d.getHours() % 12).slice(-2),</div><div class="line">        h: d.getHours() % 12,</div><div class="line">        mm: (&apos;0&apos; + d.getMinutes()).slice(-2),</div><div class="line">        m: d.getMinutes(),</div><div class="line">        ss: (&apos;0&apos; + d.getSeconds()).slice(-2),</div><div class="line">        s: d.getSeconds(),</div><div class="line">        w: [&apos;日&apos;,&apos;一&apos;,&apos;二&apos;,&apos;三&apos;,&apos;四&apos;,&apos;五&apos;,&apos;六&apos;][d.getDay()]</div><div class="line">    &#125;</div><div class="line">    return sFormation.replace(/([a-z]+)/ig, function(match, p1)&#123;</div><div class="line">    	console.log(match, p1);</div><div class="line">    	return obj[p1]</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><p><strong>实现模版解析函数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var str = &apos;I am &#123;name&#125;，my job is &#123;job&#125;.&apos;;</div><div class="line">var obj = &#123;</div><div class="line">	name: &apos;kad&apos;,</div><div class="line">	job: &apos;Front-End Development&apos;</div><div class="line">&#125;;</div><div class="line">function tmpl(str, obj)&#123;</div><div class="line">	return str.replace(/&#123;([^&#125;]+)&#125;/ig, function(match, $1)&#123;</div><div class="line">		console.log(match, $1);</div><div class="line">		return obj[$1];</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line">console.log(tmpl(str, obj));</div></pre></td></tr></table></figure>
<h3 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h3><p><strong>CSS中经常有类似<code>background-image</code>这种通过<code>-</code>连接的字符，通过JS设置样式的时候需要将这种样式转换成backgroundImage驼峰格式，请完成此转换功能</strong></p>
<ol>
<li>以<code>-</code>为分隔符，将第二个起的非空单词首字母转为大写</li>
<li><code>-webkit-border-image</code>转换后的结果为 webkitBorderImage</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function cssStyle2DomStyle(sName) &#123;</div><div class="line">    var arr = sName.split(&apos;-&apos;);</div><div class="line">    var mark = false;</div><div class="line">    var ans = &apos;&apos;;</div><div class="line">    for(var i = 0; i &lt; arr.length; i++)&#123;</div><div class="line">        if(arr[i].trim())&#123;</div><div class="line">            if(!mark) &#123;</div><div class="line">                mark = true;</div><div class="line">                ans += arr[i];</div><div class="line">            &#125;else&#123;</div><div class="line">                ans += arr[i].charAt(0).toUpperCase() + arr[i].slice(1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function cssStyle2DomStyle(sName) &#123;</div><div class="line">    return sName.replace(/(?!^)\-(\w)(\w+)/g, function(a, b, c)&#123;</div><div class="line">            return b.toUpperCase() + c.toLowerCase();</div><div class="line">        &#125;).replace(/^\-/, &apos;&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h3><p><strong>将 rgb 颜色字符串转换为十六进制的形式，如<code>rgb(255, 255, 255)</code> 转为 <code>#ffffff</code>.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function rgb2hex(sRGB) &#123;</div><div class="line">    var reg = /rgb\((\d+),\s*(\d+),\s*(\d+)\)/;</div><div class="line">    var arr = sRGB.match(reg);</div><div class="line">    console.log(arr);</div><div class="line">    var ans = &apos;#&apos;;</div><div class="line">    if(arr)&#123;</div><div class="line">        for(var i = 1; i &lt; arr.length; i++)&#123;</div><div class="line">            var num = parseInt(arr[i]);</div><div class="line">            ans += num &lt; 16 ? (&apos;0&apos; + num) : num.toString(16);   </div><div class="line">        &#125;</div><div class="line">    &#125;else&#123;</div><div class="line">        ans = sRGB;</div><div class="line">    &#125;</div><div class="line">    return ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://deerchao.net/tutorials/regex/regex-1.htm" target="_blank" rel="external">正则表达式30分钟入门教程</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="external">RegExp MDN</a></p>
<p><a href="https://alf.nu/RegexGolf" target="_blank" rel="external">Regex Golf</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="external">replace MDN</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS布局]]></title>
      <url>http://kad0108.github.io/2017/03/24/layout/</url>
      <content type="html"><![CDATA[<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h3 id="文本的水平垂直居中"><a href="#文本的水平垂直居中" class="headerlink" title="文本的水平垂直居中"></a>文本的水平垂直居中</h3><p><code>text-align + line-height</code></p>
<h3 id="盒模型的水平垂直居中"><a href="#盒模型的水平垂直居中" class="headerlink" title="盒模型的水平垂直居中"></a>盒模型的水平垂直居中</h3><ol>
<li><p>绝对定位 + top:50%;left:50%; + margin-left,margin-top元素宽高的一半</p>
</li>
<li><p>弹性布局 <code>display:flex; + justify-content:center; + align-items:center;</code></p>
</li>
<li><p>表格布局 <code>display:table;text-align:center;</code> + <code>display:table-cell;vertical-align:middle;</code></p>
</li>
</ol>
<a id="more"></a>
<h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><p>左右两栏宽度固定，中间一栏自适应宽度。</p>
<p>实现三栏布局的几种方法：</p>
<h3 id="最古老的table的布局，三个td搞定"><a href="#最古老的table的布局，三个td搞定" class="headerlink" title="最古老的table的布局，三个td搞定"></a>最古老的table的布局，三个td搞定</h3><h3 id="float布局：middle必须放最后"><a href="#float布局：middle必须放最后" class="headerlink" title="float布局：middle必须放最后"></a>float布局：middle必须放最后</h3><p>middle如果放在right前，没有设置浮动，和right不在一个流中会把right挤下去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">html,body,div&#123;</div><div class="line">	height: 100%;</div><div class="line">&#125;</div><div class="line">.middle&#123;</div><div class="line">	margin: 0 200px;</div><div class="line">&#125;</div><div class="line">.left, .right&#123;</div><div class="line">	background-color: purple;</div><div class="line">	width: 200px;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">	float: left;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">	float: right;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="absolute布局：middle可以放中间"><a href="#absolute布局：middle可以放中间" class="headerlink" title="absolute布局：middle可以放中间"></a>absolute布局：middle可以放中间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">html,body,div&#123;</div><div class="line">	height: 100%;</div><div class="line">&#125;</div><div class="line">.middle&#123;</div><div class="line">	margin: 0 200px;</div><div class="line">&#125;</div><div class="line">.left, .right&#123;</div><div class="line">	background-color: purple;</div><div class="line">	width: 200px;</div><div class="line">	position: absolute;</div><div class="line">	top: 0;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">	left: 0;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">	right: 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="flex一维布局"><a href="#flex一维布局" class="headerlink" title="flex一维布局"></a>flex一维布局</h3><p>父元素设置flex布局，子元素中需要自适应宽度的设置flex:1;，通过order来实现对子元素排列顺序的控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">html,body,div&#123;</div><div class="line">	height: 100%;</div><div class="line">&#125;</div><div class="line">.container&#123;</div><div class="line">	display: flex;</div><div class="line">&#125;</div><div class="line">.middle&#123;</div><div class="line">	order: 2;</div><div class="line">	flex: 1;</div><div class="line">&#125;</div><div class="line">.left, .right&#123;</div><div class="line">	background-color: purple;</div><div class="line">	width: 200px;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">	order: 1;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">	order: 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">	&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h3 id="grid-目前仍然在W3C草案中的栅格二维布局，需要确定浏览器支持"><a href="#grid-目前仍然在W3C草案中的栅格二维布局，需要确定浏览器支持" class="headerlink" title="grid: 目前仍然在W3C草案中的栅格二维布局，需要确定浏览器支持"></a>grid: 目前仍然在W3C草案中的栅格二维布局，需要确定浏览器支持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">html,body,div&#123;</div><div class="line">	height: 100%;</div><div class="line">&#125;</div><div class="line">.container&#123;</div><div class="line">	display: grid;</div><div class="line">	grid-template-columns: 200px auto 200px;</div><div class="line">	grid-template-rows: 100%;</div><div class="line">&#125;</div><div class="line">.middle&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">.left, .right&#123;</div><div class="line">	background-color: purple;</div><div class="line">	width: 200px;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">	&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="两列布局"><a href="#两列布局" class="headerlink" title="两列布局"></a>两列布局</h2><p>左栏固定宽度，右栏自适应宽度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">html,body,div&#123;</div><div class="line">	height: 100%;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">	width: 200px;</div><div class="line">	float: left;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">	margin-left: 200px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>也可以触发右栏元素的BFC实现自适应，见<a href="/2017/03/02/bfc/" title="BFC">BFC</a>这篇博文。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.w3cplus.com/css/vertically-center-content-with-css" target="_blank" rel="external">CSS制作水平垂直居中对齐</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="external">Flex</a></p>
<p><a href="http://www.jackpu.com/san-lie-bu-ju-zuo-you-gu-ding-zhong-jian-lie-zi-gua-ying-tan-jiu/" target="_blank" rel="external">CSS Grid</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ajax和跨域总结]]></title>
      <url>http://kad0108.github.io/2017/03/11/ajax/</url>
      <content type="html"><![CDATA[<h2 id="Ajax-异步JS-XML"><a href="#Ajax-异步JS-XML" class="headerlink" title="Ajax = 异步JS + XML"></a>Ajax = 异步JS + XML</h2><p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新(不阻塞)。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<h3 id="创建XMLHttpRequest对象，用于和服务器交换数据"><a href="#创建XMLHttpRequest对象，用于和服务器交换数据" class="headerlink" title="创建XMLHttpRequest对象，用于和服务器交换数据"></a>创建XMLHttpRequest对象，用于和服务器交换数据</h3><p>浏览器兼容写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var xhr;</div><div class="line">if(window.XMLHttpRequest)&#123;</div><div class="line">	xhr = new XMLHttpRequest();</div><div class="line">&#125;eles if(window.ActiveXObject)&#123;</div><div class="line">	// code for IE5,IE6</div><div class="line">	xhr = new ActiveXObject(Microsoft.XMLHTTP);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="向服务器发起请求："><a href="#向服务器发起请求：" class="headerlink" title="向服务器发起请求："></a>向服务器发起请求：</h3><p><strong>GET or POST?</strong></p>
<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求：</p>
<ol>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ol>
<p><strong>GET请求</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xhr.open(&quot;GET&quot;, url, true);</div><div class="line">xhr.send(null);</div></pre></td></tr></table></figure>
<p>为避免获取到的缓存结果，可以向url添加一个唯一的ID：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.open(&quot;GET&quot;,&quot;demo_get.asp?t=&quot; + Math.random(),true);</div></pre></td></tr></table></figure></p>
<p>通过 GET 方法发送信息，请向 URL 添加信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.open(&quot;GET&quot;,&quot;demo_get2.asp?fname=Bill&amp;lname=Gates&quot;,true);</div></pre></td></tr></table></figure></p>
<p><strong>POST请求</strong></p>
<p>需要使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定希望发送的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.asp&quot;,true);</div><div class="line">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//提交时的内容类型</div><div class="line">xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;);</div></pre></td></tr></table></figure></p>
<h3 id="发送XHR请求时，会发送的HTTP头部信息："><a href="#发送XHR请求时，会发送的HTTP头部信息：" class="headerlink" title="发送XHR请求时，会发送的HTTP头部信息："></a>发送XHR请求时，会发送的HTTP头部信息：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Accept：浏览器能够处理的内容类型</div><div class="line">Accept-Charset：浏览器能够显示的字符集</div><div class="line">Accept-Encoding：浏览器能够处理的压缩编码</div><div class="line">Accept-Language：浏览器当前设置的语言</div><div class="line">Connection：浏览器与服务器之间连接的类型</div><div class="line">Cookie：缓存</div><div class="line">Host：发出请求的页面所在的域</div><div class="line">Referer：发出请求的页面的URI</div><div class="line">User-Agent：浏览器的用户代理字符串</div></pre></td></tr></table></figure>
<p><img src="/2017/03/11/ajax/ajaxheader.png" alt="ajax http header"></p>
<p>使用setRequestHeader()可以设置自定义的请求头部信息。要成功发送请求头部信息，必须在open方法之后和send方法之前调用。</p>
<h3 id="服务器响应："><a href="#服务器响应：" class="headerlink" title="服务器响应："></a>服务器响应：</h3><p>responseText：获得字符串形式的响应数据。<br>responseXML：获得 XML 形式的响应数据</p>
<h3 id="原生JS写Ajax"><a href="#原生JS写Ajax" class="headerlink" title="原生JS写Ajax"></a>原生JS写Ajax</h3><p>XMLHttpRequest Level 1 的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var url = &apos;xx.json&apos;;</div><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.onreadystatechange = function()&#123;</div><div class="line">	if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</div><div class="line">		console.log(xhr.responseText);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">xhr.open(&quot;GET&quot;, url);</div><div class="line">xhr.send(null);</div></pre></td></tr></table></figure></p>
<p>XMLHTTPRequest Level 2 的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var url = &apos;xx.json&apos;;</div><div class="line">var xhr = new XMLHttpRequest();</div><div class="line"></div><div class="line">xhr.open(&apos;GET&apos;, url);</div><div class="line">xhr.send(null);</div><div class="line"></div><div class="line">xhr.onload = function()&#123;</div><div class="line">	if(xhr.status == 200 || xhr.status == 304)&#123;</div><div class="line">		console.log(JSON.parse(xhr.responseText));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>老版本缺点：</strong></p>
<ol>
<li>只支持文本数据的传送，无法用来读取和上传二进制文件。</li>
<li>传送和接收数据时，没有进度信息，只能提示有没有完成。</li>
<li>受到”同域限制”（Same Origin Policy），只能向同一域名的服务器请求数据。</li>
</ol>
<p><strong>XMLHttpRequest Level 2新版本的功能：</strong></p>
<ol>
<li>可以设置HTTP请求的时限，xhr.timeout，xhr.ontimeout。</li>
<li>可以使用FormData对象管理表单数据，xhr.send(new FormData(form))。</li>
<li>可以上传文件, formData.append(‘files[]’, files[i])。</li>
<li>可以请求不同域名下的数据（跨域请求）,CORS，使用跨域资源共享的前提是浏览器支持且服务器同意。</li>
<li>可以获取服务器端的二进制数据。</li>
<li>可以获得数据传输的进度信息，xhr.onprogress。</li>
</ol>
<blockquote>
<p>面试题：Ajax实现分页，分页切换url不变，现在想实现点击浏览器后退按钮回退到前一页而不是上一个链接</p>
</blockquote>
<p>可以采用“地址栏加hash”技术来解决。只要改变锚点内容（‘#’后的），浏览器就认为URL变化，也就会放入浏览历史，这样前进后退问题就解决了。我们只要把不同的AJAX状态通过不同的hash写到地址栏就可以了，当页面加载的时候检测是否有hash值，有的话就读取hash进行相应的ajax还原操作。location.hash可以取到或者设置hash的值，当hash改变的时候window.onhashchange事件会被触发。</p>
<h3 id="JQuery的Ajax使用"><a href="#JQuery的Ajax使用" class="headerlink" title="JQuery的Ajax使用"></a>JQuery的Ajax使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">	url: &apos;./data.json&apos;,</div><div class="line">	type: &apos;GET&apos;,</div><div class="line">	aysnc: true,</div><div class="line">	data: &#123;//发送给服务器的数据</div><div class="line"></div><div class="line">	&#125;,</div><div class="line">	timeout: 5000, //超时</div><div class="line">	dataType: &apos;json&apos;, //服务器返回的数据格式</div><div class="line"></div><div class="line">	beforeSend:function(xhr)&#123;</div><div class="line">        //发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头</div><div class="line">    &#125;,</div><div class="line">	success: function(data, textStatus)&#123;</div><div class="line">		//根据 dataType 参数进行处理后的服务器返回数据</div><div class="line">	&#125;,</div><div class="line">	error: function()&#123;</div><div class="line">		//请求出错处理</div><div class="line">	&#125;,</div><div class="line">	complete:function()&#123;</div><div class="line">        //请求完成之后调用这个函数，无论成功或失败</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>jquery调用ajax中文乱码的问题，提交前用encode对数据进行编码，后台接收处对数据进行解码。</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>跨域是指在通过JS不同域之间进行数据传输或通信。只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p>
<h3 id="CORS-Cross-Origin-Resource-Sharing-跨域资源共享"><a href="#CORS-Cross-Origin-Resource-Sharing-跨域资源共享" class="headerlink" title="CORS(Cross-Origin Resource Sharing, 跨域资源共享)"></a>CORS(Cross-Origin Resource Sharing, 跨域资源共享)</h3><p>CORS的基本思想是使用自定义的HTTP头部让浏览器和服务器进行沟通。</p>
<p>发起请求时添加额外的Origin头部，包含和请求页面的源信息，服务器根据这个头部信息决定是否给予响应，就在Access-Control-Allow-Origin头部中返回相同的源信息。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Origin：http://www.abc.com</div><div class="line">Access-Control-Allow-Origin: http://www.abc.com</div></pre></td></tr></table></figure></p>
<p>注意，请求和响应都不包含cookie信息。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>通过script标签引入的js是不受同源策略的限制的，其实凡是带有src这个属性的标签都拥有跨域的能力，如script、img、iframe。</p>
<p>JSONP是使用script元素获取JSON数据包装在一个回调函数中操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function handle(response)&#123;</div><div class="line">	console.log(response.data);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var script = document.createElement(&apos;script&apos;);</div><div class="line">script.src = &apos;http://abc.com/json/?callback=handle&apos;;</div><div class="line">document.body.insertBefore(script, document.body.firstChild);</div></pre></td></tr></table></figure>
<p>JSONP的缺点：无法确定其他域是否安全，无法确定JSONP请求是否失败。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。</p>
<p>JSONP的优势：在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>比如两个页面地址分别为<code>x.abc.com</code>和<code>y.abc.com</code>，明显不同域，可以将两个页面的<code>document.domain</code>设为相同的域名<code>abc.com</code>，而且也只能设置为更高一级的父域，且<strong>主域必须相同</strong>。</p>
<p>不同域之间能够获得彼此的window对象，但不能获取window的属性和方法。通过修改两个页面的document.domain，就可以在父页面中操作它里面的iframe的window对象(contentWindow)。</p>
<p>修改document.domain的方法只适用于不同子域的框架间的交互.</p>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>在每个窗口window的生命周期内，窗口载入的所有页面都是共享一个window.name的，每个页面都对window.name有读写的权限。window.name是持久存在在一个窗口载入过的所有页面中，并不会因为新页面的载入而重置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//a.html</div><div class="line">window.name = &apos;data from a.html&apos;;</div><div class="line">window.location = &apos;b.html&apos;;</div><div class="line"></div><div class="line">//b.html</div><div class="line">console.log(window.name);//&apos;data from a.html&apos;</div></pre></td></tr></table></figure>
<h3 id="HTML5-PostMessage"><a href="#HTML5-PostMessage" class="headerlink" title="HTML5 PostMessage"></a>HTML5 PostMessage</h3><p>postMessage用于两个窗口iframe之间交换数据。两个窗口能通信的前提是：一个窗口以iframe的形式存在于另一个窗口中(MessageEvent.source获取源窗口)，或者一个窗口是从另一个窗口通过window.open()或超链接形式打开的(同样可以用window.opener获取源窗口)。也就是说要想交换数据，必须能获取目标窗口的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// origin1</div><div class="line">window.frames[0].postMessage(message, origin2URL);</div><div class="line">window.onmessage = function(e)&#123;</div><div class="line">	console.log(e.data);// MessageEvent</div><div class="line">&#125;</div><div class="line">// origin2: iframe in origin1</div><div class="line">window.onmessage = function(e)&#123;</div><div class="line">	if(e.source != window.parent) return;// 判断数据发送方</div><div class="line">	console.log(e.data);</div><div class="line">	e.source.postMessage(message, e.origin);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/kad0108/Html5/tree/gh-pages/postMessage" target="_blank" rel="external">demo看这里</a></p>
<blockquote>
<p>如果需要传输的数据很大，用HTTP GET请求肯定不行，而且需要兼容浏览器，应该怎么跨域？</p>
</blockquote>
<p>使用POST请求，通过表单提交，action指向post请求的地方，提交表单会马上刷新页面，target可以指定刷新页面，写个iframe让target指向这个iframe。</p>
<h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><h3 id="XSS-Cross-Site-Scripting"><a href="#XSS-Cross-Site-Scripting" class="headerlink" title="XSS(Cross Site Scripting)"></a>XSS(Cross Site Scripting)</h3><p>XSS跨站脚本攻击：攻击者向web页面插入恶意脚本代码<code>&lt;script&gt;&lt;/script&gt;</code>来攻击用户。</p>
<p>XSS防御：对输入(和URL参数)进行过滤，对输出进行html编码。特殊字符过滤，如：<code>&lt;</code>,<code>&gt;</code>,<code>&amp;</code>,JS伪协议。</p>
<h3 id="CSRF-Cross-Site-Request-Forgery"><a href="#CSRF-Cross-Site-Request-Forgery" class="headerlink" title="CSRF(Cross Site Request Forgery)"></a>CSRF(Cross Site Request Forgery)</h3><p>CSRF跨站请求伪造：通过伪造来自受信任用户的请求来利用受信任的网站。</p>
<p><strong>CSRF原理：</strong></p>
<p>通过例子来说明，用户访问并登录银行网站，用户在未登出银行网站的情况下访问了危险网站(可以通过广告等诱使用户访问)，用户在访问这个危险网站同时，向银行发起一个转账请求，这个请求会携带着用户的cookie走了。这个请求因为是用户发起的并且携带了认证信息，所以请求会成功响应。所以，CSRF攻击是hacker借助受害者的cookie骗取服务器的信任，但hacker是打死都拿不到也无法读取cookie的，而且服务器返回的结果由于浏览器同源策略的限制，hacker也无法拿到。</p>
<p><strong>CSRF防御：</strong></p>
<ol>
<li><p>检查HTTP头部Referer(从哪个页面链接过来)</p>
</li>
<li><p>检查token(服务器不存储用户登录状态，只需验证token是否合法)</p>
</li>
<li><p>通过验证码来检测用户提交</p>
</li>
<li><p>使用定制的HTTP报头</p>
</li>
<li><p>严格设置cookie的域</p>
</li>
</ol>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>Ajax是无需刷新页面就能够从服务器取得数据的一种方法，核心对象是XMLHttpRequest对象。</p>
<p>同源策略是对XHR的一个主要约束，它为通信设置了”相同的域、相同的端口、相同的协议”这一限制。试图访问上述限制之外的资源都会引发安全错误，除非采用被认可的跨域解决方案，这个方案叫做CORS。</p>
<p>Comet是对Ajax的扩展，让服务器能够实时向客户端推送数据。实现Comet的手段主要有：长轮询和HTTP流。</p>
<p>WebSockets是一种与服务器进行全双工、双向通信的信道。与其他方案不同，websockets不使用HTTP协议，而使用自定义的协议，专门为快速传输小数据设计。</p>
<p>JS跨域请求方式有：CORS、JSONP、修改<code>document.domain</code>跨子域、<code>window.name</code>、<code>HTML5 window.postMessage</code>.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="external">XMLHttpRequest Level 2 使用指南</a><br><a href="https://developer.mozilla.org/cn/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest" target="_blank" rel="external">Using XMLHttpRequest</a><br><a href="http://www.jquery123.com/jQuery.ajax/" target="_blank" rel="external">jQuert.ajax()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">HTTP访问控制(CORS)</a><br><a href="https://segmentfault.com/a/1190000000718840" target="_blank" rel="external">详解js跨域问题</a><br><a href="http://www.cnblogs.com/zichi/p/4638096.html" target="_blank" rel="external">HTML5 PostMessage</a><br><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/" target="_blank" rel="external">CSRF 攻击</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[输入URL到页面加载完成这个过程中都发生了什么]]></title>
      <url>http://kad0108.github.io/2017/03/09/url/</url>
      <content type="html"><![CDATA[<p><strong>过程大致分为网络通信和页面渲染：</strong></p>
<ol>
<li><p>DNS解析：根据输入域名查找对应的IP地址</p>
</li>
<li><p>TCP三次握手：浏览器向服务器发起TCP连接</p>
</li>
<li><p>握手成功后浏览器向服务器发起HTTP请求</p>
</li>
<li><p>服务器接收到请求，将数据返回给浏览器</p>
</li>
<li><p>浏览器下载HTML文档(响应报头，状态码200)，同时设置缓存，返回304则表示有缓存直接用缓存</p>
</li>
<li><p>浏览器解析渲染页面。</p>
</li>
<li><p>TCP四次挥手断开连接</p>
</li>
</ol>
<a id="more"></a>
<h2 id="DNS：应用层协议"><a href="#DNS：应用层协议" class="headerlink" title="DNS：应用层协议"></a>DNS：应用层协议</h2><p>DNS默认使用UDP协议，因为不需要TCP三次握手，传输速度快而且响应快。</p>
<h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><p><strong>浏览器缓存 -&gt; 操作系统DNS缓存 -&gt; 操作系统hosts文件 -&gt; 本地DNS服务器</strong></p>
<p>到本地DNS服务器一般有80%的域名解析成功了，如果没解析就会向根DNS服务器等顶级域名服务器发起迭代DNS解析请求。</p>
<p>实际情况中，主机到本地DNS采用递归查询，DNS服务器之间采用迭代查询。</p>
<p>DNS解析为什么设置成这种形式？分布式分层次的DNS解析可以覆盖所有域名系统，本地DNS缓存是为了加快速度。</p>
<p>后端原来是ip为a的服务器，现在换到b了，你拿到了错误的域名解析ip地址会怎么样？出现域名解析错误，可以清除本地DNS缓存。</p>
<h3 id="常见的DNS攻击"><a href="#常见的DNS攻击" class="headerlink" title="常见的DNS攻击"></a>常见的DNS攻击</h3><ol>
<li><p>域名劫持：黑客控制域名管理邮箱密码，将该域名的记录指向黑客可控制的DNS服务器，使用户访问该域名时，进入黑客指向的内容。</p>
</li>
<li><p>缓存投毒：控制DNS缓存服务器，将错误域名记录存入缓存中，将本来访问某网站的用户带到黑客指向的网站。</p>
</li>
<li><p>DDOS攻击：攻击者向DNS服务器发送大量请求占用网络资源，使合法DNS请求得不到响应。</p>
</li>
<li><p>DNS欺骗：攻击者冒充域名服务器</p>
</li>
</ol>
<h2 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h2><p>TCP是传输层协议，UDP也是。</p>
<h3 id="三次握手的过程："><a href="#三次握手的过程：" class="headerlink" title="三次握手的过程："></a>三次握手的过程：</h3><ol>
<li>客户端先发送一个带有SYN标志的报文给服务端</li>
<li>服务端收到SYN报文后，传回一个带有SYN/ACK标志的报文以示传达确认信息。</li>
<li>客户端收到后再发送一个带有ACK标志的报文段给服务端以示握手成功。</li>
</ol>
<h3 id="需要三次握手的主要原因是："><a href="#需要三次握手的主要原因是：" class="headerlink" title="需要三次握手的主要原因是："></a>需要三次握手的主要原因是：</h3><p>TCP是双通道连接，即client和server都需要互相通信，并且双方都需要初始化自身的序列号，并且让对方确认自身的序列号。</p>
<p>为了互相通信，因此第一次握手是client向server发送自身的初始序列号，同时需要server回复确认此序列号，<br>另一方面server也需要发送自身的序列号，并且需要client确认自身的序列号，因此第二次握手把server向client确认client的序列号和server向client发送server自身的序列号两个过程合并了，第三次握手即是client确认了server的序列号。</p>
<p>少于三次握手都不能使双方对对方的序列号进行确认。</p>
<h2 id="浏览器页面渲染"><a href="#浏览器页面渲染" class="headerlink" title="浏览器页面渲染"></a>浏览器页面渲染</h2><p>最终决定浏览器表现出来的页面效果的差异是：渲染引擎 Rendering Engine，也就是我们通常所说的“浏览器内核”，负责解析网页语法（如HTML、JavaScript）并渲染、展示网页。</p>
<h3 id="加载页面时浏览器的具体工作流程是："><a href="#加载页面时浏览器的具体工作流程是：" class="headerlink" title="加载页面时浏览器的具体工作流程是："></a>加载页面时浏览器的具体工作流程是：</h3><ol>
<li><p>解析HTML，转换树中的标签到DOM节点，构建DOM。</p>
</li>
<li><p>解析CSS，构建CSSOM。</p>
</li>
<li><p>结合DOM和CSSOM，构建Render Tree。</p>
</li>
<li><p>布局Layout渲染Paint过程，计算元素大小、位置。这里也就涉及到了repaint和reflow的概念。</p>
</li>
</ol>
<h2 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h2><p>由于TCP连接是全双工的，因此每个方向都必须<strong>单独进行关闭</strong>。客户端或服务器均可主动发起挥手动作。</p>
<h3 id="四次挥手的过程："><a href="#四次挥手的过程：" class="headerlink" title="四次挥手的过程："></a>四次挥手的过程：</h3><ol>
<li><p>客户端发送FIN，来关闭客户端到服务端的数据传送</p>
</li>
<li><p>服务端接受到这个FIN，回复确认ACK报文。</p>
</li>
<li><p>服务端关闭与客户端的连接，发送FIN给客户端。</p>
</li>
<li><p>客户端回复ACK确认。</p>
</li>
</ol>
<p>当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。</p>
<p><img src="/2017/03/09/url/url.png" alt="网上找到一张过程很详细的图"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.williamlong.info/archives/3813.html" target="_blank" rel="external">DNS攻击原理与防范</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端性能优化]]></title>
      <url>http://kad0108.github.io/2017/03/08/optimize/</url>
      <content type="html"><![CDATA[<p>前端性能优化，目的是为什么？让用户有更友好的体验，让服务商节省可观的资源。</p>
<p>对优化方向进行分类，直接来看表：</p>
<table>
<thead>
<tr>
<th>优化方向</th>
<th style="text-align:center">优化手段</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求数量</td>
<td style="text-align:center">CSS Sprites，合并脚本和样式表</td>
</tr>
<tr>
<td>请求带宽</td>
<td style="text-align:center">使用Gzip压缩传输文件，精简JS文件</td>
</tr>
<tr>
<td>缓存利用</td>
<td style="text-align:center">使用http缓存，使用CDN，ajax，减少DNS查找</td>
</tr>
<tr>
<td>页面结构</td>
<td style="text-align:center">样式表放顶部，脚本放底部</td>
</tr>
<tr>
<td>代码校验</td>
<td style="text-align:center">避免CSS表达式，避免重定向</td>
</tr>
<tr>
<td>减少Repaint和Reflow</td>
<td style="text-align:center">设置class，脱离文档流，减少dom操作</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>下面具体解释其中一些优化点：</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>Content Delivery Network 即内容分发网络，CDN把<strong>内容分发</strong>到距离用户近的缓存服务器，然后DNS托管(把DNS解析的地址改成CDN提供的)，DNS服务器根据用户IP地址，将域名解析成相应节点的缓存服务器IP地址，实现<strong>用户就近访问</strong>，提高网站渲染速度和性能。</p>
<h3 id="减少repaint和reflow"><a href="#减少repaint和reflow" class="headerlink" title="减少repaint和reflow"></a>减少repaint和reflow</h3><p><a href="http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/" target="_blank" rel="external">回流与重绘</a></p>
<ol>
<li><p>通过设置class的方式，而不是多次修改元素style属性。</p>
</li>
<li><p>有动画效果的元素可以将position属性设为fixed或absolute。</p>
</li>
<li><p>权衡速度的平滑性，函数节流（自己的理解）</p>
</li>
<li><p>减少对DOM元素的查询和修改，查询时可将其赋值给局部变量。</p>
</li>
</ol>
<h3 id="CSS引用"><a href="#CSS引用" class="headerlink" title="CSS引用"></a>CSS引用</h3><p>尽量使用link代替@import，因为link是在页面加载时同时加载，import是等页面加载完再加载。</p>
<h2 id="有关缓存"><a href="#有关缓存" class="headerlink" title="有关缓存"></a>有关缓存</h2><h3 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h3><p>缓存可以减少响应延迟，减少网络带宽消耗。http header中与缓存控制相关的头部有：Cache-Control、Expires、Etag、Last-Modified。</p>
<p>浏览器在第一次第一次请求后，再次请求时：</p>
<ol>
<li><p>浏览器会先看header中的Cache-Control和Expires(强缓存)，如果有缓存则直接从本地缓存中获取资源，不和服务器通信，返回200。</p>
</li>
<li><p>如果没有缓存，则携带Etag和Last-Modified(协商缓存)发请求给服务器，如果服务器端没有变化，返回304，告诉浏览器可以从缓存中获取资源。</p>
</li>
<li><p>如果本地没有缓存或者服务器端资源有更新，或者用户强制刷新Ctrl+F5，浏览器会直接从服务器下载最新数据</p>
</li>
</ol>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>请求报文的请求头部，控制缓存行为，相对时间。</p>
<p><strong>max-age</strong>这个值也爱考，max-age&gt;0直接从浏览器缓存中提取，max-age&lt;=0向server发送http请求确认该资源是否有修改，有返回200，无返回304。</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>响应内容过期时间，是绝对时间。如果max-age和Expires同时存在，<strong>cache-control覆盖expires</strong>。</p>
<h4 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h4><p>请求报文的响应头部，响应中资源的校验值，用于标示URL对象是否改变，是与web资源关联的记号(token)。</p>
<p>请求头中<strong>If-Match</strong>和<strong>If-None-Match</strong>用来比较Etag是否一致。</p>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p>响应中文件在服务器端最后一次修改的时间。</p>
<p>请求头中<strong>If-Modified-Since</strong>询问该时间后文件是否有被修改过。没有变化返回304。</p>
<p>ETag解决了Last-modified无法解决的问题：</p>
<ul>
<li>一些文件修改时间改变了，但是内容没有改变，此时使用Last-modified会认为资源更新了，而ETag不会。</li>
<li>Last-modified只能精确到秒，如果资源修改非常频繁，在秒以下的时间进行修改，Last-modified无法正确响应。</li>
<li>某些服务器不能精确的得到文件的最后修改时间，这样就无法通过最后修改时间判断资源是否更新。</li>
</ul>
<blockquote>
<p>有面试题问304缓存的原理，Not Modified，就可以讲讲上面的http缓存了。</p>
</blockquote>
<h3 id="离线缓存"><a href="#离线缓存" class="headerlink" title="离线缓存"></a>离线缓存</h3><p>之前一直以为离线缓存就是指本地存储localStorage…是我孤陋寡闻了。但是！<strong>这个HTML5新特性已被弃用</strong>！</p>
<p>这里还是简要说一下这个技术的思想：开发者可以使用 Application Cache (AppCache) 接口设定浏览器应该缓存的资源并使得离线用户可用。</p>
<p>来分析一下mainfest的优缺点：</p>
<p>优点：</p>
<ol>
<li>离线运行</li>
<li>加载速度快</li>
<li>减少服务器负载，只下载更新资源</li>
</ol>
<p>缺点：</p>
<ol>
<li>更新的资源，需要二次刷新才会被页面采用</li>
<li>不支持增量更新，只要manifest发生变化，所有资源全部重新下载一次</li>
<li>缺乏足够容错机制，当清单中任意资源文件出现加载异常，都会导致整个manifest策略运行异常</li>
</ol>
<p>全量加载和二次刷新这两个缺点就已经够严重了。再看其优点也不是真的那么好用：</p>
<p>1.离线运行对于普通页面来说，离线运行没什么用；对于webapp来说，这个特性还不错；对于hybird app来说，也没什么用。<br>2.减少资源请求HTTP协议的Cache-Control和Expires就也能在缓存有效期内，不再发送资源请求<br>3.可以更新资源manifest是文件被更新后，全量更新缓存。而改用HTTP协议的缓存方案，只需要对资源文件引用的URL做少许变动即可刷新缓存，例如补个时间戳参数</p>
<blockquote>
<p>面试问题：浏览器的缓存机制</p>
</blockquote>
<p>在浏览器端保存数据能够快速读取本地数据加速网页展示，避免重复的网络请求。可以在Chrome的开发者工具的Application中看到浏览器支持的缓存机制。</p>
<p>浏览器缓存机制有：HTTP缓存、WEB SQL、IndexedDB、Cookie、LocalStorage、SessionStorage、Application Cache</p>
<p><img src="/2017/03/08/optimize/cache.png" alt="浏览器缓存机制"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://blog.csdn.net/eroswang/article/details/8302191" target="_blank" rel="external">浏览器缓存详解</a></p>
<p><a href="http://www.iteye.com/topic/656658" target="_blank" rel="external">Etag</a></p>
<p><a href="http://www.cnblogs.com/lei2007/archive/2013/08/16/3262897.html" target="_blank" rel="external">yahoo前端性能优化</a></p>
<p><a href="https://github.com/fouber/blog/issues/3" target="_blank" rel="external">前端工程与性能优化</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache" target="_blank" rel="external">manifest</a></p>
<p><a href="https://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="external">浏览器HTTP协议缓存机制</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于JS中变量类型的一些知识总结]]></title>
      <url>http://kad0108.github.io/2017/03/03/datatype/</url>
      <content type="html"><![CDATA[<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>基本类型：Number、String、Boolean、Null、Undefined</p>
<p>引用类型：Array、Object</p>
<p>ES6新数据类型：Symbol</p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><ol>
<li><p>var、let、const、function</p>
</li>
<li><p>不使用关键字，全局变量</p>
</li>
<li><p>window.a = 1，全局变量</p>
</li>
</ol>
<a id="more"></a>
<h3 id="判断变量类型"><a href="#判断变量类型" class="headerlink" title="判断变量类型"></a>判断变量类型</h3><ol>
<li><p><strong>typeof</strong></p>
<p> typeof返回的是类型字符串，它的返回值有6种：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typeof 3; // &quot;number&quot;</div><div class="line">typeof &quot;abc&quot;; // &quot;string&quot;</div><div class="line">typeof true; // &quot;boolean&quot;</div><div class="line">typeof undefined; // &quot;undefined&quot;</div><div class="line">typeof null; // &quot;object&quot;</div><div class="line">typeof &#123;&#125;; // &quot;object&quot;</div><div class="line">typeof function()&#123;&#125;; // &quot;function&quot;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>instanceof</strong></p>
<p> 检测引用类型是具体什么类型的对象时使用instaceof，本质是检查某个对象的原型链是否包含某个构造函数的prototype属性。instanceof是通过原型链来检查类型的，所以适用于任何object的类型检查。instanceof对基本数据类型不起作用，因为基本数据类型没有原型链。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3] instanceof Array // true</div><div class="line">/abc/ instanceof RegExp // true</div><div class="line">(&#123;&#125;) instanceof Object // true</div><div class="line">(function()&#123;&#125;) instanceof Function // true</div><div class="line">/*原型*/</div><div class="line">function Animal()&#123; &#125;</div><div class="line">(new Animal) instanceof Animal     // true</div></pre></td></tr></table></figure>
</li>
<li><p><strong>constructor</strong></p>
<p> constructor属性返回一个指向创建了该对象原型的函数引用(即函数本身)。与instanceof不同的是，在访问基本类型的constructor时，JS会自动调用其构造函数来生成一个对象。但是无法判断null和undefined。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(3).constructor === Number // true</div><div class="line">true.constructor === Boolean // true</div><div class="line">&apos;abc&apos;.constructor === String // true</div><div class="line">[1,2,3].constructor === Array // true</div><div class="line">(function()&#123;&#125;).constructor === Function // true</div><div class="line">null.constructor         // TypeError!</div><div class="line">undefined.constructor    // TypeError!</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Object.prototype.toString</strong></p>
<p> toString会将当前对象转换成字符串输出。可以检查所有ECMA标准中内置的所有类型，但是无法检测用户自定义类型。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">toString = Object.prototype.toString;</div><div class="line">toString.call(new Date);    // [object Date]</div><div class="line">toString.call(&apos;abc&apos;);  // [object String]</div><div class="line">toString.call(3);           // [object Number]</div><div class="line">toString.call([]);          // [object Array]</div><div class="line">toString.call(&#123;&#125;);          // [object Object]</div><div class="line">toString.call(undefined);   // [object Undefined]</div><div class="line">toString.call(null);        // [object Null]</div><div class="line">/*无法检测自定义类型*/</div><div class="line">function Animal()&#123;&#125;;</div><div class="line">var ani = new Animal();</div><div class="line">toString.call(ani);        // [object Object]</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="基本类型这里有点需要注意："><a href="#基本类型这里有点需要注意：" class="headerlink" title="基本类型这里有点需要注意："></a>基本类型这里有点需要注意：</h3><p>当基本字符串需要调用一个字符串对象才有的方法时，js会自动将基本字符串转化为字符串对象并且调用相应的方法。</p>
<p>ECMAScript中字符串是不可变的，一旦创建，值就不能改变。</p>
<p>看控制台的测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var str = &apos;kad&apos;;</div><div class="line">str[0] // &apos;k&apos;</div><div class="line">str[0] = &apos;a&apos;;</div><div class="line">str // &apos;kad&apos;</div></pre></td></tr></table></figure></p>
<p>咦？那为啥字符串拼接就可以修改啊<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str = &apos;k&apos;;</div><div class="line">str += &apos;ad&apos;;</div><div class="line">str // &apos;kad&apos;</div></pre></td></tr></table></figure></p>
<p>拼接过程实际是：创建一个新字符串，填充’k’和’ad’，然后销毁原来的字符串’k’和’ad’.在旧版本的浏览器中，拼接字符串速度很慢。</p>
<p>记得剑指offer上说提高时间效率中，就有不要多次用String的＋运算符来拼接字符串，因为会产生很多String的临时实例，造成空间和时间的浪费，更好的办法就是用StringBuffer的append方法来完成字符串的拼接。</p>
<p>那么JS中，现代浏览器已经解决了＋运算符拼接低效的问题(怎么解决的啊。。。)，还可以通过数组来实现字符串拼接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;k&apos;];</div><div class="line">arr.push(&apos;ad&apos;);</div><div class="line">arr.join(&apos;&apos;);// &apos;kad&apos;</div></pre></td></tr></table></figure>
<p>而且通过new String(‘kad’)这种方式创建的字符串，虽然类型是object，但是依然不可改变值。<code>Object.getOwnPropertyDescriptor(str, 0)</code>可以输出Object的属性类型，发现writable为false。</p>
<h2 id="基础类型和引用类型的存储："><a href="#基础类型和引用类型的存储：" class="headerlink" title="基础类型和引用类型的存储："></a>基础类型和引用类型的存储：</h2><p>基本类型就是保存在栈内存中的简单数据段，在内存中占有固定大小的空间，他们的值保存在栈空间中，按值访问。</p>
<p>而引用类型的对象，栈内存中存放该对象在堆内存中的访问地址（内存地址大小固定），由堆内存分配空间。当查询引用类型的变量时，先从栈中读取内存地址，然后通过地址找到堆中的值，也就是按引用访问。</p>
<h3 id="为什么会有栈内存和堆内存之分？"><a href="#为什么会有栈内存和堆内存之分？" class="headerlink" title="为什么会有栈内存和堆内存之分？"></a>为什么会有栈内存和堆内存之分？</h3><p>与垃圾回收机制有关，为了使程序运行时占用的内存最小。</p>
<p>每个函数执行时都会建立自己的内存栈，调用结束就释放内存。堆内存中的对象不会随着调用的结束而销毁，只有当一个对象没有任何引用变量引用时，系统的垃圾回收机制才会回收它。</p>
<h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><p>引用类型是在没有引用之后, 通过 v8 的 GC 自动回收, 值类型如果是处于闭包的情况下, 要等闭包没有引用才会被 GC 回收, 非闭包的情况下等待 v8 的新生代 (new space) 切换的时候回收。</p>
<p>垃圾收集机制的原理：找出那些不再继续使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔周期性地执行这一操作。</p>
<p>JS中最常用的垃圾收集方式是标记清除。销毁带标记的值并回收所占用的内存空间。</p>
<p>还有一种垃圾收集策略叫引用计数，跟踪记录每个值被引用的次数。但无法解决循环引用的问题。</p>
<blockquote>
<p>有关闭包的内存问题</p>
</blockquote>
<p>闭包是否一定会造成内存泄漏？不一定。</p>
<p>闭包在使用之后没有将其引用设为null，GC就会认为这部分资源还在使用，所以GC就不会对其进行回收。由于闭包的作用域链可能会很长，所以GC会认为这条作用域链还有可能会再次使用，所以整个链的资源都不会回收，这种情况引起的内存泄漏比不清除引用更严重。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var sG = &apos;Global Scope&apos;; // 全局变量资源</div><div class="line">function A()&#123;</div><div class="line">	var sA = &apos;Scope A&apos;; // 作用域链A中的资源</div><div class="line">	return function B()&#123;</div><div class="line">		var sB = &apos;Scope B&apos;; // 作用域链B中的资源</div><div class="line">		return function C()&#123;</div><div class="line">			var sC = &apos;Scope C&apos;; // 作用域链C中的资源</div><div class="line">			return function Closure()&#123;</div><div class="line">				console.log(sG); // 查找作用域链，对全局变量进行使用</div><div class="line">				console.log(sA); // 查找作用域链，对作用域链A中的sA进行使用</div><div class="line">				console.log(sB); // 查找作用域链，对作用域链B中的sB进行使用</div><div class="line">				console.log(sC); // 查找作用域链，对作用域链C中的sC进行使用</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var clo = A()()(); // 返回一个函数名为Closure的闭包</div><div class="line">clo(); // 使用闭包</div><div class="line">clo = null; // 如果不对其进行null处理，那这个闭包会一直包涵作用域链A、B、C，作用域中的资源sA、sB、sC就不会背GC回收。</div></pre></td></tr></table></figure>
<p>闭包引起的内存泄漏可以通过这个将变量设为null来解除对对象的引用，确保正常回收其占用的内存。</p>
<blockquote>
<p>面试题：局部变量与全局变量的存储</p>
</blockquote>
<p>全局变量存放在静态区(static)，程序运行开始时为其分配内存，程序运行结束后该内存才被释放。</p>
<p>局部变量存储在栈(stack)中，随函数调用被申请和释放。</p>
<h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><p>这个问题上，网上的说法不一，以红宝书的标准来: <strong>JS中所有函数的参数都是按值传递的</strong>。</p>
<p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量，用ECMAScript的概念来说就是arguments对象中的一个元素。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</p>
<h3 id="证明一下对象是按值传递的（准确的说是call-by-sharing）"><a href="#证明一下对象是按值传递的（准确的说是call-by-sharing）" class="headerlink" title="证明一下对象是按值传递的（准确的说是call-by-sharing）"></a>证明一下对象是按值传递的（准确的说是call-by-sharing）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function setName(obj)&#123;</div><div class="line">	obj.name = &apos;kad&apos;;</div><div class="line">	obj = &#123;name: &apos;lz&apos;&#125;;</div><div class="line">&#125;</div><div class="line">var person = new Object();</div><div class="line">setName(person);</div><div class="line">alert(person.name);// &apos;kad&apos;</div></pre></td></tr></table></figure>
<p>如果对象是按引用传递的，person应该被修改为指向name为’lz’的对象。实际上，在函数中重写obj时，这个变量引用的就是一个局部对象了，这个局部对象在函数执行完毕后立即被销毁。</p>
<p>那么，<strong>如何将值类型的变量以引用的方式传递：将基础类型包装成对象</strong>。</p>
<h2 id="再来说说引用类型的拷贝"><a href="#再来说说引用类型的拷贝" class="headerlink" title="再来说说引用类型的拷贝"></a>再来说说引用类型的拷贝</h2><p>这种直接赋值，obj1和obj2指向的是堆内存中的同一个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj1 = new Object();</div><div class="line">var obj2 = obj1;</div><div class="line">a === b // true</div></pre></td></tr></table></figure></p>
<h3 id="数组的深拷贝："><a href="#数组的深拷贝：" class="headerlink" title="数组的深拷贝："></a>数组的深拷贝：</h3><ol>
<li>newArr = oldArr.slice(0, oldArr.length);//第二个参数可省略</li>
<li>newArr = oldArr.concat();</li>
</ol>
<h3 id="对象的深拷贝"><a href="#对象的深拷贝" class="headerlink" title="对象的深拷贝"></a>对象的深拷贝</h3><ol>
<li><p>把对象属性遍历一遍赋给新对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function deepCopy(obj)&#123;</div><div class="line">	var newObj = &#123;&#125;;</div><div class="line">	for(key in obj)&#123;</div><div class="line">		newObj[key] = typeof obj[key] === &apos;Object&apos; ? deepCopy(obj[key]) : obj[key];</div><div class="line">	&#125;</div><div class="line">	return newObj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">Object.create()</a>，需要传入对象原型</p>
</li>
</ol>
<h2 id="关于引用，来看题："><a href="#关于引用，来看题：" class="headerlink" title="关于引用，来看题："></a>关于引用，来看题：</h2><blockquote>
<p>== 的 === 的区别</p>
<p>那么[1] == [1]的结果是什么</p>
</blockquote>
<p>应该是false，不要被自己对于 == 和 === 的结论影响然后得出错误的结论。因为是两个不同的对象在比较。</p>
<p>关于==类型转换记住是优先转数字，然后就很好理解true==’true’结果为false了。</p>
<p><img src="/2017/03/03/datatype/compare.png" alt="看到一张挺有意思的图，贴在这儿"></p>
<blockquote>
<p>面试题：JS中判断是否为数组</p>
</blockquote>
<ol>
<li><p>Array.isArray(arr)</p>
</li>
<li><p>arr instanceof Array</p>
</li>
<li><p><code>arr.__proto__.constructor === Array</code></p>
</li>
</ol>
<blockquote>
<p>说到引用，不可不提c++中指针和引用的区别，ps：C语言中没有引用：</p>
</blockquote>
<ol>
<li><p>指针是一个实体，引用只是个别名</p>
</li>
<li><p>引用只能在定义时初始化一次，之后引用所指向的内容不变；指针可变。</p>
</li>
<li><p>引用不能为空，指针可以为空。</p>
</li>
<li><p>sizeof引用拿到的事所指向变量的大小，而sizeof指针拿到的是指针本身(所指向变量的地址)的大小。</p>
</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" target="_blank" rel="external">call-by-sharing</a></p>
<p><a href="http://harttle.com/2015/09/18/js-type-checking.html" target="_blank" rel="external">判断JS变量类型</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BFC]]></title>
      <url>http://kad0108.github.io/2017/03/02/bfc/</url>
      <content type="html"><![CDATA[<h3 id="首先明确BFC是什么"><a href="#首先明确BFC是什么" class="headerlink" title="首先明确BFC是什么"></a>首先明确BFC是什么</h3><p>BFC(Block Formatting Context)就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。IE中是hasLayout</p>
<h3 id="然后什么情况会触发BFC："><a href="#然后什么情况会触发BFC：" class="headerlink" title="然后什么情况会触发BFC："></a>然后什么情况会触发BFC：</h3><ol>
<li><p>float的值不为none</p>
</li>
<li><p>overflow的值为auto,scroll或hidden</p>
</li>
<li><p>display的值为table-cell, table-caption, inline-block中的任何一个</p>
</li>
<li><p>position的值不为relative和static</p>
</li>
</ol>
<a id="more"></a>
<h3 id="然后通过例子来看BFC可以用来干嘛："><a href="#然后通过例子来看BFC可以用来干嘛：" class="headerlink" title="然后通过例子来看BFC可以用来干嘛："></a>然后通过例子来看BFC可以用来干嘛：</h3><p><strong>1. 防止margin重叠</strong></p>
<p>垂直的两个块级元素会发生margin重叠：兄弟元素或父子元素。水平方向的margin是不重叠的。</p>
<p>解决：触发下面元素的BFC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">p&#123;</div><div class="line">	width: 200px;</div><div class="line">	height: 200px;</div><div class="line">	background-color: pink;</div><div class="line">	margin: 100px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;p&gt;&lt;/p&gt;</div><div class="line">&lt;p style=&quot;float: left;&quot;&gt;&lt;/p&gt;</div><div class="line">或</div><div class="line">&lt;p&gt;&lt;/p&gt;</div><div class="line">&lt;p style=&quot;position: absolute;&quot;&gt;&lt;/p&gt;</div><div class="line">或</div><div class="line">&lt;p&gt;&lt;/p&gt;</div><div class="line">&lt;div style=&quot;overflow:hidden;&quot;&gt;</div><div class="line">	&lt;p&gt;&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">或</div><div class="line">&lt;p&gt;&lt;/p&gt;</div><div class="line">&lt;p style=&quot;display:inline-block;&quot;&gt;&lt;/p&gt;</div></pre></td></tr></table></figure></p>
<p><strong>2. 防止浮动元素的父元素高度塌陷，即清除浮动</strong></p>
<p>当一个父元素包含了多个浮动子元素时，子元素设置了宽高，父元素的宽度不会受影响，但是高度会塌陷</p>
<p>因为计算BFC的高度时，浮动元素的高度也参与计算，所以解决方案是触发父元素的BFC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.child&#123;</div><div class="line">	width: 100px;</div><div class="line">	height: 100px;</div><div class="line">	border: 6px solid purple;</div><div class="line">	float: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;parent&quot; style=&quot;overflow:hidden;&quot;&gt;</div><div class="line">	&lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">或</div><div class="line">其他几种BFC情况均可解决</div></pre></td></tr></table></figure>
<p><strong>3. 自适应两栏布局</strong></p>
<p>普通流布局的div和浮动元素做兄弟时是覆盖关系(文字会环绕)，但是将div做BFC化之后，会顺着浮动元素边缘形成自己的封闭的上下文。</p>
<p>调节下面demo中aside的宽度会发现main的宽度在自适应变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">.container&#123;</div><div class="line">	width: 400px;</div><div class="line">	height: 400px;</div><div class="line">&#125;</div><div class="line">.aside&#123;</div><div class="line">	float: left; /**/</div><div class="line">	width: 100px;</div><div class="line">	height: 100px;</div><div class="line">	background-color: pink;</div><div class="line">&#125;</div><div class="line">.main&#123;</div><div class="line">	overflow: hidden; /**/</div><div class="line">	background-color: lightgrey;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">	&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;main&quot;&gt;我就是为了撑开这个div的&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/" target="_blank" rel="external">CSS深入理解流体特性和BFC特性下多栏自适应布局</a></p>
<p><a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="external">BFC 神奇背后的原理</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Scope and Thread]]></title>
      <url>http://kad0108.github.io/2017/02/24/scope/</url>
      <content type="html"><![CDATA[<p>有关作用域和执行栈的几道题目，直接来看例子：</p>
<h3 id="例子一："><a href="#例子一：" class="headerlink" title="例子一："></a>例子一：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 10; i++)&#123;&#125;</div><div class="line">console.log(i);</div></pre></td></tr></table></figure>
<p>输出10，var声明的变量i在全局范围内都有效。</p>
<a id="more"></a>
<h3 id="例子二："><a href="#例子二：" class="headerlink" title="例子二："></a>例子二：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for(let i = 0; i &lt; 10; i++)&#123;&#125;</div><div class="line">console.log(i);</div></pre></td></tr></table></figure>
<p>会输出ReferenceError，因为let声明的变量i只在let所在代码块内有效。在循环体外引用就会出错。</p>
<p>注意声明了而没有赋值的变量才输出undefined。</p>
<h3 id="例子三："><a href="#例子三：" class="headerlink" title="例子三："></a>例子三：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 5; i++)&#123;</div><div class="line">	setTimeout(()=&gt;&#123;</div><div class="line">		console.log(&quot;one:&quot;, i);</div><div class="line">	&#125;, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出是<strong>5个5</strong>。</p>
<p>为什么出现这种情况？执行栈</p>
<h4 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h4><ol>
<li><p>匿名函数自执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 5; i++)&#123;</div><div class="line">	setTimeout((function()&#123;</div><div class="line">		console.log(i);</div><div class="line">	&#125;)(i), 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>闭包里返回匿名函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 5; i++)&#123;</div><div class="line">	setTimeout((function(i)&#123;</div><div class="line">		return function()&#123;</div><div class="line">			console.log(i);</div><div class="line">		&#125;</div><div class="line">	&#125;)(i), 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面这两种方法的思想都是要隔离作用域。我们都知道JS在ES6之前是没有块级作用域的，只有函数作用域，通过自执行函数来隔离变量作用域，我自己的理解就是让本次循环的i只在本次循环内作用。</p>
<h3 id="例子四："><a href="#例子四：" class="headerlink" title="例子四："></a>例子四：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(let i = 0; i &lt; 5; i++)&#123;</div><div class="line">	setTimeout(()=&gt;&#123;</div><div class="line">		console.log(i);</div><div class="line">	&#125;, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出是正常的0，1，2，3，4。因为i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量。</p>
<p>你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p>
<h3 id="例子五：promise与setTimeout"><a href="#例子五：promise与setTimeout" class="headerlink" title="例子五：promise与setTimeout"></a>例子五：promise与setTimeout</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">setTimeout(function()&#123;</div><div class="line">	console.log(0);</div><div class="line">&#125;, 0);</div><div class="line">console.log(1);</div><div class="line">new Promise(function executor(resolve)&#123;</div><div class="line">	console.log(2);</div><div class="line">	for(var i = 0; i &lt; 10000; i++)&#123;</div><div class="line">		i == 6666 &amp;&amp; console.log(3);</div><div class="line">		i == 9999 &amp;&amp; resolve();</div><div class="line">	&#125;</div><div class="line">	console.log(4);</div><div class="line">&#125;).then(function()&#123;</div><div class="line">	console.log(5);</div><div class="line">&#125;);</div><div class="line">console.log(6);</div></pre></td></tr></table></figure>
<p>输出： 1 2 3 4 6 5 0</p>
<p>其中异步事件注册顺序：setTimeout-&gt;promise.then</p>
<p>实际优先级关系：promise.then-&gt;setTimeout</p>
<h3 id="例子六：nextTick和setImmediate"><a href="#例子六：nextTick和setImmediate" class="headerlink" title="例子六：nextTick和setImmediate"></a>例子六：nextTick和setImmediate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">setImmediate(function()&#123;</div><div class="line">    console.log(1);</div><div class="line">&#125;,0);</div><div class="line">setTimeout(function()&#123;</div><div class="line">    console.log(2);</div><div class="line">&#125;,0);</div><div class="line">new Promise(function(resolve)&#123;</div><div class="line">    console.log(3);</div><div class="line">    resolve();</div><div class="line">    console.log(4);</div><div class="line">&#125;).then(function()&#123;</div><div class="line">    console.log(5);</div><div class="line">&#125;);</div><div class="line">console.log(6);</div><div class="line">process.nextTick(function()&#123;</div><div class="line">    console.log(7);</div><div class="line">&#125;);</div><div class="line">console.log(8);</div></pre></td></tr></table></figure>
<p>输出： 3 4 6 8 7 5 2 1</p>
<p>优先级关系：process.nextTick-&gt;promise.then-&gt;setTimeout-&gt;setImmediate</p>
<h3 id="有关执行任务"><a href="#有关执行任务" class="headerlink" title="有关执行任务"></a>有关执行任务</h3><p>任务分两类：microtask、macrotask</p>
<p>macrotask：script整体代码、setTimeout、setInterval、setImmediate、I/O</p>
<p>microtask：process.nextTick、Promises</p>
<p>执行顺序是：先执行一个macrotask，然后执行所有microtask任务，然后再执行macrotask，重复过程.</p>
<p>process.nextTick在当前执行栈尾部，下一次event loop(主线程读取任务队列)之前触发回调函数，setTimeout也是在下一次event loop调用。</p>
<h3 id="有关定时器的知识："><a href="#有关定时器的知识：" class="headerlink" title="有关定时器的知识："></a>有关定时器的知识：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setInterval(function()&#123;</div><div class="line">	</div><div class="line">&#125;, 150ms);</div></pre></td></tr></table></figure>
<p>第二个参数，一直以为是每次执行前需要等待的毫秒数，其实不是。这个参数表示它的代码会在150ms之后被加入到任务队列中。但是不管怎样它的执行都要等到主线程的所有同步任务执行完毕才能执行。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">event loop</a></p>
<p><a href="https://www.zhihu.com/question/36972010" target="_blank" rel="external">promise的队列和setTimeout的队列</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Cookie]]></title>
      <url>http://kad0108.github.io/2017/02/21/cookie/</url>
      <content type="html"><![CDATA[<h3 id="cookie的产生与使用"><a href="#cookie的产生与使用" class="headerlink" title="cookie的产生与使用"></a>cookie的产生与使用</h3><p>browser第一次请求server，server提供web页面，还附带一些键值对，也就是cookie。browser在本地存储cookie，之后每次请求和响应中都会来回发送cookie，仅限4k数据。</p>
<p>cookie与一个域相关联，而且只能发送给这个域。</p>
<p>cookie一般存储的是用户的登陆信息包括用户名、认证信息、登陆时间等，以便于下次免登陆，但一般不会将密码放在cookie中。</p>
<a id="more"></a>
<h3 id="HTTP协议是无状态的，为了保持用户会话状态使用什么技术方案弥补？"><a href="#HTTP协议是无状态的，为了保持用户会话状态使用什么技术方案弥补？" class="headerlink" title="HTTP协议是无状态的，为了保持用户会话状态使用什么技术方案弥补？"></a>HTTP协议是无状态的，为了保持用户会话状态使用什么技术方案弥补？</h3><p>常用的保持会话状态的方式有session、cookie、URL GET参数：</p>
<ol>
<li><p>cookie是保存在浏览器终端内存或磁盘上的一小块数据，只能保存字符串类型。所有cookie信息都随着浏览器的请求而发送。cookie分为持久cookie（数据保存在磁盘中）、会话cookie（保存在内存，浏览器关闭后被删除）。浏览器对单域下cookie的个数和每个key的长度都有限制。</p>
</li>
<li><p>session是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息。客户端需要接收、记忆和回送session的会话标识号，session通常是借助客户端的cookie来纪录会话标识。</p>
</li>
<li><p>GET参数是URL中的普通参数，GET方式是明文传输，其传送的数据量会有限制，不同浏览器支持的最大长度略有不同。</p>
</li>
</ol>
<p>要保持用户的会话状态，服务端在客户端第一次访问时自动创建一个session来存储客户端的信息，同时生成一个唯一的key发送给客户端。如果客户端没有禁用cookie，服务器会在客户端的cookie中写入一个key值，用户保存用户信息，之后每一次访问携带cookie给后端，服务器可以根据这个值判断用户的唯一性。如果用户禁用了cookie，则需要将验证信息写入URL中，所有的请求也需要携带这个参数，比如<code>http://a.com/b.html?session_id=auij123456789</code>，不携带则客户端会丢失会话状态。</p>
<h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><ol>
<li><p>cookie存储在客户端，session存储在服务器端</p>
</li>
<li><p>cookie存储<strong>编码</strong>后的字符串，session保存对象</p>
</li>
<li><p>session借助cookie才能工作，如果客户端禁用cookie，可以将验证信息写入URL，所有请求携带这个参数</p>
</li>
</ol>
<h3 id="浏览器端存储技术localStorage、sessionStorage、cookie区别"><a href="#浏览器端存储技术localStorage、sessionStorage、cookie区别" class="headerlink" title="浏览器端存储技术localStorage、sessionStorage、cookie区别"></a>浏览器端存储技术localStorage、sessionStorage、cookie区别</h3><p>cookie是存储在浏览器端，只有4k大小，并且随浏览器的请求一起发送到服务器端的，它有一定的过期时间，到了过期时间自动会消失。</p>
<p>sessionStorage和localeStorage也是存储在客户端的，同属于web Storage，比cookie的存储大小要大有5M，cookie只有4kb，localeStorage是持久化的存储在客户端，如果用户不手动清除的话，不会自动消失，会一直存在，sessionStorage也是存储在客户端，但是它的存活时间是在一个回话期间，只要浏览器的回话关闭了就会自动消失。localStorage在移动端会因为一些原因(比如内存不足等)会被清空。</p>
<p>cookie可以跨域读取，localStorage不允许跨域。读取同一份localStorage必须在相同的协议、主机、端口下。sessionStorage除了要在同域下，还需要在同一浏览器标签页下。</p>
<p>cookie的读取是通过document.cookie，读取到的字符串中存储方式是：<code>key=val;</code>。localStorage则直接以键值对的形式存储，值也必须是字符串，有setItem、getItem、removeItem、clear方法。</p>
<h3 id="cookie可设置属性"><a href="#cookie可设置属性" class="headerlink" title="cookie可设置属性"></a>cookie可设置属性</h3><p>domain属性：决定允许访问cookie的域名。</p>
<p>path属性：决定允许访问cookie的路径。同一服务器，URL中有和path相同的路径的页面都可以共享cookie。</p>
<p>expires属性：cookie过期时间。</p>
<p>secure属性：默认为空，使用HTTP传递数据。设置secure则使用HTTPS等安全协议传输。</p>
<p>HttpOnly属性：限制非HTTP方式的访问。</p>
<p>如果想让a.hello.com访问b.hello.com的cookie，可以将domain设为hello.com，并把path设为<code>/</code>。</p>
<h3 id="cookie的弊端"><a href="#cookie的弊端" class="headerlink" title="cookie的弊端"></a>cookie的弊端</h3><ol>
<li><p>数量和长度限制。</p>
</li>
<li><p>安全性。cookie被拦截后也不需要知道cookie的意义，原样转发就可达到目的。<a href="http://kadong.space/2017/03/11/ajax/#前端安全" target="_blank" rel="external">看这里有关前端安全的总结</a></p>
</li>
<li><p>用户可以禁用cookie，则cookie功能受限。</p>
</li>
</ol>
<h3 id="记住密码自动登录怎么实现？"><a href="#记住密码自动登录怎么实现？" class="headerlink" title="记住密码自动登录怎么实现？"></a>记住密码自动登录怎么实现？</h3><p>这里是我自己的理解，不一定正确。</p>
<p>登录时勾选了记住密码，则expires选项会附加到登录cookie中。如果未勾选，则不携带expires属性让cookie的寿命仅限本次会话，或者携带设置了一个过去的时间点的expires这样cookie会立刻被删除。</p>
<p>勾选自动登录则再携带一个自定义属性autologin。</p>
<h3 id="封装cookie的添加、删除、查询方法"><a href="#封装cookie的添加、删除、查询方法" class="headerlink" title="封装cookie的添加、删除、查询方法"></a>封装cookie的添加、删除、查询方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var CookieUtil = &#123;</div><div class="line">	setCookie: function(key, val, expiredays)&#123;</div><div class="line">		var exdate = new Date();</div><div class="line">		exdate.setDate(exdate.getDate() + expiredays);</div><div class="line">		document.cookie = key + &quot;=&quot; + escape(val) + ((expiredays == undefined) ? &quot;&quot; : &quot;;expires=&quot; + exdate.toGMTString());</div><div class="line">	&#125;,</div><div class="line">	getCookie: function(key)&#123;</div><div class="line">		var cookie = document.cookie;</div><div class="line">		var start = cookie.indexOf(key);</div><div class="line">		if(start != -1) return null;</div><div class="line">		var end = cookie.indexOf(&quot;;&quot;, start);</div><div class="line">		if(end == -1) end = cookie.length;</div><div class="line">		return escape(cookie.substring(start+key.length+1, end));</div><div class="line">	&#125;,</div><div class="line">	deleteCookie: function(key)&#123;</div><div class="line">		var val = this.getCookie(key);</div><div class="line">		if(val == null) return null;</div><div class="line">		this.setCookie(key, val, 0);//过期时间设为0，浏览器会马上自动删除cookie	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS Prototype]]></title>
      <url>http://kad0108.github.io/2017/02/20/prototype/</url>
      <content type="html"><![CDATA[<p>JS原型是前端面试时总会问到的知识点，这里具体总结一下。</p>
<p>缘于问题：<strong>对JS原型有什么了解，用原型创建对象和普通new一个对象的区别</strong>，下面具体说明创建对象的几种方法。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function person(name)&#123;</div><div class="line">	var o = new Object();</div><div class="line">	o.name = name;</div><div class="line">	return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p = person(&quot;kad&quot;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>工厂模式解决了使用Object一个接口创建很多对象产生大量重复代码的问题，但是无法识别对象类型。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Person(name)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.sayName = function()&#123;alert(this.name);&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person = new Person(&quot;kad&quot;);</div><div class="line">alert(person.constructor == Person); // true</div><div class="line">alert(person instanceof Person); // true</div></pre></td></tr></table></figure>
<p>构造函数以大写字母开头。对象的constructor属性用来识别对象类型。</p>
<p>但是构造函数的每个方法都要在每个实例上重新创建一遍。不同实例上的同名函数不相等。<code>person1.sayName != person2.sayName</code></p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line">Person.prototype.name = &quot;kad&quot;;</div><div class="line">Person.prototype.sayName = function()&#123;alert(this.name);&#125;</div><div class="line">var person = new Person();</div></pre></td></tr></table></figure>
<p>使用原型对象的好处是可以让所有对象实例共享原型对象所包含的属性和方法。<code>person1.sayName == person2.sayName</code></p>
<h2 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h2><p><img src="/2017/02/20/prototype/prototype.png" alt="原型对象"></p>
<p>从图中可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. Person.prototype.constructor == Person</div><div class="line"></div><div class="line">2. person.__proto__ == Person.prototype</div></pre></td></tr></table></figure>
<p><strong>isPrototypeOf()</strong>用来判断原型对象和实例之间的关系： <code>Person.prototype.isPrototypeOf(person)</code>。</p>
<p><strong>hasOwnProperty()</strong>检测实例自身的属性，会忽略从原型链上继承到的属性。</p>
<p><strong>delete</strong>操作符可以删除实例属性。</p>
<p><strong>in</strong>操作符用来判断实例是否含有某个属性，不管是不是本地属性。</p>
<h3 id="proto-是连接实例与构造函数的原型对象之间。"><a href="#proto-是连接实例与构造函数的原型对象之间。" class="headerlink" title="__proto__是连接实例与构造函数的原型对象之间。"></a><code>__proto__</code>是连接实例与构造函数的原型对象之间。</h3><blockquote>
<p><strong>new操作符做了什么</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function F()&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">var f = new F();</div></pre></td></tr></table></figure>
<p>new操作符的心路历程：</p>
<ol>
<li><p>新建一个对象 <code>f = new Object()</code></p>
</li>
<li><p>设置对象原型链 <code>f.__proto__ = F.prototype</code></p>
</li>
<li><p>改变构造函数内this的指向，让F中的this指向实例，执行F函数体 <code>F.call(f)</code></p>
</li>
</ol>
<h2 id="JS继承"><a href="#JS继承" class="headerlink" title="JS继承"></a>JS继承</h2><h3 id="原型链继承：将父类的实例作为子类的原型"><a href="#原型链继承：将父类的实例作为子类的原型" class="headerlink" title="原型链继承：将父类的实例作为子类的原型"></a>原型链继承：将父类的实例作为子类的原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Father(name)&#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;</div><div class="line">Father.prototype.sayName = function()&#123;</div><div class="line">	return this.name;</div><div class="line">&#125;</div><div class="line">function Child()&#123;&#125;</div><div class="line">Child.prototype = new Person(&quot;kad&quot;);</div><div class="line">var child = new Child();</div><div class="line">child.sayName();//&apos;kad&apos;</div></pre></td></tr></table></figure>
<p>缺点：所有子类共享父类实例，如果某个子类修改了父类，其他子类继承会出问题。在构造子类型实例时不能给父类传参。</p>
<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Parent(name)&#123;</div><div class="line">	console.log(this);</div><div class="line">	this.name = name;</div><div class="line">	this.sayName = function()&#123;</div><div class="line">		console.log(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">function Child(name)&#123;</div><div class="line">	this.parent = Parent;//此时Parent中的this指向的是Child，也就是把Parent中的属性和方法都给了Child</div><div class="line">	this.parent(name);</div><div class="line">	//这里直接delete this.parent也可以</div><div class="line">&#125;</div><div class="line">var child = new Child(&quot;kad&quot;);</div><div class="line">child.sayName(); //&apos;kad&apos;</div><div class="line">console.log(child); </div><div class="line">/**</div><div class="line">Child</div><div class="line">-name: &quot;kad&quot;</div><div class="line">-parent: Parent</div><div class="line">-sayName: ()</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>缺点：无法继承父类原型链上的属性和方法。</p>
<h3 id="call、apply实现继承"><a href="#call、apply实现继承" class="headerlink" title="call、apply实现继承"></a>call、apply实现继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function Parent(name)&#123;</div><div class="line">	console.log(this);</div><div class="line">	this.name = name;</div><div class="line">	this.sayName = function()&#123;</div><div class="line">		console.log(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">function Child(name)&#123;</div><div class="line">	Parent.call(this, name);</div><div class="line">&#125;</div><div class="line">var child = new Child(&quot;kad&quot;);</div><div class="line">child.sayName();//&apos;kad&apos;</div><div class="line">console.log(child);</div><div class="line">/**</div><div class="line">Child</div><div class="line">-name: &quot;kad&quot;</div><div class="line">sayName: ()</div><div class="line">*/</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>为什么子类的原型要指向父类的实例，而不直接指向父类的原型呢？</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">	this.name = &apos;kad&apos;;</div><div class="line">&#125;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Test()&#123;</div><div class="line">	this.name = &apos;test&apos;;</div><div class="line">&#125;</div><div class="line">Test.prototype = Person.prototype;</div><div class="line"></div><div class="line">Test.prototype.tt = function()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2017/02/20/prototype/prototype3.png" alt="看图说话"></p>
<p>可以看出，当子类的原型指向父类的原型时，子类就不是继承父类了，因为此时对子类原型的修改会反映到父类上。</p>
<h2 id="区别静态、私有、共享属性和方法"><a href="#区别静态、私有、共享属性和方法" class="headerlink" title="区别静态、私有、共享属性和方法"></a>区别静态、私有、共享属性和方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">	this.name = &quot;kad&quot;;</div><div class="line">	this.privFn = function()&#123;</div><div class="line">		console.log(&quot;I&apos;m private.&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">Person.staticFn = function()&#123;</div><div class="line">	console.log(&quot;I&apos;m static.&quot;);</div><div class="line">&#125;</div><div class="line">Person.prototype.shareFn = function()&#123;</div><div class="line">	console.log(&quot;I&apos;m public and shareable.&quot;);</div><div class="line">&#125;</div><div class="line">var p = new Person();</div><div class="line"></div><div class="line">function Stu()&#123;</div><div class="line">	this.name = &quot;student&quot;;</div><div class="line">&#125;</div><div class="line">Stu.prototype = new Person();</div><div class="line">var s = new Stu();</div></pre></td></tr></table></figure>
<p><img src="/2017/02/20/prototype/prototype2.png" alt="member"></p>
<p>区别静态属性/方法、私有属性/方法、共享属性/方法：</p>
<ol>
<li><p>静态属性/方法只能通过构造函数直接调用，即Person.staticFn()</p>
</li>
<li><p>私有属性/方法只能通过实例化调用，即p.privFn()</p>
</li>
<li><p>共享属性/方法可以通过原型对象调用，也可以实例化调用，即Person.prototype.shareFn()或p.shareFn()</p>
</li>
<li><p>私有属性/方法和共享属性/方法都可以被子对象继承，而静态属性/方法不可以被继承</p>
</li>
</ol>
<h2 id="改变函数内部this指针的指向"><a href="#改变函数内部this指针的指向" class="headerlink" title="改变函数内部this指针的指向"></a>改变函数内部this指针的指向</h2><p>总是挺难理解call和apply，来点自己的记忆方法。</p>
<blockquote>
<p>比如<code>fn.call(obj)</code>，obj说：hi，fn，把你的this借我用用（即把fn的this指向obj）。</p>
<p>再比如<code>fn.sayName.call(obj)</code>，obj说：hi，fn，把你的sayName借我用用（把sayName的this指向obj）。</p>
</blockquote>
<p>call方法应用于Function对象，测试了普通{}对象是不可以调用call的。</p>
<p>call返回什么：比如animal.sayname.call(cat);语句返回的是修改了sayName的this，执行cat.sayName()的结果。</p>
<p>call和apply的区别就只是第二个参数啦。bind的返回值是函数。</p>
<p>bind最常用的场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Fn()&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">Fn.prototype.click = function()&#123;&#125;</div><div class="line">Fn.prototype.init = function()&#123;</div><div class="line">	document.addEventListener(&apos;click&apos;, this.click.bind(this));//也就是在监听事件函数中的this指向了Fn</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>看下面的问题，加深对context上下文和this的理解</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var User = &#123;</div><div class="line">	count: 1,</div><div class="line">	getCount: function ()&#123;</div><div class="line">		console.log(this);</div><div class="line">		return this.count;		</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">console.log(User.getCount());//1</div><div class="line">var fn = User.getCount;</div><div class="line">console.log(fn());//undefined,此时fn的上下文是window</div></pre></td></tr></table></figure>
<p><strong>如何确保fn的上下文始终和User关联?</strong></p>
<p>正确答案是使用Function.prototype.bind</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var func = User.getCount.bind(User);  </div><div class="line">console.log(func());</div></pre></td></tr></table></figure>
<p>兼容老浏览器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Function.prototype.bind = Function.prototype.bind || function(context)&#123;</div><div class="line">	var self = this;</div><div class="line">	return function()&#123;</div><div class="line">		return self.apply(context, arguments);		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WebSocket]]></title>
      <url>http://kad0108.github.io/2017/02/15/websocket/</url>
      <content type="html"><![CDATA[<p><strong>WebSocket是Html5新增的协议，目的就是为了在浏览器和服务器之间建立不受限的双向通信通道，使得服务器能够主动向客户端发送数据。</strong></p>
<h2 id="传统的HTTP协议不能实现WebSocket的功能吗？"><a href="#传统的HTTP协议不能实现WebSocket的功能吗？" class="headerlink" title="传统的HTTP协议不能实现WebSocket的功能吗？"></a>传统的HTTP协议不能实现WebSocket的功能吗？</h2><p>HTTP是一个请求－响应协议，必须是浏览器向服务器发起请求，服务器才能响应这个请求，再把数据发送给客户端。也就是说浏览器不主动请求，服务器是没法主动发数据给浏览器的。</p>
<a id="more"></a>
<h3 id="轮询能实现啊"><a href="#轮询能实现啊" class="headerlink" title="轮询能实现啊"></a>轮询能实现啊</h3><p>ajax轮询的原理是启动一个定时器，固定间隔向服务器发起请求，问服务器是否有新信息。这种机制频繁请求会给服务器带来巨大的压力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">场景再现：</div><div class="line">C：有没有新信息？（Request）</div><div class="line">S：没有（Response）</div><div class="line">C：哎呀有没有新信息 （Request）</div><div class="line">S：没有了啦！（Response）</div><div class="line">－－－loop</div></pre></td></tr></table></figure>
<p>还有comet本质也是轮询，客户端在发起连接后，服务器没消息就一直不返回response，直到有消息才返回，返回之后客户端再建立起连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">场景再现：</div><div class="line">C：有没有消息？（Request）</div><div class="line">S：没有，等有的时候再给你。</div><div class="line">...</div><div class="line">S: 来，给你消息 (Response)</div><div class="line">－－－loop</div></pre></td></tr></table></figure>
<blockquote>
<p>如何判断用户是否是在网的状态，就可以采用轮询。也可以使用HTML5提供的navigator.onLine来判断设备是在线还是离线。</p>
</blockquote>
<h2 id="那WebSocket是怎么实现的啊"><a href="#那WebSocket是怎么实现的啊" class="headerlink" title="那WebSocket是怎么实现的啊"></a>那WebSocket是怎么实现的啊</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">场景再现：</div><div class="line">C：我要建立websocket协议，协议版本xx （Request）</div><div class="line">S：OK，已升级为WebSocket协议（HTTP Protocols Switched）</div><div class="line">C：麻烦你有信息的时候推送给我哈</div><div class="line">S：lalala</div><div class="line">S：我给你发送数据啦</div><div class="line">S：嗯，加油哦</div></pre></td></tr></table></figure>
<p>也就是经过一次HTTP请求，就可以源源不断发送信息啦</p>
<h3 id="WebSocket请求是什么样的呢？"><a href="#WebSocket请求是什么样的呢？" class="headerlink" title="WebSocket请求是什么样的呢？"></a>WebSocket请求是什么样的呢？</h3><p><img src="/2017/02/15/websocket/websocket.png" alt="websocket"></p>
<p>该请求和普通的HTTP请求有几点不同：</p>
<ol>
<li>GET请求的地址不是类似/path/，而是以ws://开头的地址；</li>
<li>请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；</li>
<li>Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；</li>
<li>Sec-WebSocket-Version指定了WebSocket的协议版本。</li>
</ol>
<p>响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。</p>
<p><a href="https://github.com/kad0108/Html5/tree/gh-pages/webSocket" target="_blank" rel="external">简易小demo看这里</a></p>
<h2 id="那HTTP不是也有keep-alive来实现长连接吗？"><a href="#那HTTP不是也有keep-alive来实现长连接吗？" class="headerlink" title="那HTTP不是也有keep-alive来实现长连接吗？"></a>那HTTP不是也有keep-alive来实现长连接吗？</h2><p>connection：keep-alive是指在一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发header。也就是除了真正的数据部分外，服务器和客户端还要大量交换 HTTP header，信息交换效率很低。</p>
<p>WebSocket 解决的第一个问题是，通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.zhihu.com/question/20215561" target="_blank" rel="external">websocket实现持久连接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP协议]]></title>
      <url>http://kad0108.github.io/2017/02/08/http/</url>
      <content type="html"><![CDATA[<p>从浏览器地址栏的请求链接开始，浏览器通过DNS解析查到域名映射的IP地址，然后浏览器端向此IP地址取得连接，成功连接之后，浏览器端将请求头信息通过HTTP协议向此IP地址所在服务器发起请求，服务器接受到请求后处理发回响应。浏览器从服务器接收到text/html类型的代码，浏览器开始显示此html。</p>
<p>HTTP是互联网上应用最广泛的一种网络协议，也是浏览器和服务器通信时所采用的协议。HTTP是基于TCP传输，<strong>无连接</strong>(每次连接只处理一个请求，响应后断开)，<strong>无状态</strong>(服务器不会保存客户的任何信息)的<strong>应用层</strong>协议。</p>
<h2 id="HTTP的报文格式"><a href="#HTTP的报文格式" class="headerlink" title="HTTP的报文格式"></a>HTTP的报文格式</h2><p>请求报文(从客户端发到服务器)</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;方法&gt;&lt;URL&gt;&lt;版本&gt;</div><div class="line">&lt;首部header&gt;</div><div class="line">&lt;主体body&gt;(可选)</div></pre></td></tr></table></figure>
<p>响应报文(从服务器发给客户端)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;版本&gt;&lt;状态码&gt;&lt;状态信息&gt;</div><div class="line">&lt;首部&gt;</div><div class="line">&lt;主体&gt;</div></pre></td></tr></table></figure>
<p>HTTP header字段包括通用头、请求头、响应头、实体头四个部分。</p>
<h3 id="请求方法中GET和POST的区别"><a href="#请求方法中GET和POST的区别" class="headerlink" title="请求方法中GET和POST的区别"></a>请求方法中GET和POST的区别</h3><table>
<thead>
<tr>
<th>GET用于获取资源</th>
<th style="text-align:center">POST用于发送数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>通过URL请求传输数据</td>
<td style="text-align:center">通过HTTP包的包体</td>
</tr>
<tr>
<td>受URL长度限制，只能传递约1024字节</td>
<td style="text-align:center">数据量大，可达2M</td>
</tr>
<tr>
<td>只支持ASCII字符</td>
<td style="text-align:center">支持标准字符集，可传递中文字符</td>
</tr>
<tr>
<td>get请求会缓存</td>
<td style="text-align:center">不缓存，每次刷新重新发送</td>
</tr>
<tr>
<td>url可见，不安全</td>
<td style="text-align:center">较get安全</td>
</tr>
</tbody>
</table>
<h3 id="POST提交数据的几种数据格式"><a href="#POST提交数据的几种数据格式" class="headerlink" title="POST提交数据的几种数据格式"></a>POST提交数据的几种数据格式</h3><p>POST提交的数据必须放在HTTP的body中，服务器端根据http header中的<strong>Content-Type</strong>字段来判断数据是用哪种编码方式编码的，然后进行解码。</p>
<h4 id="先看Form表单的enctype属性："><a href="#先看Form表单的enctype属性：" class="headerlink" title="先看Form表单的enctype属性："></a>先看Form表单的<strong>enctype</strong>属性：</h4><ol>
<li><p>默认编码方式发送前编码所有字符：<code>application/x-www-form-urlencoded</code></p>
</li>
<li><p>不对字符编码，在使用包含文件上传的表单时必须使用该值：<code>multipart/form-data</code></p>
</li>
<li><p>空格转换为+加号，不对特殊字符编码：<code>text/plain</code></p>
</li>
</ol>
<h4 id="Ajax以POST请求向服务器提交数据时，可以通过setRequestHeader设置头部属性Content-Type定义发送内容编码属性。"><a href="#Ajax以POST请求向服务器提交数据时，可以通过setRequestHeader设置头部属性Content-Type定义发送内容编码属性。" class="headerlink" title="Ajax以POST请求向服务器提交数据时，可以通过setRequestHeader设置头部属性Content-Type定义发送内容编码属性。"></a>Ajax以POST请求向服务器提交数据时，可以通过setRequestHeader设置头部属性Content-Type定义发送内容编码属性。</h4><ol>
<li><p><code>application/json</code>：json数据</p>
</li>
<li><p><code>application/xml</code>：根据xml头指定的编码格式进行编码。还有<code>text/xml</code>这种编码方式但是不推荐，因为<code>text/*</code>这种MIME类型有一个US-ASCII字符集，<code>text/xml</code>会忽略xml头指定的编码格式而默认采用US-ASCII编码。</p>
</li>
</ol>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><strong>1xx：临时响应（表示请求已接收，继续处理）</strong></p>
<p><strong>2xx：请求成功</strong></p>
<p>200 OK</p>
<p><strong>3xx：重定向</strong></p>
<p>302 Move temporarily</p>
<p>304 Not Modified</p>
<p><strong>4xx：客户端请求错误</strong></p>
<p>401 Unauthorized</p>
<p>403 Forbidden</p>
<p>404 Not Found</p>
<p><strong>5xx：服务器错误</strong></p>
<p>500 Internal Server Error</p>
<p>503 Service Unavailable</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>与HTTP协议紧密相关的还有HTTPS协议，它通过SSL和HTTP协议构建可进行加密传输、身份认证的网络协议，能防止数据在传输过程中被劫持或篡改。</p>
<table>
<thead>
<tr>
<th>HTTP</th>
<th style="text-align:center">HTTPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准端口80</td>
<td style="text-align:center">标准端口443</td>
</tr>
<tr>
<td>明文传输，不安全</td>
<td style="text-align:center">具有安全性的SSL加密传输协议</td>
</tr>
<tr>
<td>无需证书</td>
<td style="text-align:center">需要CA机构颁发的SSL证书</td>
</tr>
<tr>
<td>工作在应用层</td>
<td style="text-align:center">工作在传输层？</td>
</tr>
</tbody>
</table>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://imququ.com/post/four-ways-to-post-data-in-http.html" target="_blank" rel="external">四种常见的 POST 提交数据方式</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS伪协议]]></title>
      <url>http://kad0108.github.io/2017/02/05/jsprotocol/</url>
      <content type="html"><![CDATA[<p>总能看到网页上一些a标签的链接是<code>javascript:;</code>，点击之后页面并没有跳转。下面详细说明：</p>
<h2 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h2><p>伪协议不同于因特网上所真实存在的协议，如<code>http://，https://，ftp://</code>，伪协议是为关联应用程序而使用的，如:<code>tencent://(关联QQ)</code>，<code>mailto:kad108@foxmail.com(关联电脑中Email软件)</code>，还有就是<code>javascript:;</code>。</p>
<p><code>javascript:</code>这个特殊的协议类型声明了URL的主体是javascript代码，由javascript解释器执行。在浏览器打开<code>javascript:URL</code>的时候，它会先运行URL中的代码，当返回值不为undefined的时候，前页链接会替换为这段代码的返回值。可以在浏览器地址栏输入以下URL查看效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javascript:var now = new Date(); &quot;&lt;h1&gt;The time is:&lt;/h1&gt;&quot; + now;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="javascript-与javascript-void-0"><a href="#javascript-与javascript-void-0" class="headerlink" title="javascript:;与javascript:void(0)"></a>javascript:;与javascript:void(0)</h2><p><code>javascript:</code>是表示在触发<code>&lt;a&gt;</code>默认动作时，执行一段JavaScript代码，而 <code>javascript:;</code>表示什么都不执行，这样点击a标签时就没有任何反应。</p>
<p><code>javascript:void(0)</code>, 其中<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void" target="_blank" rel="external">void运算符</a>会对给定的表达式进行求值，然后直接返回 undefined。<code>javascript:;</code>也是返回undefined，所以两种方法是等价的。</p>
<h2 id="href的值为javascript-与-click-的区别"><a href="#href的值为javascript-与-click-的区别" class="headerlink" title="href的值为javascript: 与 click 的区别"></a>href的值为javascript: 与 click 的区别</h2><ol>
<li><p>定义的scope不同，前者是global，后者可以是任何作用域</p>
</li>
<li><p>执行的context不同，前者是window，后者是a元素本身</p>
</li>
<li><p>执行的时机不同，总是click事件先执行，href=”javascript:…”后执行，所以，只能在click事件里阻止默认行为的发生，却不能在href里阻止事件的执行。</p>
</li>
</ol>
<h2 id="再看看a标签的用法"><a href="#再看看a标签的用法" class="headerlink" title="再看看a标签的用法"></a>再看看a标签的用法</h2><p>有href属性的<code>&lt;a&gt;</code>标签才有<code>cursor：pointer;</code>的效果</p>
<ol>
<li><p>点击这个链接后，会让页面跳到页面顶部，在location.href后面增加#号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>如果页面里面有id为ele的元素，会执行锚点机制跳转到这个元素上缘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;#ele&quot;&gt;&lt;/a&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>页面不跳转：三种写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt;</div><div class="line">&lt;a href=&quot;javascript :void(0);&quot;&gt;&lt;/a&gt;</div><div class="line">&lt;a href=&quot;xxxx&quot; onclick=&quot;return false;&quot;&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[隐藏页面元素的几种方法]]></title>
      <url>http://kad0108.github.io/2017/01/28/hidedom/</url>
      <content type="html"><![CDATA[<h3 id="1-opacity"><a href="#1-opacity" class="headerlink" title="1. opacity"></a>1. opacity</h3><p>从视觉上隐藏元素，但元素依然占位，响应用户交互。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">opacity: 0;</div></pre></td></tr></table></figure>
<h3 id="2-position"><a href="#2-position" class="headerlink" title="2. position"></a>2. position</h3><p>将元素移出可视区域，不影响页面布局，还可以与用户交互。应用：用Dom模拟复选框和单选框，使用这个方法来隐藏真正的checkbox和radio元素来接收焦点切换。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">position: absolute;</div><div class="line">top: -1000px;</div><div class="line">left: -1000px;</div></pre></td></tr></table></figure>
<h3 id="3-clip-path"><a href="#3-clip-path" class="headerlink" title="3. clip-path"></a>3. clip-path</h3><p>clip-path可以裁剪以隐藏元素，对元素添加下面属性即可隐藏，元素依然占位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clip-path: polygon(0 0, 0 0, 0 0, 0 0);</div></pre></td></tr></table></figure>
<h3 id="4-visibility"><a href="#4-visibility" class="headerlink" title="4. visibility"></a>4. visibility</h3><p>隐藏元素占据空间，显示元素设置为visible，只触发repaint，不响应用户交互。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">visibility: hidden;</div></pre></td></tr></table></figure>
<h3 id="5-display"><a href="#5-display" class="headerlink" title="5. display"></a>5. display</h3><p>隐藏元素不占据空间，显示时浏览器需要根据样式定义来计算元素应该出现的位置，触发reflow(有时处于性能考虑尽量减少触发reflow)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">display: none</div></pre></td></tr></table></figure>
<h3 id="6-transform"><a href="#6-transform" class="headerlink" title="6. transform"></a>6. transform</h3><p>元素所在位置会被保留，该用法对行内元素不作用。有兼容性问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">transform: scale(0);</div></pre></td></tr></table></figure>
<h3 id="7-hidden"><a href="#7-hidden" class="headerlink" title="7. hidden"></a>7. hidden</h3><p>HTML5提供的属性，和<code>display:none;</code>效果相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div hidden&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="IE下隐藏元素"><a href="#IE下隐藏元素" class="headerlink" title="IE下隐藏元素"></a>IE下隐藏元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">filter:alpha(opacity=0);</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[完善博客功能]]></title>
      <url>http://kad0108.github.io/2017/01/26/build/</url>
      <content type="html"><![CDATA[<h2 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h2><p>使用Hexo搭建了静态博客，托管到了github上可通过<a href="https://kad0108.github.io/">kad0108.github.io</a>访问。然而GitHub 屏蔽了百度爬虫，GitHub Pages 中的内容无法被百度索引。</p>
<p>然后自己也申请了域名，下面是github绑定域名时间——————</p>
<ol>
<li><p>source文件夹中新建CNAME文件（无后缀名），首行添加域名，我的是<a href="http://kadong.space/" target="_blank" rel="external">kadong.space</a>，注意前面不加<code>http://或www</code>，然后使用<code>hexo g &amp;&amp; hexo d</code>部署。</p>
</li>
<li><p>在域名解析提供商，我的域名是在万网购买。步骤：进入工作台－》域名－》解析－》域名解析－》解析设置－》添加解析。</p>
</li>
</ol>
<a id="more"></a>
<p><img src="/2017/01/26/build/domain.png" alt="domain"></p>
<h2 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h2><p>Hexo评论模块支持Disqus, 多说和友言。</p>
<p><a href="http://duoshuo.com/create-site/" target="_blank" rel="external">创建多说站点</a>，然后后面<a href="http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9" target="_blank" rel="external">配置</a>会用到站点名称。</p>
<h2 id="留言板功能"><a href="#留言板功能" class="headerlink" title="留言板功能"></a>留言板功能</h2><p>参考<a href="http://blog.csdn.net/shenshanlaoyuan/article/details/52774473" target="_blank" rel="external">这里</a>，我把留言板功能和关于我页面集合在一起。</p>
<p>在多说控制台，修改多说CSS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#ds-recent-visitors .ds-avatar &#123;</div><div class="line">	display: inline;</div><div class="line">	padding: 0 !important;</div><div class="line">	margin: 4px !important;</div><div class="line">&#125;</div><div class="line">#ds-recent-visitors div img &#123;</div><div class="line">    display: inline-block !important;</div><div class="line">    width: 56px !important;</div><div class="line">    height: 56px !important;</div><div class="line">    border-radius: 50%;</div><div class="line">    border: 1px solid #ddd;</div><div class="line">    padding: 2px;</div><div class="line">    /* box-shadow: 1px 1px 1px rgba(0,0,0, .15); */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="音乐功能"><a href="#音乐功能" class="headerlink" title="音乐功能"></a>音乐功能</h2><p>使用网易云音乐，生成外链播放器，后续继续探索如何集成多个歌曲。</p>
<p><br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS布局模型之浮动模型]]></title>
      <url>http://kad0108.github.io/2017/01/25/float/</url>
      <content type="html"><![CDATA[<h2 id="CSS的基本布局模型："><a href="#CSS的基本布局模型：" class="headerlink" title="CSS的基本布局模型："></a>CSS的基本布局模型：</h2><h3 id="Flow-Model"><a href="#Flow-Model" class="headerlink" title="Flow Model"></a>Flow Model</h3><p>流模型是Html元素默认布局</p>
<ul>
<li>块级元素：垂直分布，宽度100%</li>
<li>内联元素：水平分布，不可设宽高</li>
</ul>
<a id="more"></a>
<h3 id="Layer-Model"><a href="#Layer-Model" class="headerlink" title="Layer Model"></a>Layer Model</h3><p>层模型有三种形式：</p>
<ul>
<li>绝对定位absolute</li>
<li>相对定位relative</li>
<li>固定定位fixed</li>
</ul>
<h3 id="Float-Model"><a href="#Float-Model" class="headerlink" title="Float Model"></a>Float Model</h3><p>今天的主要学习内容：浮动模型。</p>
<p>去查看了文档，说float这个属性本来是应用于图像，使文字围绕在图像周围。这里就有了疑问，既然一直说float会让元素脱离文档流，那为什么还会让占据空间挤开文字呢？</p>
<p>Q: 脱离文档流就不占据空间了吗？<br>A: 可以这么说。更准确地一点说，是一个元素脱离文档流（out of normal flow）之后，其他的元素在定位的时候会当做没看见它，两者位置重叠都是可以的。</p>
<p>Q: 脱离文档流是不是指该元素从dom树中脱离？<br>A: 不是，用浏览器的审查元素就可以看到脱离文档流的元素（例如被float了）依然会出现在dom树里</p>
<h2 id="下面是测试时间"><a href="#下面是测试时间" class="headerlink" title="下面是测试时间"></a>下面是测试时间</h2><h3 id="在正常的flow中是这样的："><a href="#在正常的flow中是这样的：" class="headerlink" title="在正常的flow中是这样的："></a>在正常的flow中是这样的：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;father&quot;&gt;</div><div class="line">	&lt;div class=&quot;child1&quot;&gt;child one&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;child2&quot;&gt;child two&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><img src="/2017/01/25/float/float1.png" alt="normal flow"></p>
<p>可以看到两个child div是垂直排列</p>
<h3 id="在对第一个child加上浮动后："><a href="#在对第一个child加上浮动后：" class="headerlink" title="在对第一个child加上浮动后："></a>在对第一个child加上浮动后：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;father&quot;&gt;</div><div class="line">	&lt;div class=&quot;child1 float&quot;&gt;child one&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;child2&quot;&gt;child two&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><img src="/2017/01/25/float/float2.png" alt="float"></p>
<p>第一个蓝色的child1 div脱离文档流，跟在后面的第二个橙色的child2 div无视浮动元素去定位，所以它们都顶着父元素的左边和顶部边框，而且浮动元素child1覆盖了child2，但是很奇怪的是child2中的文字却看到了这个浮动元素，飘到了child1的边上。<strong>这就是float的特性：其它盒子会无视浮动元素，但其他盒子内的文本仍然会为这个元素让出位置，环绕在其周围。</strong></p>
<h3 id="那么将child1改为绝对定位呢？"><a href="#那么将child1改为绝对定位呢？" class="headerlink" title="那么将child1改为绝对定位呢？"></a>那么将child1改为绝对定位呢？</h3><p><img src="/2017/01/25/float/float3.png" alt="absolute"></p>
<p>发现child2盒子以及它的文本内容都无视了child1的存在。这是脱离文档流时float和absolute的区别。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>脱离文档流，就是将元素从普通的布局中拿走，其他盒子在定位时会无视脱离文档流的元素进行定位。float布局会其他盒子内的文本依然会为这个元素让出位置，环绕在其周围。浮动元素会生成一个块级框，也就是display:block;而不论它本身是何种元素。而absolute定位则其他盒子及其内容都会无视它。</strong></p>
<h2 id="float的缺点-amp-清除浮动"><a href="#float的缺点-amp-清除浮动" class="headerlink" title="float的缺点 &amp; 清除浮动"></a>float的缺点 &amp; 清除浮动</h2><p>当一个父元素包含了多个浮动子元素时，子元素设置了宽高，父元素的宽度不会受影响，但是<strong>高度会塌陷</strong>，解决办法清除浮动。</p>
<p>清除浮动的本质就是<strong>触发元素的BFC</strong>，让容器中的子元素不会影响到外面的元素。触发元素BFC的情况看<a href="http://kadong.space/2017/03/02/bfc/" target="_blank" rel="external">这篇博文</a>总结。</p>
<h3 id="清除浮动的几种方法"><a href="#清除浮动的几种方法" class="headerlink" title="清除浮动的几种方法"></a>清除浮动的几种方法</h3><ul>
<li>在父元素上使用“:before”和“:after”两个伪元素。使用这些伪元素，我们可以在浮动元素的父容器前面和后面创建隐藏元素。“:before”伪元素是用来防止子元素顶部的外边距塌陷，使用“display: table”创建一个匿名的“table-cell”元素。这也确保在IE6和IE7下具有一致性。“:after”伪元素是用来防止子元素的底部的外边距塌陷，以及用来清除元素的浮动。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.father:before, .father:after &#123;</div><div class="line">	content:&quot;&quot;;</div><div class="line">	display:block;</div><div class="line">	clear:both;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;father&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<ul>
<li>在容器的结束标签前添加一个空标签，在空标签上直接设置样式“clear:both”。用这种方法来清除浮动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.clearfix &#123;</div><div class="line">	clear:both;</div><div class="line">	zoom:1; /* For IE 6/7 (trigger hasLayout) */</div><div class="line">&#125;</div><div class="line">&lt;div class=&quot;father&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><p><a href="https://www.zhihu.com/question/24529373/answer/29135021" target="_blank" rel="external">脱离文档流</a></p>
</li>
<li><p><a href="http://www.w3cplus.com/css/advanced-html-css-lesson2-detailed-css-positioning.html" target="_blank" rel="external">清除浮动</a></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://kad0108.github.io/2017/01/25/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
