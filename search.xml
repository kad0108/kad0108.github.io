<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[CSS布局]]></title>
      <url>http://kad0108.github.io/2017/03/24/layout/</url>
      <content type="html"><![CDATA[<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h3 id="文本的水平垂直居中"><a href="#文本的水平垂直居中" class="headerlink" title="文本的水平垂直居中"></a>文本的水平垂直居中</h3><p><code>text-align + line-height</code></p>
<h3 id="盒模型的水平垂直居中"><a href="#盒模型的水平垂直居中" class="headerlink" title="盒模型的水平垂直居中"></a>盒模型的水平垂直居中</h3><ol>
<li><p>绝对定位 + top:50%;left:50%; + margin-left,margin-top元素宽高的一半</p>
</li>
<li><p>弹性布局 <code>display:flex; + justify-content:center; + align-items:center;</code></p>
</li>
<li><p>表格布局 <code>display:table;text-align:center;</code> + <code>display:table-cell;vertical-align:middle;</code></p>
</li>
</ol>
<a id="more"></a>
<h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><p>左右两栏宽度固定，中间一栏自适应宽度。</p>
<p>实现三栏布局的几种方法：</p>
<h3 id="最古老的table的布局，三个td搞定"><a href="#最古老的table的布局，三个td搞定" class="headerlink" title="最古老的table的布局，三个td搞定"></a>最古老的table的布局，三个td搞定</h3><h3 id="float布局：middle必须放最后"><a href="#float布局：middle必须放最后" class="headerlink" title="float布局：middle必须放最后"></a>float布局：middle必须放最后</h3><p>middle如果放在right前，没有设置浮动，和right不在一个流中会把right挤下去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">html,body,div&#123;</div><div class="line">	height: 100%;</div><div class="line">&#125;</div><div class="line">.middle&#123;</div><div class="line">	margin: 0 200px;</div><div class="line">&#125;</div><div class="line">.left, .right&#123;</div><div class="line">	background-color: purple;</div><div class="line">	width: 200px;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">	float: left;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">	float: right;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="absolute布局：middle可以放中间"><a href="#absolute布局：middle可以放中间" class="headerlink" title="absolute布局：middle可以放中间"></a>absolute布局：middle可以放中间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">html,body,div&#123;</div><div class="line">	height: 100%;</div><div class="line">&#125;</div><div class="line">.middle&#123;</div><div class="line">	margin: 0 200px;</div><div class="line">&#125;</div><div class="line">.left, .right&#123;</div><div class="line">	background-color: purple;</div><div class="line">	width: 200px;</div><div class="line">	position: absolute;</div><div class="line">	top: 0;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">	left: 0;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">	right: 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="flex一维布局"><a href="#flex一维布局" class="headerlink" title="flex一维布局"></a>flex一维布局</h3><p>父元素设置flex布局，子元素中需要自适应宽度的设置flex:1;，通过order来实现对子元素排列顺序的控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">html,body,div&#123;</div><div class="line">	height: 100%;</div><div class="line">&#125;</div><div class="line">.container&#123;</div><div class="line">	display: flex;</div><div class="line">&#125;</div><div class="line">.middle&#123;</div><div class="line">	order: 2;</div><div class="line">	flex: 1;</div><div class="line">&#125;</div><div class="line">.left, .right&#123;</div><div class="line">	background-color: purple;</div><div class="line">	width: 200px;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">	order: 1;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">	order: 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">	&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h3 id="grid-目前仍然在W3C草案中的栅格二维布局，需要确定浏览器支持"><a href="#grid-目前仍然在W3C草案中的栅格二维布局，需要确定浏览器支持" class="headerlink" title="grid: 目前仍然在W3C草案中的栅格二维布局，需要确定浏览器支持"></a>grid: 目前仍然在W3C草案中的栅格二维布局，需要确定浏览器支持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">html,body,div&#123;</div><div class="line">	height: 100%;</div><div class="line">&#125;</div><div class="line">.container&#123;</div><div class="line">	display: grid;</div><div class="line">	grid-template-columns: 200px auto 200px;</div><div class="line">	grid-template-rows: 100%;</div><div class="line">&#125;</div><div class="line">.middle&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">.left, .right&#123;</div><div class="line">	background-color: purple;</div><div class="line">	width: 200px;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">	&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="两列布局"><a href="#两列布局" class="headerlink" title="两列布局"></a>两列布局</h2><p>左栏固定宽度，右栏自适应宽度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">html,body,div&#123;</div><div class="line">	height: 100%;</div><div class="line">&#125;</div><div class="line">.left&#123;</div><div class="line">	width: 200px;</div><div class="line">	float: left;</div><div class="line">&#125;</div><div class="line">.right&#123;</div><div class="line">	margin-left: 200px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>也可以触发右栏元素的BFC实现自适应，见<a href="http://kadong.space/2017/03/02/bfc/" target="_blank" rel="external">这篇博文</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.w3cplus.com/css/vertically-center-content-with-css" target="_blank" rel="external">CSS制作水平垂直居中对齐</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="external">Flex</a></p>
<p><a href="http://www.jackpu.com/san-lie-bu-ju-zuo-you-gu-ding-zhong-jian-lie-zi-gua-ying-tan-jiu/" target="_blank" rel="external">CSS Grid</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ajax和跨域总结]]></title>
      <url>http://kad0108.github.io/2017/03/11/ajax/</url>
      <content type="html"><![CDATA[<h2 id="Ajax-异步JS-XML"><a href="#Ajax-异步JS-XML" class="headerlink" title="Ajax = 异步JS + XML"></a>Ajax = 异步JS + XML</h2><p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新(不阻塞)。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<h3 id="创建XMLHttpRequest对象，用于和服务器交换数据"><a href="#创建XMLHttpRequest对象，用于和服务器交换数据" class="headerlink" title="创建XMLHttpRequest对象，用于和服务器交换数据"></a>创建XMLHttpRequest对象，用于和服务器交换数据</h3><p>浏览器兼容写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var xhr;</div><div class="line">if(window.XMLHttpRequest)&#123;</div><div class="line">	xhr = new XMLHttpRequest();</div><div class="line">&#125;eles if(window.ActiveXObject)&#123;</div><div class="line">	// code for IE5,IE6</div><div class="line">	xhr = new ActiveXObject(Microsoft.XMLHTTP);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="向服务器发起请求："><a href="#向服务器发起请求：" class="headerlink" title="向服务器发起请求："></a>向服务器发起请求：</h3><p><strong>GET or POST?</strong></p>
<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求：</p>
<ol>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ol>
<p><strong>GET请求</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xhr.open(&quot;GET&quot;, url, true);</div><div class="line">xhr.send(null);</div></pre></td></tr></table></figure>
<p>为避免获取到的缓存结果，可以向url添加一个唯一的ID：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.open(&quot;GET&quot;,&quot;demo_get.asp?t=&quot; + Math.random(),true);</div></pre></td></tr></table></figure></p>
<p>通过 GET 方法发送信息，请向 URL 添加信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.open(&quot;GET&quot;,&quot;demo_get2.asp?fname=Bill&amp;lname=Gates&quot;,true);</div></pre></td></tr></table></figure></p>
<p><strong>POST请求</strong></p>
<p>需要使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定希望发送的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.asp&quot;,true);</div><div class="line">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//提交时的内容类型</div><div class="line">xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;);</div></pre></td></tr></table></figure></p>
<h3 id="发送XHR请求时，会发送的HTTP头部信息："><a href="#发送XHR请求时，会发送的HTTP头部信息：" class="headerlink" title="发送XHR请求时，会发送的HTTP头部信息："></a>发送XHR请求时，会发送的HTTP头部信息：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Accept：浏览器能够处理的内容类型</div><div class="line">Accept-Charset：浏览器能够显示的字符集</div><div class="line">Accept-Encoding：浏览器能够处理的压缩编码</div><div class="line">Accept-Language：浏览器当前设置的语言</div><div class="line">Connection：浏览器与服务器之间连接的类型</div><div class="line">Cookie：缓存</div><div class="line">Host：发出请求的页面所在的域</div><div class="line">Referer：发出请求的页面的URI</div><div class="line">User-Agent：浏览器的用户代理字符串</div></pre></td></tr></table></figure>
<p><img src="/2017/03/11/ajax/ajaxheader.png" alt="ajax http header"></p>
<p>使用setRequestHeader()可以设置自定义的请求头部信息。要成功发送请求头部信息，必须在open方法之后和send方法之前调用。</p>
<h3 id="服务器响应："><a href="#服务器响应：" class="headerlink" title="服务器响应："></a>服务器响应：</h3><p>responseText：获得字符串形式的响应数据。<br>responseXML：获得 XML 形式的响应数据</p>
<h3 id="原生JS写Ajax"><a href="#原生JS写Ajax" class="headerlink" title="原生JS写Ajax"></a>原生JS写Ajax</h3><p>XMLHttpRequest Level 1 的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var url = &apos;xx.json&apos;;</div><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.onreadystatechange = function()&#123;</div><div class="line">	if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</div><div class="line">		console.log(xhr.responseText);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">xhr.open(&quot;GET&quot;, url);</div><div class="line">xhr.send(null);</div></pre></td></tr></table></figure></p>
<p>XMLHTTPRequest Level 2 的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var url = &apos;xx.json&apos;;</div><div class="line">var xhr = new XMLHttpRequest();</div><div class="line"></div><div class="line">xhr.open(&apos;GET&apos;, url);</div><div class="line">xhr.send(null);</div><div class="line"></div><div class="line">xhr.onload = function()&#123;</div><div class="line">	if(xhr.status == 200 || xhr.status == 304)&#123;</div><div class="line">		console.log(JSON.parse(xhr.responseText));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>老版本缺点：</strong></p>
<ol>
<li>只支持文本数据的传送，无法用来读取和上传二进制文件。</li>
<li>传送和接收数据时，没有进度信息，只能提示有没有完成。</li>
<li>受到”同域限制”（Same Origin Policy），只能向同一域名的服务器请求数据。</li>
</ol>
<p><strong>XMLHttpRequest Level 2新版本的功能：</strong></p>
<ol>
<li>可以设置HTTP请求的时限，xhr.timeout，xhr.ontimeout。</li>
<li>可以使用FormData对象管理表单数据，xhr.send(new FormData(form))。</li>
<li>可以上传文件, formData.append(‘files[]’, files[i])。</li>
<li>可以请求不同域名下的数据（跨域请求）,CORS，使用跨域资源共享的前提是浏览器支持且服务器同意。</li>
<li>可以获取服务器端的二进制数据。</li>
<li>可以获得数据传输的进度信息，xhr.onprogress。</li>
</ol>
<blockquote>
<p>面试题：Ajax实现分页，分页切换url不变，现在想实现点击浏览器后退按钮回退到前一页而不是上一个链接</p>
</blockquote>
<p>可以采用“地址栏加hash”技术来解决。只要改变锚点内容（‘#’后的），浏览器就认为URL变化，也就会放入浏览历史，这样前进后退问题就解决了。我们只要把不同的AJAX状态通过不同的hash写到地址栏就可以了，当页面加载的时候检测是否有hash值，有的话就读取hash进行相应的ajax还原操作。location.hash可以取到或者设置hash的值，当hash改变的时候window.onhashchange事件会被触发。</p>
<h3 id="JQuery的Ajax使用"><a href="#JQuery的Ajax使用" class="headerlink" title="JQuery的Ajax使用"></a>JQuery的Ajax使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">	url: &apos;./data.json&apos;,</div><div class="line">	type: &apos;GET&apos;,</div><div class="line">	aysnc: true,</div><div class="line">	data: &#123;//发送给服务器的数据</div><div class="line"></div><div class="line">	&#125;,</div><div class="line">	timeout: 5000, //超时</div><div class="line">	dataType: &apos;json&apos;, //服务器返回的数据格式</div><div class="line"></div><div class="line">	beforeSend:function(xhr)&#123;</div><div class="line">        //发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头</div><div class="line">    &#125;,</div><div class="line">	success: function(data, textStatus)&#123;</div><div class="line">		//根据 dataType 参数进行处理后的服务器返回数据</div><div class="line">	&#125;,</div><div class="line">	error: function()&#123;</div><div class="line">		//请求出错处理</div><div class="line">	&#125;,</div><div class="line">	complete:function()&#123;</div><div class="line">        //请求完成之后调用这个函数，无论成功或失败</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>jquery调用ajax中文乱码的问题，提交前用encode对数据进行编码，后台接收处对数据进行解码。</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>跨域是指在通过JS不同域之间进行数据传输或通信。只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p>
<h3 id="CORS-Cross-Origin-Resource-Sharing-跨域资源共享"><a href="#CORS-Cross-Origin-Resource-Sharing-跨域资源共享" class="headerlink" title="CORS(Cross-Origin Resource Sharing, 跨域资源共享)"></a>CORS(Cross-Origin Resource Sharing, 跨域资源共享)</h3><p>CORS的基本思想是使用自定义的HTTP头部让浏览器和服务器进行沟通。</p>
<p>发起请求时添加额外的Origin头部，包含和请求页面的源信息，服务器根据这个头部信息决定是否给予响应，就在Access-Control-Allow-Origin头部中返回相同的源信息。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Origin：http://www.abc.com</div><div class="line">Access-Control-Allow-Origin: http://www.abc.com</div></pre></td></tr></table></figure></p>
<p>注意，请求和响应都不包含cookie信息。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>通过script标签引入的js是不受同源策略的限制的，其实凡是带有src这个属性的标签都拥有跨域的能力，如script、img、iframe。</p>
<p>JSONP是使用script元素获取JSON数据包装在一个回调函数中操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function handle(response)&#123;</div><div class="line">	console.log(response.data);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var script = document.createElement(&apos;script&apos;);</div><div class="line">script.src = &apos;http://abc.com/json/?callback=handle&apos;;</div><div class="line">document.body.insertBefore(script, document.body.firstChild);</div></pre></td></tr></table></figure>
<p>JSONP的缺点：无法确定其他域是否安全，无法确定JSONP请求是否失败。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。</p>
<p>JSONP的优势：在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>比如两个页面地址分别为<code>x.abc.com</code>和<code>y.abc.com</code>，明显不同域，可以将两个页面的<code>document.domain</code>设为相同的域名<code>abc.com</code>，而且也只能设置为更高一级的父域，且<strong>主域必须相同</strong>。</p>
<p>不同域之间能够获得彼此的window对象，但不能获取window的属性和方法。通过修改两个页面的document.domain，就可以在父页面中操作它里面的iframe的window对象(contentWindow)。</p>
<p>修改document.domain的方法只适用于不同子域的框架间的交互.</p>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>在每个窗口window的生命周期内，窗口载入的所有页面都是共享一个window.name的，每个页面都对window.name有读写的权限。window.name是持久存在在一个窗口载入过的所有页面中，并不会因为新页面的载入而重置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//a.html</div><div class="line">window.name = &apos;data from a.html&apos;;</div><div class="line">window.location = &apos;b.html&apos;;</div><div class="line"></div><div class="line">//b.html</div><div class="line">console.log(window.name);//&apos;data from a.html&apos;</div></pre></td></tr></table></figure>
<h3 id="HTML5-PostMessage"><a href="#HTML5-PostMessage" class="headerlink" title="HTML5 PostMessage"></a>HTML5 PostMessage</h3><p>postMessage用于两个窗口iframe之间交换数据。两个窗口能通信的前提是：一个窗口以iframe的形式存在于另一个窗口中(MessageEvent.source获取源窗口)，或者一个窗口是从另一个窗口通过window.open()或超链接形式打开的(同样可以用window.opener获取源窗口)。也就是说要想交换数据，必须能获取目标窗口的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// origin1</div><div class="line">window.frames[0].postMessage(message, origin2URL);</div><div class="line">window.onmessage = function(e)&#123;</div><div class="line">	console.log(e.data);// MessageEvent</div><div class="line">&#125;</div><div class="line">// origin2: iframe in origin1</div><div class="line">window.onmessage = function(e)&#123;</div><div class="line">	if(e.source != window.parent) return;// 判断数据发送方</div><div class="line">	console.log(e.data);</div><div class="line">	e.source.postMessage(message, e.origin);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/kad0108/Html5/tree/gh-pages/postMessage" target="_blank" rel="external">demo看这里</a></p>
<blockquote>
<p>如果需要传输的数据很大，用HTTP GET请求肯定不行，而且需要兼容浏览器，应该怎么跨域？</p>
</blockquote>
<p>使用POST请求，通过表单提交，action指向post请求的地方，提交表单会马上刷新页面，target可以指定刷新页面，写个iframe让target指向这个iframe。</p>
<h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><h3 id="XSS-Cross-Site-Scripting"><a href="#XSS-Cross-Site-Scripting" class="headerlink" title="XSS(Cross Site Scripting)"></a>XSS(Cross Site Scripting)</h3><p>XSS跨站脚本攻击：攻击者向web页面插入恶意脚本代码<code>&lt;script&gt;&lt;/script&gt;</code>来攻击用户。</p>
<p>XSS防御：对输入(和URL参数)进行过滤，对输出进行html编码。特殊字符过滤，如：<code>&lt;</code>,<code>&gt;</code>,<code>&amp;</code>,JS伪协议。</p>
<h3 id="CSRF-Cross-Site-Request-Forgery"><a href="#CSRF-Cross-Site-Request-Forgery" class="headerlink" title="CSRF(Cross Site Request Forgery)"></a>CSRF(Cross Site Request Forgery)</h3><p>CSRF跨站请求伪造：通过伪造来自受信任用户的请求来利用受信任的网站。</p>
<p><strong>CSRF原理：</strong></p>
<p>通过例子来说明，用户访问并登录银行网站，用户在未登出银行网站的情况下访问了危险网站(可以通过广告等诱使用户访问)，用户在访问这个危险网站同时，向银行发起一个转账请求，这个请求会携带着用户的cookie走了。这个请求因为是用户发起的并且携带了认证信息，所以请求会成功响应。所以，CSRF攻击是hacker借助受害者的cookie骗取服务器的信任，但hacker是打死都拿不到也无法读取cookie的，而且服务器返回的结果由于浏览器同源策略的限制，hacker也无法拿到。</p>
<p><strong>CSRF防御：</strong></p>
<ol>
<li><p>检查HTTP头部Referer(从哪个页面链接过来)</p>
</li>
<li><p>检查token(服务器不存储用户登录状态，只需验证token是否合法)</p>
</li>
<li><p>通过验证码来检测用户提交</p>
</li>
<li><p>使用定制的HTTP报头</p>
</li>
<li><p>严格设置cookie的域</p>
</li>
</ol>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>Ajax是无需刷新页面就能够从服务器取得数据的一种方法，核心对象是XMLHttpRequest对象。</p>
<p>同源策略是对XHR的一个主要约束，它为通信设置了”相同的域、相同的端口、相同的协议”这一限制。试图访问上述限制之外的资源都会引发安全错误，除非采用被认可的跨域解决方案，这个方案叫做CORS。</p>
<p>Comet是对Ajax的扩展，让服务器能够实时向客户端推送数据。实现Comet的手段主要有：长轮询和HTTP流。</p>
<p>WebSockets是一种与服务器进行全双工、双向通信的信道。与其他方案不同，websockets不使用HTTP协议，而使用自定义的协议，专门为快速传输小数据设计。</p>
<p>JS跨域请求方式有：CORS、JSONP、修改<code>document.domain</code>跨子域、<code>window.name</code>、<code>HTML5 window.postMessage</code>.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="external">XMLHttpRequest Level 2 使用指南</a><br><a href="https://developer.mozilla.org/cn/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest" target="_blank" rel="external">Using XMLHttpRequest</a><br><a href="http://www.jquery123.com/jQuery.ajax/" target="_blank" rel="external">jQuert.ajax()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">HTTP访问控制(CORS)</a><br><a href="https://segmentfault.com/a/1190000000718840" target="_blank" rel="external">详解js跨域问题</a><br><a href="http://www.cnblogs.com/zichi/p/4638096.html" target="_blank" rel="external">HTML5 PostMessage</a><br><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/" target="_blank" rel="external">CSRF 攻击</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[输入URL到页面加载完成这个过程中都发生了什么]]></title>
      <url>http://kad0108.github.io/2017/03/09/url/</url>
      <content type="html"><![CDATA[<p><strong>过程大致分为网络通信和页面渲染：</strong></p>
<ol>
<li><p>DNS解析：根据输入域名查找对应的IP地址</p>
</li>
<li><p>TCP三次握手：浏览器向服务器发起TCP连接</p>
</li>
<li><p>握手成功后浏览器向服务器发起HTTP请求</p>
</li>
<li><p>服务器接收到请求，将数据返回给浏览器</p>
</li>
<li><p>浏览器下载HTML文档(响应报头，状态码200)，同时设置缓存，返回304则表示有缓存直接用缓存</p>
</li>
<li><p>浏览器解析渲染页面。</p>
</li>
<li><p>TCP四次挥手断开连接</p>
</li>
</ol>
<a id="more"></a>
<h2 id="DNS：应用层协议"><a href="#DNS：应用层协议" class="headerlink" title="DNS：应用层协议"></a>DNS：应用层协议</h2><p>DNS默认使用UDP协议，因为不需要TCP三次握手，传输速度快而且响应快。</p>
<h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><p><strong>浏览器缓存 -&gt; 操作系统DNS缓存 -&gt; 操作系统hosts文件 -&gt; 本地DNS服务器</strong></p>
<p>到本地DNS服务器一般有80%的域名解析成功了，如果没解析就会向根DNS服务器等顶级域名服务器发起迭代DNS解析请求。</p>
<p>实际情况中，主机到本地DNS采用递归查询，DNS服务器之间采用迭代查询。</p>
<p>DNS解析为什么设置成这种形式？分布式分层次的DNS解析可以覆盖所有域名系统，本地DNS缓存是为了加快速度。</p>
<p>后端原来是ip为a的服务器，现在换到b了，你拿到了错误的域名解析ip地址会怎么样？出现域名解析错误，可以清除本地DNS缓存。</p>
<h3 id="常见的DNS攻击"><a href="#常见的DNS攻击" class="headerlink" title="常见的DNS攻击"></a>常见的DNS攻击</h3><ol>
<li><p>域名劫持：黑客控制域名管理邮箱密码，将该域名的记录指向黑客可控制的DNS服务器，使用户访问该域名时，进入黑客指向的内容。</p>
</li>
<li><p>缓存投毒：控制DNS缓存服务器，将错误域名记录存入缓存中，将本来访问某网站的用户带到黑客指向的网站。</p>
</li>
<li><p>DDOS攻击：攻击者向DNS服务器发送大量请求占用网络资源，使合法DNS请求得不到响应。</p>
</li>
<li><p>DNS欺骗：攻击者冒充域名服务器</p>
</li>
</ol>
<h2 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h2><p>TCP是传输层协议，UDP也是。</p>
<h3 id="三次握手的过程："><a href="#三次握手的过程：" class="headerlink" title="三次握手的过程："></a>三次握手的过程：</h3><ol>
<li>客户端先发送一个带有SYN标志的报文给服务端</li>
<li>服务端收到SYN报文后，传回一个带有SYN/ACK标志的报文以示传达确认信息。</li>
<li>客户端收到后再发送一个带有ACK标志的报文段给服务端以示握手成功。</li>
</ol>
<h3 id="需要三次握手的主要原因是："><a href="#需要三次握手的主要原因是：" class="headerlink" title="需要三次握手的主要原因是："></a>需要三次握手的主要原因是：</h3><p>TCP是双通道连接，即client和server都需要互相通信，并且双方都需要初始化自身的序列号，并且让对方确认自身的序列号。</p>
<p>为了互相通信，因此第一次握手是client向server发送自身的初始序列号，同时需要server回复确认此序列号，<br>另一方面server也需要发送自身的序列号，并且需要client确认自身的序列号，因此第二次握手把server向client确认client的序列号和server向client发送server自身的序列号两个过程合并了，第三次握手即是client确认了server的序列号。</p>
<p>少于三次握手都不能使双方对对方的序列号进行确认。</p>
<h2 id="浏览器页面渲染"><a href="#浏览器页面渲染" class="headerlink" title="浏览器页面渲染"></a>浏览器页面渲染</h2><p>最终决定浏览器表现出来的页面效果的差异是：渲染引擎 Rendering Engine，也就是我们通常所说的“浏览器内核”，负责解析网页语法（如HTML、JavaScript）并渲染、展示网页。</p>
<h3 id="加载页面时浏览器的具体工作流程是："><a href="#加载页面时浏览器的具体工作流程是：" class="headerlink" title="加载页面时浏览器的具体工作流程是："></a>加载页面时浏览器的具体工作流程是：</h3><ol>
<li><p>解析HTML，转换树中的标签到DOM节点，构建DOM。</p>
</li>
<li><p>解析CSS，构建CSSOM。</p>
</li>
<li><p>结合DOM和CSSOM，构建Render Tree。</p>
</li>
<li><p>布局Layout渲染Paint过程，计算元素大小、位置。这里也就涉及到了repaint和reflow的概念。</p>
</li>
</ol>
<h2 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h2><p>由于TCP连接是全双工的，因此每个方向都必须<strong>单独进行关闭</strong>。客户端或服务器均可主动发起挥手动作。</p>
<h3 id="四次挥手的过程："><a href="#四次挥手的过程：" class="headerlink" title="四次挥手的过程："></a>四次挥手的过程：</h3><ol>
<li><p>客户端发送FIN，来关闭客户端到服务端的数据传送</p>
</li>
<li><p>服务端接受到这个FIN，回复确认ACK报文。</p>
</li>
<li><p>服务端关闭与客户端的连接，发送FIN给客户端。</p>
</li>
<li><p>客户端回复ACK确认。</p>
</li>
</ol>
<p>当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。</p>
<p><img src="/2017/03/09/url/url.png" alt="网上找到一张过程很详细的图"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.williamlong.info/archives/3813.html" target="_blank" rel="external">DNS攻击原理与防范</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端性能优化]]></title>
      <url>http://kad0108.github.io/2017/03/08/optimize/</url>
      <content type="html"><![CDATA[<p>前端性能优化，目的是为什么？让用户有更友好的体验，让服务商节省可观的资源。</p>
<p>对优化方向进行分类，直接来看表：</p>
<table>
<thead>
<tr>
<th>优化方向</th>
<th style="text-align:center">优化手段</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求数量</td>
<td style="text-align:center">CSS Sprites，合并脚本和样式表</td>
</tr>
<tr>
<td>请求带宽</td>
<td style="text-align:center">使用Gzip压缩传输文件，精简JS文件</td>
</tr>
<tr>
<td>缓存利用</td>
<td style="text-align:center">使用http缓存，使用CDN，ajax，减少DNS查找</td>
</tr>
<tr>
<td>页面结构</td>
<td style="text-align:center">样式表放顶部，脚本放底部</td>
</tr>
<tr>
<td>代码校验</td>
<td style="text-align:center">避免CSS表达式，避免重定向</td>
</tr>
<tr>
<td>减少Repaint和Reflow</td>
<td style="text-align:center">设置class，脱离文档流，减少dom操作</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>下面具体解释其中一些优化点：</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>Content Delivery Network 即内容分发网络，CDN把<strong>内容分发</strong>到距离用户近的缓存服务器，然后DNS托管(把DNS解析的地址改成CDN提供的)，DNS服务器根据用户IP地址，将域名解析成相应节点的缓存服务器IP地址，实现<strong>用户就近访问</strong>，提高网站渲染速度和性能。</p>
<h3 id="减少repaint和reflow"><a href="#减少repaint和reflow" class="headerlink" title="减少repaint和reflow"></a>减少repaint和reflow</h3><p><a href="http://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/" target="_blank" rel="external">回流与重绘</a></p>
<ol>
<li><p>通过设置class的方式，而不是多次修改元素style属性。</p>
</li>
<li><p>有动画效果的元素可以将position属性设为fixed或absolute。</p>
</li>
<li><p>权衡速度的平滑性，函数节流（自己的理解）</p>
</li>
<li><p>减少对DOM元素的查询和修改，查询时可将其赋值给局部变量。</p>
</li>
</ol>
<h3 id="CSS引用"><a href="#CSS引用" class="headerlink" title="CSS引用"></a>CSS引用</h3><p>尽量使用link代替@import，因为link是在页面加载时同时加载，import是等页面加载完再加载。</p>
<h2 id="有关缓存"><a href="#有关缓存" class="headerlink" title="有关缓存"></a>有关缓存</h2><h3 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h3><p>缓存可以减少响应延迟，减少网络带宽消耗。http header中与缓存控制相关的头部有：Cache-Control、Expires、Etag、Last-Modified。</p>
<p>浏览器在第一次第一次请求后，再次请求时：</p>
<ol>
<li><p>浏览器会先看header中的Cache-Control和Expires(强缓存)，如果有缓存则直接从本地缓存中获取资源，不和服务器通信，返回200。</p>
</li>
<li><p>如果没有缓存，则携带Etag和Last-Modified(协商缓存)发请求给服务器，如果服务器端没有变化，返回304，告诉浏览器可以从缓存中获取资源。</p>
</li>
<li><p>如果本地没有缓存或者服务器端资源有更新，或者用户强制刷新Ctrl+F5，浏览器会直接从服务器下载最新数据</p>
</li>
</ol>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>请求报文的请求头部，控制缓存行为，相对时间。</p>
<p><strong>max-age</strong>这个值也爱考，max-age&gt;0直接从浏览器缓存中提取，max-age&lt;=0向server发送http请求确认该资源是否有修改，有返回200，无返回304。</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>响应内容过期时间，是绝对时间。如果max-age和Expires同时存在，<strong>cache-control覆盖expires</strong>。</p>
<h4 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h4><p>请求报文的响应头部，响应中资源的校验值，用于标示URL对象是否改变，是与web资源关联的记号(token)。</p>
<p>请求头中<strong>If-Match</strong>和<strong>If-None-Match</strong>用来比较Etag是否一致。</p>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p>响应中文件在服务器端最后一次修改的时间。</p>
<p>请求头中<strong>If-Modified-Since</strong>询问该时间后文件是否有被修改过。没有变化返回304。</p>
<p>ETag解决了Last-modified无法解决的问题：</p>
<ul>
<li>一些文件修改时间改变了，但是内容没有改变，此时使用Last-modified会认为资源更新了，而ETag不会。</li>
<li>Last-modified只能精确到秒，如果资源修改非常频繁，在秒以下的时间进行修改，Last-modified无法正确响应。</li>
<li>某些服务器不能精确的得到文件的最后修改时间，这样就无法通过最后修改时间判断资源是否更新。</li>
</ul>
<blockquote>
<p>有面试题问304缓存的原理，Not Modified，就可以讲讲上面的http缓存了。</p>
</blockquote>
<h3 id="离线缓存"><a href="#离线缓存" class="headerlink" title="离线缓存"></a>离线缓存</h3><p>之前一直以为离线缓存就是指本地存储localStorage…是我孤陋寡闻了。但是！<strong>这个HTML5新特性已被弃用</strong>！</p>
<p>这里还是简要说一下这个技术的思想：开发者可以使用 Application Cache (AppCache) 接口设定浏览器应该缓存的资源并使得离线用户可用。</p>
<p>来分析一下mainfest的优缺点：</p>
<p>优点：</p>
<ol>
<li>离线运行</li>
<li>加载速度快</li>
<li>减少服务器负载，只下载更新资源</li>
</ol>
<p>缺点：</p>
<ol>
<li>更新的资源，需要二次刷新才会被页面采用</li>
<li>不支持增量更新，只要manifest发生变化，所有资源全部重新下载一次</li>
<li>缺乏足够容错机制，当清单中任意资源文件出现加载异常，都会导致整个manifest策略运行异常</li>
</ol>
<p>全量加载和二次刷新这两个缺点就已经够严重了。再看其优点也不是真的那么好用：</p>
<p>1.离线运行对于普通页面来说，离线运行没什么用；对于webapp来说，这个特性还不错；对于hybird app来说，也没什么用。<br>2.减少资源请求HTTP协议的Cache-Control和Expires就也能在缓存有效期内，不再发送资源请求<br>3.可以更新资源manifest是文件被更新后，全量更新缓存。而改用HTTP协议的缓存方案，只需要对资源文件引用的URL做少许变动即可刷新缓存，例如补个时间戳参数</p>
<blockquote>
<p>面试问题：浏览器的缓存机制</p>
</blockquote>
<p>在浏览器端保存数据能够快速读取本地数据加速网页展示，避免重复的网络请求。可以在Chrome的开发者工具的Application中看到浏览器支持的缓存机制。</p>
<p>浏览器缓存机制有：HTTP缓存、WEB SQL、IndexedDB、Cookie、LocalStorage、SessionStorage、Application Cache</p>
<p><img src="/2017/03/08/optimize/cache.png" alt="浏览器缓存机制"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://blog.csdn.net/eroswang/article/details/8302191" target="_blank" rel="external">浏览器缓存详解</a></p>
<p><a href="http://www.iteye.com/topic/656658" target="_blank" rel="external">Etag</a></p>
<p><a href="http://www.cnblogs.com/lei2007/archive/2013/08/16/3262897.html" target="_blank" rel="external">yahoo前端性能优化</a></p>
<p><a href="https://github.com/fouber/blog/issues/3" target="_blank" rel="external">前端工程与性能优化</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache" target="_blank" rel="external">manifest</a></p>
<p><a href="https://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="external">浏览器HTTP协议缓存机制</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于JS中变量类型的一些知识总结]]></title>
      <url>http://kad0108.github.io/2017/03/03/datatype/</url>
      <content type="html"><![CDATA[<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>基本类型：Number、String、Boolean、Null、Undefined</p>
<p>引用类型：Array、Object</p>
<p>ES6新数据类型：Symbol</p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><ol>
<li><p>var、let、const、function</p>
</li>
<li><p>不使用关键字，全局变量</p>
</li>
<li><p>window.a = 1，全局变量</p>
</li>
</ol>
<a id="more"></a>
<h3 id="判断变量类型"><a href="#判断变量类型" class="headerlink" title="判断变量类型"></a>判断变量类型</h3><ol>
<li><p><strong>typeof</strong></p>
<p> typeof返回的是类型字符串，它的返回值有6种：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typeof 3; // &quot;number&quot;</div><div class="line">typeof &quot;abc&quot;; // &quot;string&quot;</div><div class="line">typeof true; // &quot;boolean&quot;</div><div class="line">typeof undefined; // &quot;undefined&quot;</div><div class="line">typeof null; // &quot;object&quot;</div><div class="line">typeof &#123;&#125;; // &quot;object&quot;</div><div class="line">typeof function()&#123;&#125;; // &quot;function&quot;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>instanceof</strong></p>
<p> 检测引用类型是具体什么类型的对象时使用instaceof，本质是检查某个对象的原型链是否包含某个构造函数的prototype属性。instanceof是通过原型链来检查类型的，所以适用于任何object的类型检查。instanceof对基本数据类型不起作用，因为基本数据类型没有原型链。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3] instanceof Array // true</div><div class="line">/abc/ instanceof RegExp // true</div><div class="line">(&#123;&#125;) instanceof Object // true</div><div class="line">(function()&#123;&#125;) instanceof Function // true</div><div class="line">/*原型*/</div><div class="line">function Animal()&#123; &#125;</div><div class="line">(new Animal) instanceof Animal     // true</div></pre></td></tr></table></figure>
</li>
<li><p><strong>constructor</strong></p>
<p> constructor属性返回一个指向创建了该对象原型的函数引用(即函数本身)。与instanceof不同的是，在访问基本类型的constructor时，JS会自动调用其构造函数来生成一个对象。但是无法判断null和undefined。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(3).constructor === Number // true</div><div class="line">true.constructor === Boolean // true</div><div class="line">&apos;abc&apos;.constructor === String // true</div><div class="line">[1,2,3].constructor === Array // true</div><div class="line">(function()&#123;&#125;).constructor === Function // true</div><div class="line">null.constructor         // TypeError!</div><div class="line">undefined.constructor    // TypeError!</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Object.prototype.toString</strong></p>
<p> toString会将当前对象转换成字符串输出。可以检查所有ECMA标准中内置的所有类型，但是无法检测用户自定义类型。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">toString = Object.prototype.toString;</div><div class="line">toString.call(new Date);    // [object Date]</div><div class="line">toString.call(&apos;abc&apos;);  // [object String]</div><div class="line">toString.call(3);           // [object Number]</div><div class="line">toString.call([]);          // [object Array]</div><div class="line">toString.call(&#123;&#125;);          // [object Object]</div><div class="line">toString.call(undefined);   // [object Undefined]</div><div class="line">toString.call(null);        // [object Null]</div><div class="line">/*无法检测自定义类型*/</div><div class="line">function Animal()&#123;&#125;;</div><div class="line">var ani = new Animal();</div><div class="line">toString.call(ani);        // [object Object]</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="基本类型这里有点需要注意："><a href="#基本类型这里有点需要注意：" class="headerlink" title="基本类型这里有点需要注意："></a>基本类型这里有点需要注意：</h3><p>当基本字符串需要调用一个字符串对象才有的方法时，js会自动将基本字符串转化为字符串对象并且调用相应的方法。</p>
<p>ECMAScript中字符串是不可变的，一旦创建，值就不能改变。</p>
<p>看控制台的测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var str = &apos;kad&apos;;</div><div class="line">str[0] // &apos;k&apos;</div><div class="line">str[0] = &apos;a&apos;;</div><div class="line">str // &apos;kad&apos;</div></pre></td></tr></table></figure></p>
<p>咦？那为啥字符串拼接就可以修改啊<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str = &apos;k&apos;;</div><div class="line">str += &apos;ad&apos;;</div><div class="line">str // &apos;kad&apos;</div></pre></td></tr></table></figure></p>
<p>拼接过程实际是：创建一个新字符串，填充’k’和’ad’，然后销毁原来的字符串’k’和’ad’.在旧版本的浏览器中，拼接字符串速度很慢。</p>
<p>记得剑指offer上说提高时间效率中，就有不要多次用String的＋运算符来拼接字符串，因为会产生很多String的临时实例，造成空间和时间的浪费，更好的办法就是用StringBuffer的append方法来完成字符串的拼接。</p>
<p>那么JS中，现代浏览器已经解决了＋运算符拼接低效的问题(怎么解决的啊。。。)，还可以通过数组来实现字符串拼接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;k&apos;];</div><div class="line">arr.push(&apos;ad&apos;);</div><div class="line">arr.join(&apos;&apos;);// &apos;kad&apos;</div></pre></td></tr></table></figure>
<p>而且通过new String(‘kad’)这种方式创建的字符串，虽然类型是object，但是依然不可改变值。<code>Object.getOwnPropertyDescriptor(str, 0)</code>可以输出Object的属性类型，发现writable为false。</p>
<h2 id="基础类型和引用类型的存储："><a href="#基础类型和引用类型的存储：" class="headerlink" title="基础类型和引用类型的存储："></a>基础类型和引用类型的存储：</h2><p>基本类型就是保存在栈内存中的简单数据段，在内存中占有固定大小的空间，他们的值保存在栈空间中，按值访问。</p>
<p>而引用类型的对象，栈内存中存放该对象在堆内存中的访问地址（内存地址大小固定），由堆内存分配空间。当查询引用类型的变量时，先从栈中读取内存地址，然后通过地址找到堆中的值，也就是按引用访问。</p>
<h3 id="为什么会有栈内存和堆内存之分？"><a href="#为什么会有栈内存和堆内存之分？" class="headerlink" title="为什么会有栈内存和堆内存之分？"></a>为什么会有栈内存和堆内存之分？</h3><p>与垃圾回收机制有关，为了使程序运行时占用的内存最小。</p>
<p>每个函数执行时都会建立自己的内存栈，调用结束就释放内存。堆内存中的对象不会随着调用的结束而销毁，只有当一个对象没有任何引用变量引用时，系统的垃圾回收机制才会回收它。</p>
<h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><p>引用类型是在没有引用之后, 通过 v8 的 GC 自动回收, 值类型如果是处于闭包的情况下, 要等闭包没有引用才会被 GC 回收, 非闭包的情况下等待 v8 的新生代 (new space) 切换的时候回收。</p>
<p>垃圾收集机制的原理：找出那些不再继续使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔周期性地执行这一操作。</p>
<p>JS中最常用的垃圾收集方式是标记清除。销毁带标记的值并回收所占用的内存空间。</p>
<p>还有一种垃圾收集策略叫引用计数，跟踪记录每个值被引用的次数。但无法解决循环引用的问题。</p>
<blockquote>
<p>有关闭包的内存问题</p>
</blockquote>
<p>闭包是否一定会造成内存泄漏？不一定。</p>
<p>闭包在使用之后没有将其引用设为null，GC就会认为这部分资源还在使用，所以GC就不会对其进行回收。由于闭包的作用域链可能会很长，所以GC会认为这条作用域链还有可能会再次使用，所以整个链的资源都不会回收，这种情况引起的内存泄漏比不清除引用更严重。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var sG = &apos;Global Scope&apos;; // 全局变量资源</div><div class="line">function A()&#123;</div><div class="line">	var sA = &apos;Scope A&apos;; // 作用域链A中的资源</div><div class="line">	return function B()&#123;</div><div class="line">		var sB = &apos;Scope B&apos;; // 作用域链B中的资源</div><div class="line">		return function C()&#123;</div><div class="line">			var sC = &apos;Scope C&apos;; // 作用域链C中的资源</div><div class="line">			return function Closure()&#123;</div><div class="line">				console.log(sG); // 查找作用域链，对全局变量进行使用</div><div class="line">				console.log(sA); // 查找作用域链，对作用域链A中的sA进行使用</div><div class="line">				console.log(sB); // 查找作用域链，对作用域链B中的sB进行使用</div><div class="line">				console.log(sC); // 查找作用域链，对作用域链C中的sC进行使用</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var clo = A()()(); // 返回一个函数名为Closure的闭包</div><div class="line">clo(); // 使用闭包</div><div class="line">clo = null; // 如果不对其进行null处理，那这个闭包会一直包涵作用域链A、B、C，作用域中的资源sA、sB、sC就不会背GC回收。</div></pre></td></tr></table></figure>
<p>闭包引起的内存泄漏可以通过这个将变量设为null来解除对对象的引用，确保正常回收其占用的内存。</p>
<blockquote>
<p>面试题：局部变量与全局变量的存储</p>
</blockquote>
<p>全局变量存放在静态区(static)，程序运行开始时为其分配内存，程序运行结束后该内存才被释放。</p>
<p>局部变量存储在栈(stack)中，随函数调用被申请和释放。</p>
<h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><p>这个问题上，网上的说法不一，以红宝书的标准来: <strong>JS中所有函数的参数都是按值传递的</strong>。</p>
<p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量，用ECMAScript的概念来说就是arguments对象中的一个元素。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</p>
<h3 id="证明一下对象是按值传递的（准确的说是call-by-sharing）"><a href="#证明一下对象是按值传递的（准确的说是call-by-sharing）" class="headerlink" title="证明一下对象是按值传递的（准确的说是call-by-sharing）"></a>证明一下对象是按值传递的（准确的说是call-by-sharing）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function setName(obj)&#123;</div><div class="line">	obj.name = &apos;kad&apos;;</div><div class="line">	obj = &#123;name: &apos;lz&apos;&#125;;</div><div class="line">&#125;</div><div class="line">var person = new Object();</div><div class="line">setName(person);</div><div class="line">alert(person.name);// &apos;kad&apos;</div></pre></td></tr></table></figure>
<p>如果对象是按引用传递的，person应该被修改为指向name为’lz’的对象。实际上，在函数中重写obj时，这个变量引用的就是一个局部对象了，这个局部对象在函数执行完毕后立即被销毁。</p>
<p>那么，<strong>如何将值类型的变量以引用的方式传递：将基础类型包装成对象</strong>。</p>
<h2 id="再来说说引用类型的拷贝"><a href="#再来说说引用类型的拷贝" class="headerlink" title="再来说说引用类型的拷贝"></a>再来说说引用类型的拷贝</h2><p>这种直接赋值，obj1和obj2指向的是堆内存中的同一个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj1 = new Object();</div><div class="line">var obj2 = obj1;</div><div class="line">a === b // true</div></pre></td></tr></table></figure></p>
<h3 id="数组的深拷贝："><a href="#数组的深拷贝：" class="headerlink" title="数组的深拷贝："></a>数组的深拷贝：</h3><ol>
<li>newArr = oldArr.slice(0, oldArr.length);//第二个参数可省略</li>
<li>newArr = oldArr.concat();</li>
</ol>
<h3 id="对象的深拷贝"><a href="#对象的深拷贝" class="headerlink" title="对象的深拷贝"></a>对象的深拷贝</h3><ol>
<li><p>把对象属性遍历一遍赋给新对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function deepCopy(obj)&#123;</div><div class="line">	var newObj = &#123;&#125;;</div><div class="line">	for(key in obj)&#123;</div><div class="line">		newObj[key] = typeof obj[key] === &apos;Object&apos; ? deepCopy(obj[key]) : obj[key];</div><div class="line">	&#125;</div><div class="line">	return newObj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">Object.create()</a>，需要传入对象原型</p>
</li>
</ol>
<h2 id="关于引用，来看题："><a href="#关于引用，来看题：" class="headerlink" title="关于引用，来看题："></a>关于引用，来看题：</h2><blockquote>
<p>== 的 === 的区别</p>
<p>那么[1] == [1]的结果是什么</p>
</blockquote>
<p>应该是false，不要被自己对于 == 和 === 的结论影响然后得出错误的结论。因为是两个不同的对象在比较。</p>
<p>关于==类型转换记住是优先转数字，然后就很好理解true==’true’结果为false了。</p>
<p><img src="/2017/03/03/datatype/compare.png" alt="看到一张挺有意思的图，贴在这儿"></p>
<blockquote>
<p>面试题：JS中判断是否为数组</p>
</blockquote>
<ol>
<li><p>Array.isArray(arr)</p>
</li>
<li><p>arr instanceof Array</p>
</li>
<li><p><code>arr.__proto__.constructor === Array</code></p>
</li>
</ol>
<blockquote>
<p>说到引用，不可不提c++中指针和引用的区别，ps：C语言中没有引用：</p>
</blockquote>
<ol>
<li><p>指针是一个实体，引用只是个别名</p>
</li>
<li><p>引用只能在定义时初始化一次，之后引用所指向的内容不变；指针可变。</p>
</li>
<li><p>引用不能为空，指针可以为空。</p>
</li>
<li><p>sizeof引用拿到的事所指向变量的大小，而sizeof指针拿到的是指针本身(所指向变量的地址)的大小。</p>
</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" target="_blank" rel="external">call-by-sharing</a></p>
<p><a href="http://harttle.com/2015/09/18/js-type-checking.html" target="_blank" rel="external">判断JS变量类型</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BFC]]></title>
      <url>http://kad0108.github.io/2017/03/02/bfc/</url>
      <content type="html"><![CDATA[<h3 id="首先明确BFC是什么"><a href="#首先明确BFC是什么" class="headerlink" title="首先明确BFC是什么"></a>首先明确BFC是什么</h3><p>BFC(Block Formatting Context)就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。IE中是hasLayout</p>
<h3 id="然后什么情况会触发BFC："><a href="#然后什么情况会触发BFC：" class="headerlink" title="然后什么情况会触发BFC："></a>然后什么情况会触发BFC：</h3><ol>
<li><p>float的值不为none</p>
</li>
<li><p>overflow的值为auto,scroll或hidden</p>
</li>
<li><p>display的值为table-cell, table-caption, inline-block中的任何一个</p>
</li>
<li><p>position的值不为relative和static</p>
</li>
</ol>
<a id="more"></a>
<h3 id="然后通过例子来看BFC可以用来干嘛："><a href="#然后通过例子来看BFC可以用来干嘛：" class="headerlink" title="然后通过例子来看BFC可以用来干嘛："></a>然后通过例子来看BFC可以用来干嘛：</h3><p><strong>1. 防止margin重叠</strong></p>
<p>垂直的两个块级元素会发生margin重叠：兄弟元素或父子元素。水平方向的margin是不重叠的。</p>
<p>解决：触发下面元素的BFC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">p&#123;</div><div class="line">	width: 200px;</div><div class="line">	height: 200px;</div><div class="line">	background-color: pink;</div><div class="line">	margin: 100px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;p&gt;&lt;/p&gt;</div><div class="line">&lt;p style=&quot;float: left;&quot;&gt;&lt;/p&gt;</div><div class="line">或</div><div class="line">&lt;p&gt;&lt;/p&gt;</div><div class="line">&lt;p style=&quot;position: absolute;&quot;&gt;&lt;/p&gt;</div><div class="line">或</div><div class="line">&lt;p&gt;&lt;/p&gt;</div><div class="line">&lt;div style=&quot;overflow:hidden;&quot;&gt;</div><div class="line">	&lt;p&gt;&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">或</div><div class="line">&lt;p&gt;&lt;/p&gt;</div><div class="line">&lt;p style=&quot;display:inline-block;&quot;&gt;&lt;/p&gt;</div></pre></td></tr></table></figure></p>
<p><strong>2. 防止浮动元素的父元素高度塌陷，即清除浮动</strong></p>
<p>当一个父元素包含了多个浮动子元素时，子元素设置了宽高，父元素的宽度不会受影响，但是高度会塌陷</p>
<p>因为计算BFC的高度时，浮动元素的高度也参与计算，所以解决方案是触发父元素的BFC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.child&#123;</div><div class="line">	width: 100px;</div><div class="line">	height: 100px;</div><div class="line">	border: 6px solid purple;</div><div class="line">	float: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;parent&quot; style=&quot;overflow:hidden;&quot;&gt;</div><div class="line">	&lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">或</div><div class="line">其他几种BFC情况均可解决</div></pre></td></tr></table></figure>
<p><strong>3. 自适应两栏布局</strong></p>
<p>普通流布局的div和浮动元素做兄弟时是覆盖关系(文字会环绕)，但是将div做BFC化之后，会顺着浮动元素边缘形成自己的封闭的上下文。</p>
<p>调节下面demo中aside的宽度会发现main的宽度在自适应变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">.container&#123;</div><div class="line">	width: 400px;</div><div class="line">	height: 400px;</div><div class="line">&#125;</div><div class="line">.aside&#123;</div><div class="line">	float: left; /**/</div><div class="line">	width: 100px;</div><div class="line">	height: 100px;</div><div class="line">	background-color: pink;</div><div class="line">&#125;</div><div class="line">.main&#123;</div><div class="line">	overflow: hidden; /**/</div><div class="line">	background-color: lightgrey;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">	&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;main&quot;&gt;我就是为了撑开这个div的&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/" target="_blank" rel="external">CSS深入理解流体特性和BFC特性下多栏自适应布局</a></p>
<p><a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="external">BFC 神奇背后的原理</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Scope and Thread]]></title>
      <url>http://kad0108.github.io/2017/02/24/scope/</url>
      <content type="html"><![CDATA[<p>有关作用域和执行栈的几道题目，直接来看例子：</p>
<h3 id="例子一："><a href="#例子一：" class="headerlink" title="例子一："></a>例子一：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 10; i++)&#123;&#125;</div><div class="line">console.log(i);</div></pre></td></tr></table></figure>
<p>输出10，var声明的变量i在全局范围内都有效。</p>
<a id="more"></a>
<h3 id="例子二："><a href="#例子二：" class="headerlink" title="例子二："></a>例子二：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for(let i = 0; i &lt; 10; i++)&#123;&#125;</div><div class="line">console.log(i);</div></pre></td></tr></table></figure>
<p>会输出ReferenceError，因为let声明的变量i只在let所在代码块内有效。在循环体外引用就会出错。</p>
<p>注意声明了而没有赋值的变量才输出undefined。</p>
<h3 id="例子三："><a href="#例子三：" class="headerlink" title="例子三："></a>例子三：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 5; i++)&#123;</div><div class="line">	setTimeout(()=&gt;&#123;</div><div class="line">		console.log(&quot;one:&quot;, i);</div><div class="line">	&#125;, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出是<strong>5个5</strong>。</p>
<p>为什么出现这种情况？执行栈</p>
<h4 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h4><ol>
<li><p>匿名函数自执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 5; i++)&#123;</div><div class="line">	setTimeout((function()&#123;</div><div class="line">		console.log(i);</div><div class="line">	&#125;)(i), 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>闭包里返回匿名函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(var i = 0; i &lt; 5; i++)&#123;</div><div class="line">	setTimeout((function(i)&#123;</div><div class="line">		return function()&#123;</div><div class="line">			console.log(i);</div><div class="line">		&#125;</div><div class="line">	&#125;)(i), 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面这两种方法的思想都是要隔离作用域。我们都知道JS在ES6之前是没有块级作用域的，只有函数作用域，通过自执行函数来隔离变量作用域，我自己的理解就是让本次循环的i只在本次循环内作用。</p>
<h3 id="例子四："><a href="#例子四：" class="headerlink" title="例子四："></a>例子四：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for(let i = 0; i &lt; 5; i++)&#123;</div><div class="line">	setTimeout(()=&gt;&#123;</div><div class="line">		console.log(i);</div><div class="line">	&#125;, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出是正常的0，1，2，3，4。因为i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量。</p>
<p>你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p>
<h3 id="例子五：promise与setTimeout"><a href="#例子五：promise与setTimeout" class="headerlink" title="例子五：promise与setTimeout"></a>例子五：promise与setTimeout</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">setTimeout(function()&#123;</div><div class="line">	console.log(0);</div><div class="line">&#125;, 0);</div><div class="line">console.log(1);</div><div class="line">new Promise(function executor(resolve)&#123;</div><div class="line">	console.log(2);</div><div class="line">	for(var i = 0; i &lt; 10000; i++)&#123;</div><div class="line">		i == 6666 &amp;&amp; console.log(3);</div><div class="line">		i == 9999 &amp;&amp; resolve();</div><div class="line">	&#125;</div><div class="line">	console.log(4);</div><div class="line">&#125;).then(function()&#123;</div><div class="line">	console.log(5);</div><div class="line">&#125;);</div><div class="line">console.log(6);</div></pre></td></tr></table></figure>
<p>输出： 1 2 3 4 6 5 0</p>
<p>其中异步事件注册顺序：setTimeout-&gt;promise.then</p>
<p>实际优先级关系：promise.then-&gt;setTimeout</p>
<h3 id="例子六：nextTick和setImmediate"><a href="#例子六：nextTick和setImmediate" class="headerlink" title="例子六：nextTick和setImmediate"></a>例子六：nextTick和setImmediate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">setImmediate(function()&#123;</div><div class="line">    console.log(1);</div><div class="line">&#125;,0);</div><div class="line">setTimeout(function()&#123;</div><div class="line">    console.log(2);</div><div class="line">&#125;,0);</div><div class="line">new Promise(function(resolve)&#123;</div><div class="line">    console.log(3);</div><div class="line">    resolve();</div><div class="line">    console.log(4);</div><div class="line">&#125;).then(function()&#123;</div><div class="line">    console.log(5);</div><div class="line">&#125;);</div><div class="line">console.log(6);</div><div class="line">process.nextTick(function()&#123;</div><div class="line">    console.log(7);</div><div class="line">&#125;);</div><div class="line">console.log(8);</div></pre></td></tr></table></figure>
<p>输出： 3 4 6 8 7 5 2 1</p>
<p>优先级关系：process.nextTick-&gt;promise.then-&gt;setTimeout-&gt;setImmediate</p>
<h3 id="有关执行任务"><a href="#有关执行任务" class="headerlink" title="有关执行任务"></a>有关执行任务</h3><p>任务分两类：microtask、macrotask</p>
<p>macrotask：script整体代码、setTimeout、setInterval、setImmediate、I/O</p>
<p>microtask：process.nextTick、Promises</p>
<p>执行顺序是：先执行一个macrotask，然后执行所有microtask任务，然后再执行macrotask，重复过程.</p>
<p>process.nextTick在当前执行栈尾部，下一次event loop(主线程读取任务队列)之前触发回调函数，setTimeout也是在下一次event loop调用。</p>
<h3 id="有关定时器的知识："><a href="#有关定时器的知识：" class="headerlink" title="有关定时器的知识："></a>有关定时器的知识：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setInterval(function()&#123;</div><div class="line">	</div><div class="line">&#125;, 150ms);</div></pre></td></tr></table></figure>
<p>第二个参数，一直以为是每次执行前需要等待的毫秒数，其实不是。这个参数表示它的代码会在150ms之后被加入到任务队列中。但是不管怎样它的执行都要等到主线程的所有同步任务执行完毕才能执行。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">event loop</a></p>
<p><a href="https://www.zhihu.com/question/36972010" target="_blank" rel="external">promise的队列和setTimeout的队列</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Cookie]]></title>
      <url>http://kad0108.github.io/2017/02/21/cookie/</url>
      <content type="html"><![CDATA[<h3 id="cookie的产生与使用"><a href="#cookie的产生与使用" class="headerlink" title="cookie的产生与使用"></a>cookie的产生与使用</h3><p>browser第一次请求server，server提供web页面，还附带一些键值对，也就是cookie。browser在本地存储cookie，之后每次请求和响应中都会来回发送cookie，仅限4k数据。</p>
<p>cookie与一个域相关联，而且只能发送给这个域。</p>
<p>cookie一般存储的是用户的登陆信息包括用户名、认证信息、登陆时间等，以便于下次免登陆，但一般不会将密码放在cookie中。</p>
<a id="more"></a>
<h3 id="HTTP协议是无状态的，为了保持用户会话状态使用什么技术方案弥补？"><a href="#HTTP协议是无状态的，为了保持用户会话状态使用什么技术方案弥补？" class="headerlink" title="HTTP协议是无状态的，为了保持用户会话状态使用什么技术方案弥补？"></a>HTTP协议是无状态的，为了保持用户会话状态使用什么技术方案弥补？</h3><p>常用的保持会话状态的方式有session、cookie、URL GET参数：</p>
<ol>
<li><p>cookie是保存在浏览器终端内存或磁盘上的一小块数据，只能保存字符串类型。所有cookie信息都随着浏览器的请求而发送。cookie分为持久cookie（数据保存在磁盘中）、会话cookie（保存在内存，浏览器关闭后被删除）。浏览器对单域下cookie的个数和每个key的长度都有限制。</p>
</li>
<li><p>session是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息。客户端需要接收、记忆和回送session的会话标识号，session通常是借助客户端的cookie来纪录会话标识。</p>
</li>
<li><p>GET参数是URL中的普通参数，GET方式是明文传输，其传送的数据量会有限制，不同浏览器支持的最大长度略有不同。</p>
</li>
</ol>
<p>要保持用户的会话状态，服务端在客户端第一次访问时自动创建一个session来存储客户端的信息，同时生成一个唯一的key发送给客户端。如果客户端没有禁用cookie，服务器会在客户端的cookie中写入一个key值，用户保存用户信息，之后每一次访问携带cookie给后端，服务器可以根据这个值判断用户的唯一性。如果用户禁用了cookie，则需要将验证信息写入URL中，所有的请求也需要携带这个参数，比如<code>http://a.com/b.html?session_id=auij123456789</code>，不携带则客户端会丢失会话状态。</p>
<h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><ol>
<li><p>cookie存储在客户端，session存储在服务器端</p>
</li>
<li><p>cookie存储<strong>编码</strong>后的字符串，session保存对象</p>
</li>
<li><p>session借助cookie才能工作，如果客户端禁用cookie，可以将验证信息写入URL，所有请求携带这个参数</p>
</li>
</ol>
<h3 id="浏览器端存储技术localStorage、sessionStorage、cookie区别"><a href="#浏览器端存储技术localStorage、sessionStorage、cookie区别" class="headerlink" title="浏览器端存储技术localStorage、sessionStorage、cookie区别"></a>浏览器端存储技术localStorage、sessionStorage、cookie区别</h3><p>cookie是存储在浏览器端，只有4k大小，并且随浏览器的请求一起发送到服务器端的，它有一定的过期时间，到了过期时间自动会消失。</p>
<p>sessionStorage和localeStorage也是存储在客户端的，同属于web Storage，比cookie的存储大小要大有5M，cookie只有4kb，localeStorage是持久化的存储在客户端，如果用户不手动清除的话，不会自动消失，会一直存在，sessionStorage也是存储在客户端，但是它的存活时间是在一个回话期间，只要浏览器的回话关闭了就会自动消失。localStorage在移动端会因为一些原因(比如内存不足等)会被清空。</p>
<p>cookie可以跨域读取，localStorage不允许跨域。读取同一份localStorage必须在相同的协议、主机、端口下。sessionStorage除了要在同域下，还需要在同一浏览器标签页下。</p>
<p>cookie的读取是通过document.cookie，读取到的字符串中存储方式是：<code>key=val;</code>。localStorage则直接以键值对的形式存储，值也必须是字符串，有setItem、getItem、removeItem、clear方法。</p>
<h3 id="cookie可设置属性"><a href="#cookie可设置属性" class="headerlink" title="cookie可设置属性"></a>cookie可设置属性</h3><p>domain属性：决定允许访问cookie的域名。</p>
<p>path属性：决定允许访问cookie的路径。同一服务器，URL中有和path相同的路径的页面都可以共享cookie。</p>
<p>expires属性：cookie过期时间。</p>
<p>secure属性：默认为空，使用HTTP传递数据。设置secure则使用HTTPS等安全协议传输。</p>
<p>HttpOnly属性：限制非HTTP方式的访问。</p>
<p>如果想让a.hello.com访问b.hello.com的cookie，可以将domain设为hello.com，并把path设为<code>/</code>。</p>
<h3 id="cookie的弊端"><a href="#cookie的弊端" class="headerlink" title="cookie的弊端"></a>cookie的弊端</h3><ol>
<li><p>数量和长度限制。</p>
</li>
<li><p>安全性。cookie被拦截后也不需要知道cookie的意义，原样转发就可达到目的。<a href="http://kadong.space/2017/03/11/ajax/#前端安全" target="_blank" rel="external">看这里有关前端安全的总结</a></p>
</li>
<li><p>用户可以禁用cookie，则cookie功能受限。</p>
</li>
</ol>
<h3 id="记住密码自动登录怎么实现？"><a href="#记住密码自动登录怎么实现？" class="headerlink" title="记住密码自动登录怎么实现？"></a>记住密码自动登录怎么实现？</h3><p>这里是我自己的理解，不一定正确。</p>
<p>登录时勾选了记住密码，则expires选项会附加到登录cookie中。如果未勾选，则不携带expires属性让cookie的寿命仅限本次会话，或者携带设置了一个过去的时间点的expires这样cookie会立刻被删除。</p>
<p>勾选自动登录则再携带一个自定义属性autologin。</p>
<h3 id="封装cookie的添加、删除、查询方法"><a href="#封装cookie的添加、删除、查询方法" class="headerlink" title="封装cookie的添加、删除、查询方法"></a>封装cookie的添加、删除、查询方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var CookieUtil = &#123;</div><div class="line">	setCookie: function(key, val, expiredays)&#123;</div><div class="line">		var exdate = new Date();</div><div class="line">		exdate.setDate(exdate.getDate() + expiredays);</div><div class="line">		document.cookie = key + &quot;=&quot; + escape(val) + ((expiredays == undefined) ? &quot;&quot; : &quot;;expires=&quot; + exdate.toGMTString());</div><div class="line">	&#125;,</div><div class="line">	getCookie: function(key)&#123;</div><div class="line">		var cookie = document.cookie;</div><div class="line">		var start = cookie.indexOf(key);</div><div class="line">		if(start != -1) return null;</div><div class="line">		var end = cookie.indexOf(&quot;;&quot;, start);</div><div class="line">		if(end == -1) end = cookie.length;</div><div class="line">		return escape(cookie.substring(start+key.length+1, end));</div><div class="line">	&#125;,</div><div class="line">	deleteCookie: function(key)&#123;</div><div class="line">		var val = this.getCookie(key);</div><div class="line">		if(val == null) return null;</div><div class="line">		this.setCookie(key, val, 0);//过期时间设为0，浏览器会马上自动删除cookie	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS Prototype]]></title>
      <url>http://kad0108.github.io/2017/02/20/prototype/</url>
      <content type="html"><![CDATA[<p>JS原型是前端面试时总会问到的知识点，这里具体总结一下。</p>
<p>缘于问题：<strong>对JS原型有什么了解，用原型创建对象和普通new一个对象的区别</strong>，下面具体说明创建对象的几种方法。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function person(name)&#123;</div><div class="line">	var o = new Object();</div><div class="line">	o.name = name;</div><div class="line">	return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p = person(&quot;kad&quot;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>工厂模式解决了使用Object一个接口创建很多对象产生大量重复代码的问题，但是无法识别对象类型。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Person(name)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.sayName = function()&#123;alert(this.name);&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person = new Person(&quot;kad&quot;);</div><div class="line">alert(person.constructor == Person); // true</div><div class="line">alert(person instanceof Person); // true</div></pre></td></tr></table></figure>
<p>构造函数以大写字母开头。对象的constructor属性用来识别对象类型。</p>
<p>但是构造函数的每个方法都要在每个实例上重新创建一遍。不同实例上的同名函数不相等。<code>person1.sayName != person2.sayName</code></p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;</div><div class="line">Person.prototype.name = &quot;kad&quot;;</div><div class="line">Person.prototype.sayName = function()&#123;alert(this.name);&#125;</div><div class="line">var person = new Person();</div></pre></td></tr></table></figure>
<p>使用原型对象的好处是可以让所有对象实例共享原型对象所包含的属性和方法。<code>person1.sayName == person2.sayName</code></p>
<h2 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h2><p><img src="/2017/02/20/prototype/prototype.png" alt="原型对象"></p>
<p>从图中可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. Person.prototype.constructor == Person</div><div class="line"></div><div class="line">2. person.__proto__ == Person.prototype</div></pre></td></tr></table></figure>
<p><strong>isPrototypeOf()</strong>用来判断原型对象和实例之间的关系： <code>Person.prototype.isPrototypeOf(person)</code>。</p>
<p><strong>hasOwnProperty()</strong>检测实例自身的属性，会忽略从原型链上继承到的属性。</p>
<p><strong>delete</strong>操作符可以删除实例属性。</p>
<p><strong>in</strong>操作符用来判断实例是否含有某个属性，不管是不是本地属性。</p>
<h3 id="proto-是连接实例与构造函数的原型对象之间。"><a href="#proto-是连接实例与构造函数的原型对象之间。" class="headerlink" title="__proto__是连接实例与构造函数的原型对象之间。"></a><code>__proto__</code>是连接实例与构造函数的原型对象之间。</h3><blockquote>
<p><strong>new操作符做了什么</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function F()&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">var f = new F();</div></pre></td></tr></table></figure>
<p>new操作符的心路历程：</p>
<ol>
<li><p>新建一个对象 <code>f = new Object()</code></p>
</li>
<li><p>设置对象原型链 <code>f.__proto__ = F.prototype</code></p>
</li>
<li><p>改变构造函数内this的指向，让F中的this指向实例，执行F函数体 <code>F.call(f)</code></p>
</li>
</ol>
<h2 id="JS继承"><a href="#JS继承" class="headerlink" title="JS继承"></a>JS继承</h2><h3 id="原型链继承：将父类的实例作为子类的原型"><a href="#原型链继承：将父类的实例作为子类的原型" class="headerlink" title="原型链继承：将父类的实例作为子类的原型"></a>原型链继承：将父类的实例作为子类的原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Father(name)&#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;</div><div class="line">Father.prototype.sayName = function()&#123;</div><div class="line">	return this.name;</div><div class="line">&#125;</div><div class="line">function Child()&#123;&#125;</div><div class="line">Child.prototype = new Person(&quot;kad&quot;);</div><div class="line">var child = new Child();</div><div class="line">child.sayName();//&apos;kad&apos;</div></pre></td></tr></table></figure>
<p>缺点：所有子类共享父类实例，如果某个子类修改了父类，其他子类继承会出问题。在构造子类型实例时不能给父类传参。</p>
<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Parent(name)&#123;</div><div class="line">	console.log(this);</div><div class="line">	this.name = name;</div><div class="line">	this.sayName = function()&#123;</div><div class="line">		console.log(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">function Child(name)&#123;</div><div class="line">	this.parent = Parent;//此时Parent中的this指向的是Child，也就是把Parent中的属性和方法都给了Child</div><div class="line">	this.parent(name);</div><div class="line">	//这里直接delete this.parent也可以</div><div class="line">&#125;</div><div class="line">var child = new Child(&quot;kad&quot;);</div><div class="line">child.sayName(); //&apos;kad&apos;</div><div class="line">console.log(child); </div><div class="line">/**</div><div class="line">Child</div><div class="line">-name: &quot;kad&quot;</div><div class="line">-parent: Parent</div><div class="line">-sayName: ()</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>缺点：无法继承父类原型链上的属性和方法。</p>
<h3 id="call、apply实现继承"><a href="#call、apply实现继承" class="headerlink" title="call、apply实现继承"></a>call、apply实现继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function Parent(name)&#123;</div><div class="line">	console.log(this);</div><div class="line">	this.name = name;</div><div class="line">	this.sayName = function()&#123;</div><div class="line">		console.log(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">function Child(name)&#123;</div><div class="line">	Parent.call(this, name);</div><div class="line">&#125;</div><div class="line">var child = new Child(&quot;kad&quot;);</div><div class="line">child.sayName();//&apos;kad&apos;</div><div class="line">console.log(child);</div><div class="line">/**</div><div class="line">Child</div><div class="line">-name: &quot;kad&quot;</div><div class="line">sayName: ()</div><div class="line">*/</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>为什么子类的原型要指向父类的实例，而不直接指向父类的原型呢？</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">	this.name = &apos;kad&apos;;</div><div class="line">&#125;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Test()&#123;</div><div class="line">	this.name = &apos;test&apos;;</div><div class="line">&#125;</div><div class="line">Test.prototype = Person.prototype;</div><div class="line"></div><div class="line">Test.prototype.tt = function()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2017/02/20/prototype/prototype3.png" alt="看图说话"></p>
<p>可以看出，当子类的原型指向父类的原型时，子类就不是继承父类了，因为此时对子类原型的修改会反映到父类上。</p>
<h2 id="区别静态、私有、共享属性和方法"><a href="#区别静态、私有、共享属性和方法" class="headerlink" title="区别静态、私有、共享属性和方法"></a>区别静态、私有、共享属性和方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">	this.name = &quot;kad&quot;;</div><div class="line">	this.privFn = function()&#123;</div><div class="line">		console.log(&quot;I&apos;m private.&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">Person.staticFn = function()&#123;</div><div class="line">	console.log(&quot;I&apos;m static.&quot;);</div><div class="line">&#125;</div><div class="line">Person.prototype.shareFn = function()&#123;</div><div class="line">	console.log(&quot;I&apos;m public and shareable.&quot;);</div><div class="line">&#125;</div><div class="line">var p = new Person();</div><div class="line"></div><div class="line">function Stu()&#123;</div><div class="line">	this.name = &quot;student&quot;;</div><div class="line">&#125;</div><div class="line">Stu.prototype = new Person();</div><div class="line">var s = new Stu();</div></pre></td></tr></table></figure>
<p><img src="/2017/02/20/prototype/prototype2.png" alt="member"></p>
<p>区别静态属性/方法、私有属性/方法、共享属性/方法：</p>
<ol>
<li><p>静态属性/方法只能通过构造函数直接调用，即Person.staticFn()</p>
</li>
<li><p>私有属性/方法只能通过实例化调用，即p.privFn()</p>
</li>
<li><p>共享属性/方法可以通过原型对象调用，也可以实例化调用，即Person.prototype.shareFn()或p.shareFn()</p>
</li>
<li><p>私有属性/方法和共享属性/方法都可以被子对象继承，而静态属性/方法不可以被继承</p>
</li>
</ol>
<h2 id="改变函数内部this指针的指向"><a href="#改变函数内部this指针的指向" class="headerlink" title="改变函数内部this指针的指向"></a>改变函数内部this指针的指向</h2><p>总是挺难理解call和apply，来点自己的记忆方法。</p>
<blockquote>
<p>比如<code>fn.call(obj)</code>，obj说：hi，fn，把你的this借我用用（即把fn的this指向obj）。</p>
<p>再比如<code>fn.sayName.call(obj)</code>，obj说：hi，fn，把你的sayName借我用用（把sayName的this指向obj）。</p>
</blockquote>
<p>call方法应用于Function对象，测试了普通{}对象是不可以调用call的。</p>
<p>call返回什么：比如animal.sayname.call(cat);语句返回的是修改了sayName的this，执行cat.sayName()的结果。</p>
<p>call和apply的区别就只是第二个参数啦。bind的返回值是函数。</p>
<p>bind最常用的场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Fn()&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">Fn.prototype.click = function()&#123;&#125;</div><div class="line">Fn.prototype.init = function()&#123;</div><div class="line">	document.addEventListener(&apos;click&apos;, this.click.bind(this));//也就是在监听事件函数中的this指向了Fn</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>看下面的问题，加深对context上下文和this的理解</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var User = &#123;</div><div class="line">	count: 1,</div><div class="line">	getCount: function ()&#123;</div><div class="line">		console.log(this);</div><div class="line">		return this.count;		</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">console.log(User.getCount());//1</div><div class="line">var fn = User.getCount;</div><div class="line">console.log(fn());//undefined,此时fn的上下文是window</div></pre></td></tr></table></figure>
<p><strong>如何确保fn的上下文始终和User关联?</strong></p>
<p>正确答案是使用Function.prototype.bind</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var func = User.getCount.bind(User);  </div><div class="line">console.log(func());</div></pre></td></tr></table></figure>
<p>兼容老浏览器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Function.prototype.bind = Function.prototype.bind || function(context)&#123;</div><div class="line">	var self = this;</div><div class="line">	return function()&#123;</div><div class="line">		return self.apply(context, arguments);		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WebSocket]]></title>
      <url>http://kad0108.github.io/2017/02/15/websocket/</url>
      <content type="html"><![CDATA[<p><strong>WebSocket是Html5新增的协议，目的就是为了在浏览器和服务器之间建立不受限的双向通信通道，使得服务器能够主动向客户端发送数据。</strong></p>
<h2 id="传统的HTTP协议不能实现WebSocket的功能吗？"><a href="#传统的HTTP协议不能实现WebSocket的功能吗？" class="headerlink" title="传统的HTTP协议不能实现WebSocket的功能吗？"></a>传统的HTTP协议不能实现WebSocket的功能吗？</h2><p>HTTP是一个请求－响应协议，必须是浏览器向服务器发起请求，服务器才能响应这个请求，再把数据发送给客户端。也就是说浏览器不主动请求，服务器是没法主动发数据给浏览器的。</p>
<a id="more"></a>
<h3 id="轮询能实现啊"><a href="#轮询能实现啊" class="headerlink" title="轮询能实现啊"></a>轮询能实现啊</h3><p>ajax轮询的原理是启动一个定时器，固定间隔向服务器发起请求，问服务器是否有新信息。这种机制频繁请求会给服务器带来巨大的压力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">场景再现：</div><div class="line">C：有没有新信息？（Request）</div><div class="line">S：没有（Response）</div><div class="line">C：哎呀有没有新信息 （Request）</div><div class="line">S：没有了啦！（Response）</div><div class="line">－－－loop</div></pre></td></tr></table></figure>
<p>还有comet本质也是轮询，客户端在发起连接后，服务器没消息就一直不返回response，直到有消息才返回，返回之后客户端再建立起连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">场景再现：</div><div class="line">C：有没有消息？（Request）</div><div class="line">S：没有，等有的时候再给你。</div><div class="line">...</div><div class="line">S: 来，给你消息 (Response)</div><div class="line">－－－loop</div></pre></td></tr></table></figure>
<blockquote>
<p>如何判断用户是否是在网的状态，就可以采用轮询。也可以使用HTML5提供的navigator.onLine来判断设备是在线还是离线。</p>
</blockquote>
<h2 id="那WebSocket是怎么实现的啊"><a href="#那WebSocket是怎么实现的啊" class="headerlink" title="那WebSocket是怎么实现的啊"></a>那WebSocket是怎么实现的啊</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">场景再现：</div><div class="line">C：我要建立websocket协议，协议版本xx （Request）</div><div class="line">S：OK，已升级为WebSocket协议（HTTP Protocols Switched）</div><div class="line">C：麻烦你有信息的时候推送给我哈</div><div class="line">S：lalala</div><div class="line">S：我给你发送数据啦</div><div class="line">S：嗯，加油哦</div></pre></td></tr></table></figure>
<p>也就是经过一次HTTP请求，就可以源源不断发送信息啦</p>
<h3 id="WebSocket请求是什么样的呢？"><a href="#WebSocket请求是什么样的呢？" class="headerlink" title="WebSocket请求是什么样的呢？"></a>WebSocket请求是什么样的呢？</h3><p><img src="/2017/02/15/websocket/websocket.png" alt="websocket"></p>
<p>该请求和普通的HTTP请求有几点不同：</p>
<ol>
<li>GET请求的地址不是类似/path/，而是以ws://开头的地址；</li>
<li>请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；</li>
<li>Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；</li>
<li>Sec-WebSocket-Version指定了WebSocket的协议版本。</li>
</ol>
<p>响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。</p>
<p><a href="https://github.com/kad0108/Html5/tree/gh-pages/webSocket" target="_blank" rel="external">简易小demo看这里</a></p>
<h2 id="那HTTP不是也有keep-alive来实现长连接吗？"><a href="#那HTTP不是也有keep-alive来实现长连接吗？" class="headerlink" title="那HTTP不是也有keep-alive来实现长连接吗？"></a>那HTTP不是也有keep-alive来实现长连接吗？</h2><p>connection：keep-alive是指在一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发header。也就是除了真正的数据部分外，服务器和客户端还要大量交换 HTTP header，信息交换效率很低。</p>
<p>WebSocket 解决的第一个问题是，通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.zhihu.com/question/20215561" target="_blank" rel="external">websocket实现持久连接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP协议]]></title>
      <url>http://kad0108.github.io/2017/02/08/http/</url>
      <content type="html"><![CDATA[<p>从浏览器地址栏的请求链接开始，浏览器通过DNS解析查到域名映射的IP地址，然后浏览器端向此IP地址取得连接，成功连接之后，浏览器端将请求头信息通过HTTP协议向此IP地址所在服务器发起请求，服务器接受到请求后处理发回响应。浏览器从服务器接收到text/html类型的代码，浏览器开始显示此html。</p>
<p>HTTP是互联网上应用最广泛的一种网络协议，也是浏览器和服务器通信时所采用的协议。HTTP是基于TCP传输，<strong>无连接</strong>(每次连接只处理一个请求，响应后断开)，<strong>无状态</strong>(服务器不会保存客户的任何信息)的<strong>应用层</strong>协议。</p>
<h2 id="HTTP的报文格式"><a href="#HTTP的报文格式" class="headerlink" title="HTTP的报文格式"></a>HTTP的报文格式</h2><p>请求报文(从客户端发到服务器)</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;方法&gt;&lt;URL&gt;&lt;版本&gt;</div><div class="line">&lt;首部header&gt;</div><div class="line">&lt;主体body&gt;(可选)</div></pre></td></tr></table></figure>
<p>响应报文(从服务器发给客户端)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;版本&gt;&lt;状态码&gt;&lt;状态信息&gt;</div><div class="line">&lt;首部&gt;</div><div class="line">&lt;主体&gt;</div></pre></td></tr></table></figure>
<p>HTTP header字段包括通用头、请求头、响应头、实体头四个部分。</p>
<h3 id="请求方法中GET和POST的区别"><a href="#请求方法中GET和POST的区别" class="headerlink" title="请求方法中GET和POST的区别"></a>请求方法中GET和POST的区别</h3><table>
<thead>
<tr>
<th>GET用于获取资源</th>
<th style="text-align:center">POST用于发送数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>通过URL请求传输数据</td>
<td style="text-align:center">通过HTTP包的包体</td>
</tr>
<tr>
<td>受URL长度限制，只能传递约1024字节</td>
<td style="text-align:center">数据量大，可达2M</td>
</tr>
<tr>
<td>只支持ASCII字符</td>
<td style="text-align:center">支持标准字符集，可传递中文字符</td>
</tr>
<tr>
<td>get请求会缓存</td>
<td style="text-align:center">不缓存，每次刷新重新发送</td>
</tr>
<tr>
<td>url可见，不安全</td>
<td style="text-align:center">较get安全</td>
</tr>
</tbody>
</table>
<h3 id="POST提交数据的几种数据格式"><a href="#POST提交数据的几种数据格式" class="headerlink" title="POST提交数据的几种数据格式"></a>POST提交数据的几种数据格式</h3><p>POST提交的数据必须放在HTTP的body中，服务器端根据http header中的<strong>Content-Type</strong>字段来判断数据是用哪种编码方式编码的，然后进行解码。</p>
<h4 id="先看Form表单的enctype属性："><a href="#先看Form表单的enctype属性：" class="headerlink" title="先看Form表单的enctype属性："></a>先看Form表单的<strong>enctype</strong>属性：</h4><ol>
<li><p>默认编码方式发送前编码所有字符：<code>application/x-www-form-urlencoded</code></p>
</li>
<li><p>不对字符编码，在使用包含文件上传的表单时必须使用该值：<code>multipart/form-data</code></p>
</li>
<li><p>空格转换为+加号，不对特殊字符编码：<code>text/plain</code></p>
</li>
</ol>
<h4 id="Ajax以POST请求向服务器提交数据时，可以通过setRequestHeader设置头部属性Content-Type定义发送内容编码属性。"><a href="#Ajax以POST请求向服务器提交数据时，可以通过setRequestHeader设置头部属性Content-Type定义发送内容编码属性。" class="headerlink" title="Ajax以POST请求向服务器提交数据时，可以通过setRequestHeader设置头部属性Content-Type定义发送内容编码属性。"></a>Ajax以POST请求向服务器提交数据时，可以通过setRequestHeader设置头部属性Content-Type定义发送内容编码属性。</h4><ol>
<li><p><code>application/json</code>：json数据</p>
</li>
<li><p><code>application/xml</code>：根据xml头指定的编码格式进行编码。还有<code>text/xml</code>这种编码方式但是不推荐，因为<code>text/*</code>这种MIME类型有一个US-ASCII字符集，<code>text/xml</code>会忽略xml头指定的编码格式而默认采用US-ASCII编码。</p>
</li>
</ol>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><strong>1xx：临时响应（表示请求已接收，继续处理）</strong></p>
<p><strong>2xx：请求成功</strong></p>
<p>200 OK</p>
<p><strong>3xx：重定向</strong></p>
<p>302 Move temporarily</p>
<p>304 Not Modified</p>
<p><strong>4xx：客户端请求错误</strong></p>
<p>401 Unauthorized</p>
<p>403 Forbidden</p>
<p>404 Not Found</p>
<p><strong>5xx：服务器错误</strong></p>
<p>500 Internal Server Error</p>
<p>503 Service Unavailable</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>与HTTP协议紧密相关的还有HTTPS协议，它通过SSL和HTTP协议构建可进行加密传输、身份认证的网络协议，能防止数据在传输过程中被劫持或篡改。</p>
<table>
<thead>
<tr>
<th>HTTP</th>
<th style="text-align:center">HTTPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准端口80</td>
<td style="text-align:center">标准端口443</td>
</tr>
<tr>
<td>明文传输，不安全</td>
<td style="text-align:center">具有安全性的SSL加密传输协议</td>
</tr>
<tr>
<td>无需证书</td>
<td style="text-align:center">需要CA机构颁发的SSL证书</td>
</tr>
<tr>
<td>工作在应用层</td>
<td style="text-align:center">工作在传输层？</td>
</tr>
</tbody>
</table>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://imququ.com/post/four-ways-to-post-data-in-http.html" target="_blank" rel="external">四种常见的 POST 提交数据方式</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS伪协议]]></title>
      <url>http://kad0108.github.io/2017/02/05/jsprotocol/</url>
      <content type="html"><![CDATA[<p>总能看到网页上一些a标签的链接是<code>javascript:;</code>，点击之后页面并没有跳转。下面详细说明：</p>
<h2 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h2><p>伪协议不同于因特网上所真实存在的协议，如<code>http://，https://，ftp://</code>，伪协议是为关联应用程序而使用的，如:<code>tencent://(关联QQ)</code>，<code>mailto:kad108@foxmail.com(关联电脑中Email软件)</code>，还有就是<code>javascript:;</code>。</p>
<p><code>javascript:</code>这个特殊的协议类型声明了URL的主体是javascript代码，由javascript解释器执行。在浏览器打开<code>javascript:URL</code>的时候，它会先运行URL中的代码，当返回值不为undefined的时候，前页链接会替换为这段代码的返回值。可以在浏览器地址栏输入以下URL查看效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javascript:var now = new Date(); &quot;&lt;h1&gt;The time is:&lt;/h1&gt;&quot; + now;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="javascript-与javascript-void-0"><a href="#javascript-与javascript-void-0" class="headerlink" title="javascript:;与javascript:void(0)"></a>javascript:;与javascript:void(0)</h2><p><code>javascript:</code>是表示在触发<code>&lt;a&gt;</code>默认动作时，执行一段JavaScript代码，而 <code>javascript:;</code>表示什么都不执行，这样点击a标签时就没有任何反应。</p>
<p><code>javascript:void(0)</code>, 其中<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void" target="_blank" rel="external">void运算符</a>会对给定的表达式进行求值，然后直接返回 undefined。<code>javascript:;</code>也是返回undefined，所以两种方法是等价的。</p>
<h2 id="href的值为javascript-与-click-的区别"><a href="#href的值为javascript-与-click-的区别" class="headerlink" title="href的值为javascript: 与 click 的区别"></a>href的值为javascript: 与 click 的区别</h2><ol>
<li><p>定义的scope不同，前者是global，后者可以是任何作用域</p>
</li>
<li><p>执行的context不同，前者是window，后者是a元素本身</p>
</li>
<li><p>执行的时机不同，总是click事件先执行，href=”javascript:…”后执行，所以，只能在click事件里阻止默认行为的发生，却不能在href里阻止事件的执行。</p>
</li>
</ol>
<h2 id="再看看a标签的用法"><a href="#再看看a标签的用法" class="headerlink" title="再看看a标签的用法"></a>再看看a标签的用法</h2><p>有href属性的<code>&lt;a&gt;</code>标签才有<code>cursor：pointer;</code>的效果</p>
<ol>
<li><p>点击这个链接后，会让页面跳到页面顶部，在location.href后面增加#号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>如果页面里面有id为ele的元素，会执行锚点机制跳转到这个元素上缘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;#ele&quot;&gt;&lt;/a&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>页面不跳转：三种写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt;</div><div class="line">&lt;a href=&quot;javascript :void(0);&quot;&gt;&lt;/a&gt;</div><div class="line">&lt;a href=&quot;xxxx&quot; onclick=&quot;return false;&quot;&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[隐藏页面元素的几种方法]]></title>
      <url>http://kad0108.github.io/2017/01/28/hidedom/</url>
      <content type="html"><![CDATA[<h3 id="1-opacity"><a href="#1-opacity" class="headerlink" title="1. opacity"></a>1. opacity</h3><p>从视觉上隐藏元素，但元素依然占位，响应用户交互。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">opacity: 0;</div></pre></td></tr></table></figure>
<h3 id="2-position"><a href="#2-position" class="headerlink" title="2. position"></a>2. position</h3><p>将元素移出可视区域，不影响页面布局，还可以与用户交互。应用：用Dom模拟复选框和单选框，使用这个方法来隐藏真正的checkbox和radio元素来接收焦点切换。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">position: absolute;</div><div class="line">top: -1000px;</div><div class="line">left: -1000px;</div></pre></td></tr></table></figure>
<h3 id="3-clip-path"><a href="#3-clip-path" class="headerlink" title="3. clip-path"></a>3. clip-path</h3><p>clip-path可以裁剪以隐藏元素，对元素添加下面属性即可隐藏，元素依然占位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clip-path: polygon(0 0, 0 0, 0 0, 0 0);</div></pre></td></tr></table></figure>
<h3 id="4-visibility"><a href="#4-visibility" class="headerlink" title="4. visibility"></a>4. visibility</h3><p>隐藏元素占据空间，显示元素设置为visible，只触发repaint，不响应用户交互。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">visibility: hidden;</div></pre></td></tr></table></figure>
<h3 id="5-display"><a href="#5-display" class="headerlink" title="5. display"></a>5. display</h3><p>隐藏元素不占据空间，显示时浏览器需要根据样式定义来计算元素应该出现的位置，触发reflow(有时处于性能考虑尽量减少触发reflow)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">display: none</div></pre></td></tr></table></figure>
<h3 id="6-transform"><a href="#6-transform" class="headerlink" title="6. transform"></a>6. transform</h3><p>元素所在位置会被保留，该用法对行内元素不作用。有兼容性问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">transform: scale(0);</div></pre></td></tr></table></figure>
<h3 id="7-hidden"><a href="#7-hidden" class="headerlink" title="7. hidden"></a>7. hidden</h3><p>HTML5提供的属性，和<code>display:none;</code>效果相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div hidden&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="IE下隐藏元素"><a href="#IE下隐藏元素" class="headerlink" title="IE下隐藏元素"></a>IE下隐藏元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">filter:alpha(opacity=0);</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[完善博客功能]]></title>
      <url>http://kad0108.github.io/2017/01/26/build/</url>
      <content type="html"><![CDATA[<h2 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h2><p>使用Hexo搭建了静态博客，托管到了github上可通过<a href="https://kad0108.github.io/">kad0108.github.io</a>访问。然而GitHub 屏蔽了百度爬虫，GitHub Pages 中的内容无法被百度索引。</p>
<p>然后自己也申请了域名，下面是github绑定域名时间——————</p>
<ol>
<li><p>source文件夹中新建CNAME文件（无后缀名），首行添加域名，我的是<a href="http://kadong.space/" target="_blank" rel="external">kadong.space</a>，注意前面不加<code>http://或www</code>，然后使用<code>hexo g &amp;&amp; hexo d</code>部署。</p>
</li>
<li><p>在域名解析提供商，我的域名是在万网购买。步骤：进入工作台－》域名－》解析－》域名解析－》解析设置－》添加解析。</p>
</li>
</ol>
<a id="more"></a>
<p><img src="/2017/01/26/build/domain.png" alt="domain"></p>
<h2 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h2><p>Hexo评论模块支持Disqus, 多说和友言。</p>
<p><a href="http://duoshuo.com/create-site/" target="_blank" rel="external">创建多说站点</a>，然后后面<a href="http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9" target="_blank" rel="external">配置</a>会用到站点名称。</p>
<h2 id="留言板功能"><a href="#留言板功能" class="headerlink" title="留言板功能"></a>留言板功能</h2><p>参考<a href="http://blog.csdn.net/shenshanlaoyuan/article/details/52774473" target="_blank" rel="external">这里</a>，我把留言板功能和关于我页面集合在一起。</p>
<p>在多说控制台，修改多说CSS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#ds-recent-visitors .ds-avatar &#123;</div><div class="line">	display: inline;</div><div class="line">	padding: 0 !important;</div><div class="line">	margin: 4px !important;</div><div class="line">&#125;</div><div class="line">#ds-recent-visitors div img &#123;</div><div class="line">    display: inline-block !important;</div><div class="line">    width: 56px !important;</div><div class="line">    height: 56px !important;</div><div class="line">    border-radius: 50%;</div><div class="line">    border: 1px solid #ddd;</div><div class="line">    padding: 2px;</div><div class="line">    /* box-shadow: 1px 1px 1px rgba(0,0,0, .15); */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="音乐功能"><a href="#音乐功能" class="headerlink" title="音乐功能"></a>音乐功能</h2><p>使用网易云音乐，生成外链播放器，后续继续探索如何集成多个歌曲。</p>
<p><br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS布局模型之浮动模型]]></title>
      <url>http://kad0108.github.io/2017/01/25/float/</url>
      <content type="html"><![CDATA[<h2 id="CSS的基本布局模型："><a href="#CSS的基本布局模型：" class="headerlink" title="CSS的基本布局模型："></a>CSS的基本布局模型：</h2><h3 id="Flow-Model"><a href="#Flow-Model" class="headerlink" title="Flow Model"></a>Flow Model</h3><p>流模型是Html元素默认布局</p>
<ul>
<li>块级元素：垂直分布，宽度100%</li>
<li>内联元素：水平分布，不可设宽高</li>
</ul>
<a id="more"></a>
<h3 id="Layer-Model"><a href="#Layer-Model" class="headerlink" title="Layer Model"></a>Layer Model</h3><p>层模型有三种形式：</p>
<ul>
<li>绝对定位absolute</li>
<li>相对定位relative</li>
<li>固定定位fixed</li>
</ul>
<h3 id="Float-Model"><a href="#Float-Model" class="headerlink" title="Float Model"></a>Float Model</h3><p>今天的主要学习内容：浮动模型。</p>
<p>去查看了文档，说float这个属性本来是应用于图像，使文字围绕在图像周围。这里就有了疑问，既然一直说float会让元素脱离文档流，那为什么还会让占据空间挤开文字呢？</p>
<p>Q: 脱离文档流就不占据空间了吗？<br>A: 可以这么说。更准确地一点说，是一个元素脱离文档流（out of normal flow）之后，其他的元素在定位的时候会当做没看见它，两者位置重叠都是可以的。</p>
<p>Q: 脱离文档流是不是指该元素从dom树中脱离？<br>A: 不是，用浏览器的审查元素就可以看到脱离文档流的元素（例如被float了）依然会出现在dom树里</p>
<h2 id="下面是测试时间"><a href="#下面是测试时间" class="headerlink" title="下面是测试时间"></a>下面是测试时间</h2><h3 id="在正常的flow中是这样的："><a href="#在正常的flow中是这样的：" class="headerlink" title="在正常的flow中是这样的："></a>在正常的flow中是这样的：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;father&quot;&gt;</div><div class="line">	&lt;div class=&quot;child1&quot;&gt;child one&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;child2&quot;&gt;child two&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><img src="/2017/01/25/float/float1.png" alt="normal flow"></p>
<p>可以看到两个child div是垂直排列</p>
<h3 id="在对第一个child加上浮动后："><a href="#在对第一个child加上浮动后：" class="headerlink" title="在对第一个child加上浮动后："></a>在对第一个child加上浮动后：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;father&quot;&gt;</div><div class="line">	&lt;div class=&quot;child1 float&quot;&gt;child one&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;child2&quot;&gt;child two&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><img src="/2017/01/25/float/float2.png" alt="float"></p>
<p>第一个蓝色的child1 div脱离文档流，跟在后面的第二个橙色的child2 div无视浮动元素去定位，所以它们都顶着父元素的左边和顶部边框，而且浮动元素child1覆盖了child2，但是很奇怪的是child2中的文字却看到了这个浮动元素，飘到了child1的边上。<strong>这就是float的特性：其它盒子会无视浮动元素，但其他盒子内的文本仍然会为这个元素让出位置，环绕在其周围。</strong></p>
<h3 id="那么将child1改为绝对定位呢？"><a href="#那么将child1改为绝对定位呢？" class="headerlink" title="那么将child1改为绝对定位呢？"></a>那么将child1改为绝对定位呢？</h3><p><img src="/2017/01/25/float/float3.png" alt="absolute"></p>
<p>发现child2盒子以及它的文本内容都无视了child1的存在。这是脱离文档流时float和absolute的区别。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>脱离文档流，就是将元素从普通的布局中拿走，其他盒子在定位时会无视脱离文档流的元素进行定位。float布局会其他盒子内的文本依然会为这个元素让出位置，环绕在其周围。浮动元素会生成一个块级框，也就是display:block;而不论它本身是何种元素。而absolute定位则其他盒子及其内容都会无视它。</strong></p>
<h2 id="float的缺点-amp-清除浮动"><a href="#float的缺点-amp-清除浮动" class="headerlink" title="float的缺点 &amp; 清除浮动"></a>float的缺点 &amp; 清除浮动</h2><p>当一个父元素包含了多个浮动子元素时，子元素设置了宽高，父元素的宽度不会受影响，但是<strong>高度会塌陷</strong>，解决办法清除浮动。</p>
<p>清除浮动的本质就是<strong>触发元素的BFC</strong>，让容器中的子元素不会影响到外面的元素。触发元素BFC的情况看<a href="http://kadong.space/2017/03/02/bfc/" target="_blank" rel="external">这篇博文</a>总结。</p>
<h3 id="清除浮动的几种方法"><a href="#清除浮动的几种方法" class="headerlink" title="清除浮动的几种方法"></a>清除浮动的几种方法</h3><ul>
<li>在父元素上使用“:before”和“:after”两个伪元素。使用这些伪元素，我们可以在浮动元素的父容器前面和后面创建隐藏元素。“:before”伪元素是用来防止子元素顶部的外边距塌陷，使用“display: table”创建一个匿名的“table-cell”元素。这也确保在IE6和IE7下具有一致性。“:after”伪元素是用来防止子元素的底部的外边距塌陷，以及用来清除元素的浮动。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.father:before, .father:after &#123;</div><div class="line">	content:&quot;&quot;;</div><div class="line">	display:block;</div><div class="line">	clear:both;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;father&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<ul>
<li>在容器的结束标签前添加一个空标签，在空标签上直接设置样式“clear:both”。用这种方法来清除浮动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.clearfix &#123;</div><div class="line">	clear:both;</div><div class="line">	zoom:1; /* For IE 6/7 (trigger hasLayout) */</div><div class="line">&#125;</div><div class="line">&lt;div class=&quot;father&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><p><a href="https://www.zhihu.com/question/24529373/answer/29135021" target="_blank" rel="external">脱离文档流</a></p>
</li>
<li><p><a href="http://www.w3cplus.com/css/advanced-html-css-lesson2-detailed-css-positioning.html" target="_blank" rel="external">清除浮动</a></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://kad0108.github.io/2017/01/25/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
